#!/bin/bash

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

versao() {
echo -e "                                   \e[97mVersão do SetupOrion: \e[32mv. 2.8.0\e[0m                                  "
echo -e "\e[32mhub.setuporion.com.br/grupo3      \e[97m<----- Grupos no WhatsApp ----->     \e[32mhub.setuporion.com.br/grupo4\e[0m"
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Cores do Setup

amarelo="\e[33m"
verde="\e[32m"
branco="\e[97m"
bege="\e[93m"
vermelho="\e[91m"
reset="\e[0m"

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

menu_instalador="1"

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

home_directory="$HOME"
dados_vps="${home_directory}/dados_vps/dados_vps"

dados() {
    nome_servidor=$(grep "Nome do Servidor:" "$dados_vps" | awk -F': ' '{print $2}')
    nome_rede_interna=$(grep "Rede interna:" "$dados_vps" | awk -F': ' '{print $2}')
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Licença do Setup

## copia
direitos_setup() {
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo=  $branco Este auto instalador foi desenvolvido para auxiliar na instalação das principais aplicações $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco  disponíveis no mercado open source. Já deixo todos os créditos aos desenvolvedores de cada $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco aplicação disponíveis aqui. Este Setup é licenciado sob a Licença MIT (MIT). Você pode usar, $amarelo =\e[0m"
    echo -e "$amarelo=  $branco  copiar, modificar, integrar, publicar, distribuir e/ou vender cópias dos produtos finais,  $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco   mas deve sempre declarar que OrionDesign (contato@oriondesign.art.br) é o autor original  $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco           destes códigos e atribuir um link para https://oriondesign.art.br/setup           $amarelo  =\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}

direitos_instalador() {
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo=  $branco Este auto instalador foi desenvolvido para auxiliar na instalação das principais aplicações $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco  disponíveis no mercado open source. Já deixo todos os créditos aos desenvolvedores de cada $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco aplicação disponíveis aqui. Este Setup é licenciado sob a Licença MIT (MIT). Você pode usar, $amarelo =\e[0m"
    echo -e "$amarelo=  $branco  copiar, modificar, integrar, publicar, distribuir e/ou vender cópias dos produtos finais,  $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco   mas deve sempre declarar que OrionDesign (contato@oriondesign.art.br) é o autor original  $amarelo  =\e[0m"
    echo -e "$amarelo=  $branco           destes códigos e atribuir um link para https://oriondesign.art.br/setup           $amarelo  =\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
    read -p "Ao digitar Y você aceita e concorda com as orientações passadas acima (Y/N): " choice
    while true; do
        case $choice in
            Y|y)
                return
                ;;
            N|n)
                clear
                nome_finalizado
                echo "Que pena que você não concorda, então estarei encerrando o instalador. Até mais."
                sleep 2
                clear
                exit 1
                ;;
            *)
                clear
                erro_msg
                echo ""
                echo ""
                echo "Por favor, digite apenas Y ou N."
                sleep 2
                clear
                nome_instalador
                direitos_setup
                ;;
        esac
        read -p "Ao digitar Y você aceita e concorda com as orientações passadas acima (Y/N): " choice
    done
}

## Credenciais Portainerv2.5.0+
info_credenciais(){ 
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo=  $branco A partir da versão 2.5.0 deste Setup foi implementado uma função para realizar deploy dentro $amarelo =\e[0m"
    echo -e "$amarelo=  $branco   do proprio portainer através de uma requisição api. Para que esta nova função funcione em  $amarelo =\e[0m"
    echo -e "$amarelo=  $branco suas proximas instalações, você precisará informar às credenciais de acesso do seu portainer $amarelo =\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
    
}

## Credito do Setup

creditos_msg() {
    echo ""
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=           $branco Gostaria de contribuir para continuarmos o desenvolvimento deste projeto?            $amarelo=\e[0m"
    echo -e "$amarelo=                              $branco Você pode fazer uma doação via PIX:                               $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=                                     $amarelo pix@oriondesign.art.br                                     $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=          $branco Ou faça parte da nossa comunidade VIP no Discord e contribua com o projeto            $amarelo=\e[0m"
    echo -e "$amarelo=                       $branco Nossa comunidade:$amarelo https://join.oriondesign.art.br                        $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=                                   $branco Nossos grupos no WhatsApp                                    $amarelo=\e[0m"
    echo -e "$amarelo=      $amarelo https://hub.setuporion.com.br/grupo3 $branco<-- ou -->$amarelo https://hub.setuporion.com.br/grupo4      $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}


## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Mensagens gerais

## Mensagem pedindo para preencher as informações

preencha_as_info() {
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=                          $branco Preencha as informações solicitadas abaixo                            $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}

## Mensagem pedindo para verificar se as informações estão certas

conferindo_as_info() {
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=                          $branco Verifique se os dados abaixos estão certos                            $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}

## Mensagem de Guarde os dados

guarde_os_dados_msg() {
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo=                 $branco Guarde todos os dados abaixo para evitar futuros transtornos                   $amarelo=\e[0m"
    echo -e "$amarelo=                                                                                                 $amarelo=\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}

## Mensagem de Instalando

instalando_msg() {
  echo""
  echo -e "$amarelo===================================================================================================\e[0m"
  echo -e "$amarelo=                                                                                                 =\e[0m"
  echo -e "$amarelo=      $branco  ██╗███╗   ██╗███████╗████████╗ █████╗ ██╗      █████╗ ███╗   ██╗██████╗  ██████╗   $amarelo      = \e[0m" 
  echo -e "$amarelo=      $branco  ██║████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██║     ██╔══██╗████╗  ██║██╔══██╗██╔═══██╗  $amarelo      =\e[0m"
  echo -e "$amarelo=      $branco  ██║██╔██╗ ██║███████╗   ██║   ███████║██║     ███████║██╔██╗ ██║██║  ██║██║   ██║  $amarelo      =\e[0m"
  echo -e "$amarelo=      $branco  ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║     ██╔══██║██║╚██╗██║██║  ██║██║   ██║  $amarelo      =\e[0m"
  echo -e "$amarelo=      $branco  ██║██║ ╚████║███████║   ██║   ██║  ██║███████╗██║  ██║██║ ╚████║██████╔╝╚██████╔╝  $amarelo      =\e[0m"
  echo -e "$amarelo=      $branco  ╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝   $amarelo      =\e[0m"
  echo -e "$amarelo=                                                                                                 =\e[0m"
  echo -e "$amarelo===================================================================================================\e[0m"
  echo ""
  echo ""
}

## Mensagem de Erro

erro_msg() {
   echo -e "$amarelo===================================================================================================\e[0m"
   echo -e "$amarelo=                                                                                                 =\e[0m"
   echo -e "$amarelo=                                 $branco███████╗██████╗ ██████╗  ██████╗                                $amarelo=\e[0m"
   echo -e "$amarelo=                                 $branco██╔════╝██╔══██╗██╔══██╗██╔═══██╗                               $amarelo=\e[0m"
   echo -e "$amarelo=                                 $branco█████╗  ██████╔╝██████╔╝██║   ██║                               $amarelo=\e[0m"
   echo -e "$amarelo=                                 $branco██╔══╝  ██╔══██╗██╔══██╗██║   ██║                               $amarelo=\e[0m"
   echo -e "$amarelo=                                 $branco███████╗██║  ██║██║  ██║╚██████╔╝                               $amarelo=\e[0m"
   echo -e "$amarelo=                                 $branco╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝                                $amarelo=\e[0m"
   echo -e "$amarelo=                                                                                                 =\e[0m"
   echo -e "$amarelo===================================================================================================\e[0m"
}

## Mensagem de Instalado

instalado_msg() {
    clear
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo -e "$branco     ██╗      ██╗███╗   ██╗███████╗████████╗ █████╗ ██╗      █████╗ ██████╗  ██████╗       ██╗\e[0m"
    echo -e "$branco     ╚██╗     ██║████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██║     ██╔══██╗██╔══██╗██╔═══██╗     ██╔╝\e[0m"
    echo -e "$branco      ╚██╗    ██║██╔██╗ ██║███████╗   ██║   ███████║██║     ███████║██║  ██║██║   ██║    ██╔╝ \e[0m"
    echo -e "$branco      ██╔╝    ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║     ██╔══██║██║  ██║██║   ██║    ╚██╗ \e[0m"
    echo -e "$branco     ██╔╝     ██║██║ ╚████║███████║   ██║   ██║  ██║███████╗██║  ██║██████╔╝╚██████╔╝     ╚██╗\e[0m"
    echo -e "$branco     ╚═╝      ╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝  ╚═════╝       ╚═╝\e[0m"
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}

## Mensagem de Testando

nome_testando() {
    clear
    echo ""
    echo -e "$branco               ████████╗███████╗███████╗████████╗ █████╗ ███╗   ██╗██████╗  ██████╗ \e[0m"
    echo -e "$branco               ╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗██╔═══██╗\e[0m"
    echo -e "$branco                  ██║   █████╗  ███████╗   ██║   ███████║██╔██╗ ██║██║  ██║██║   ██║\e[0m"
    echo -e "$branco                  ██║   ██╔══╝  ╚════██║   ██║   ██╔══██║██║╚██╗██║██║  ██║██║   ██║\e[0m"
    echo -e "$branco                  ██║   ███████╗███████║   ██║   ██║  ██║██║ ╚████║██████╔╝╚██████╔╝\e[0m"
    echo -e "$branco                  ╚═╝   ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ \e[0m"
    echo ""
    echo ""
}
nome_credenciais() {
    clear
    echo ""
    echo -e "$branco          ██████╗██████╗ ███████╗██████╗ ███████╗███╗   ██╗ ██████╗██╗ █████╗ ██╗███████╗      \e[0m"
    echo -e "$branco         ██╔════╝██╔══██╗██╔════╝██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔══██╗██║██╔════╝      \e[0m"
    echo -e "$branco         ██║     ██████╔╝█████╗  ██║  ██║█████╗  ██╔██╗ ██║██║     ██║███████║██║███████╗      \e[0m"
    echo -e "$branco         ██║     ██╔══██╗██╔══╝  ██║  ██║██╔══╝  ██║╚██╗██║██║     ██║██╔══██║██║╚════██║      \e[0m"
    echo -e "$branco         ╚██████╗██║  ██║███████╗██████╔╝███████╗██║ ╚████║╚██████╗██║██║  ██║██║███████║      \e[0m"
    echo -e "$branco          ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═══╝ ╚═════╝╚═╝╚═╝  ╚═╝╚═╝╚══════╝      \e[0m"
    echo -e "$branco                                                                                               \e[0m"
    echo -e "$branco   ██████╗  ██████╗     ██████╗  ██████╗ ██████╗ ████████╗ █████╗ ██╗███╗   ██╗███████╗██████╗ \e[0m"
    echo -e "$branco   ██╔══██╗██╔═══██╗    ██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██╔══██╗██║████╗  ██║██╔════╝██╔══██╗\e[0m"
    echo -e "$branco   ██║  ██║██║   ██║    ██████╔╝██║   ██║██████╔╝   ██║   ███████║██║██╔██╗ ██║█████╗  ██████╔╝\e[0m"
    echo -e "$branco   ██║  ██║██║   ██║    ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██╔══██║██║██║╚██╗██║██╔══╝  ██╔══██╗\e[0m"
    echo -e "$branco   ██████╔╝╚██████╔╝    ██║     ╚██████╔╝██║  ██║   ██║   ██║  ██║██║██║ ╚████║███████╗██║  ██║\e[0m"
    echo -e "$branco   ╚═════╝  ╚═════╝     ╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
    info_credenciais
}
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Titulos

## Nome do instalador

nome_instalador() { 
    clear
    echo ""
    echo -e "$branco       ███████╗███████╗████████╗██╗   ██╗██████╗      ██████╗ ██████╗ ██╗ ██████╗ ███╗   ██╗\e[0m"
    echo -e "$branco       ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗    ██╔═══██╗██╔══██╗██║██╔═══██╗████╗  ██║\e[0m"
    echo -e "$branco       ███████╗█████╗     ██║   ██║   ██║██████╔╝    ██║   ██║██████╔╝██║██║   ██║██╔██╗ ██║\e[0m"
    echo -e "$branco       ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝     ██║   ██║██╔══██╗██║██║   ██║██║╚██╗██║\e[0m"
    echo -e "$branco       ███████║███████╗   ██║   ╚██████╔╝██║         ╚██████╔╝██║  ██║██║╚██████╔╝██║ ╚████║\e[0m"
    echo -e "$branco       ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝          ╚═════╝ ╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝\e[0m"
    echo -e "$branco                                                                                            \e[0m"
    echo -e "$branco                                  ██████╗     █████╗     ██████╗                            \e[0m"
    echo -e "$branco                                  ╚════██╗   ██╔══██╗   ██╔═████╗                           \e[0m"
    echo -e "$branco                        █████╗     █████╔╝   ╚█████╔╝   ██║██╔██║    █████╗                 \e[0m"
    echo -e "$branco                        ╚════╝    ██╔═══╝    ██╔══██╗   ████╔╝██║    ╚════╝                 \e[0m"
    echo -e "$branco                                  ███████╗██╗╚█████╔╝██╗╚██████╔╝                           \e[0m"
    echo -e "$branco                                  ╚══════╝╚═╝ ╚════╝ ╚═╝ ╚═════╝                            \e[0m"
    echo "" 
}



## Menu de ferramentas

nome_menu() {
    clear
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo -e "$branco                    ███╗   ███╗███████╗███╗   ██╗██╗   ██╗    ██████╗ ███████╗                \e[0m"
    echo -e "$branco                    ████╗ ████║██╔════╝████╗  ██║██║   ██║    ██╔══██╗██╔════╝                \e[0m"
    echo -e "$branco                    ██╔████╔██║█████╗  ██╔██╗ ██║██║   ██║    ██║  ██║█████╗                  \e[0m"
    echo -e "$branco                    ██║╚██╔╝██║██╔══╝  ██║╚██╗██║██║   ██║    ██║  ██║██╔══╝                  \e[0m"
    echo -e "$branco                    ██║ ╚═╝ ██║███████╗██║ ╚████║╚██████╔╝    ██████╔╝███████╗                \e[0m"
    echo -e "$branco                    ╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝ ╚═════╝     ╚═════╝ ╚══════╝                \e[0m"
    echo -e "$branco                                                                                                \e[0m"
    echo -e "$branco  ███████╗███████╗██████╗ ██████╗  █████╗ ███╗   ███╗███████╗███╗   ██╗████████╗ █████╗ ███████╗\e[0m"
    echo -e "$branco  ██╔════╝██╔════╝██╔══██╗██╔══██╗██╔══██╗████╗ ████║██╔════╝████╗  ██║╚══██╔══╝██╔══██╗██╔════╝\e[0m"
    echo -e "$branco  █████╗  █████╗  ██████╔╝██████╔╝███████║██╔████╔██║█████╗  ██╔██╗ ██║   ██║   ███████║███████╗\e[0m"
    echo -e "$branco  ██╔══╝  ██╔══╝  ██╔══██╗██╔══██╗██╔══██║██║╚██╔╝██║██╔══╝  ██║╚██╗██║   ██║   ██╔══██║╚════██║\e[0m"
    echo -e "$branco  ██║     ███████╗██║  ██║██║  ██║██║  ██║██║ ╚═╝ ██║███████╗██║ ╚████║   ██║   ██║  ██║███████║\e[0m"
    echo -e "$branco  ╚═╝     ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝╚══════╝\e[0m"
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
    versao
    echo ""
}

## Titulo Teste de Email [0]

nome_testeemail() {
  clear
  echo ""
  echo -e "$branco                            ████████╗███████╗███████╗████████╗███████╗        \e[0m"  
  echo -e "$branco                            ╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██╔════╝        \e[0m"  
  echo -e "$branco                               ██║   █████╗  ███████╗   ██║   █████╗          \e[0m"  
  echo -e "$branco                               ██║   ██╔══╝  ╚════██║   ██║   ██╔══╝          \e[0m"  
  echo -e "$branco                               ██║   ███████╗███████║   ██║   ███████╗        \e[0m"  
  echo -e "$branco                               ╚═╝   ╚══════╝╚══════╝   ╚═╝   ╚══════╝        \e[0m"  
  echo -e "$branco                                                                              \e[0m"
  echo -e "$branco                      ██████╗ ███████╗    ███████╗███╗   ███╗████████╗██████╗ \e[0m"
  echo -e "$branco                      ██╔══██╗██╔════╝    ██╔════╝████╗ ████║╚══██╔══╝██╔══██╗\e[0m"
  echo -e "$branco                      ██║  ██║█████╗      ███████╗██╔████╔██║   ██║   ██████╔╝\e[0m"
  echo -e "$branco                      ██║  ██║██╔══╝      ╚════██║██║╚██╔╝██║   ██║   ██╔═══╝ \e[0m"
  echo -e "$branco                      ██████╔╝███████╗    ███████║██║ ╚═╝ ██║   ██║   ██║     \e[0m"
  echo -e "$branco                      ╚═════╝ ╚══════╝    ╚══════╝╚═╝     ╚═╝   ╚═╝   ╚═╝     \e[0m"
  echo ""
  echo ""                                                          
}

## Titulo Traefik e Portainer [1]

nome_traefik_e_portainer() {
    clear
    echo ""
    echo -e "$branco               ████████╗██████╗  █████╗ ███████╗███████╗██╗██╗  ██╗    ███████╗       \e[0m"
    echo -e "$branco               ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██║██║ ██╔╝    ██╔════╝       \e[0m"
    echo -e "$branco                  ██║   ██████╔╝███████║█████╗  █████╗  ██║█████╔╝     █████╗         \e[0m"
    echo -e "$branco                  ██║   ██╔══██╗██╔══██║██╔══╝  ██╔══╝  ██║██╔═██╗     ██╔══╝         \e[0m"
    echo -e "$branco                  ██║   ██║  ██║██║  ██║███████╗██║     ██║██║  ██╗    ███████╗       \e[0m"
    echo -e "$branco                  ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝    ╚══════╝       \e[0m"
    echo -e "$branco                                                                                      \e[0m"
    echo -e "$branco             ██████╗  ██████╗ ██████╗ ████████╗ █████╗ ██╗███╗   ██╗███████╗██████╗   \e[0m"
    echo -e "$branco             ██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██╔══██╗██║████╗  ██║██╔════╝██╔══██╗  \e[0m"
    echo -e "$branco             ██████╔╝██║   ██║██████╔╝   ██║   ███████║██║██╔██╗ ██║█████╗  ██████╔╝  \e[0m"
    echo -e "$branco             ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██╔══██║██║██║╚██╗██║██╔══╝  ██╔══██╗  \e[0m"
    echo -e "$branco             ██║     ╚██████╔╝██║  ██║   ██║   ██║  ██║██║██║ ╚████║███████╗██║  ██║  \e[0m"
    echo -e "$branco             ╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝  \e[0m"
    echo ""
    echo ""
}

nome_traefik() {
    clear
    echo ""
    echo -e "$branco                        ████████╗██████╗  █████╗ ███████╗███████╗██╗██╗  ██╗\e[0m"
    echo -e "$branco                        ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██║██║ ██╔╝\e[0m"
    echo -e "$branco                           ██║   ██████╔╝███████║█████╗  █████╗  ██║█████╔╝ \e[0m"
    echo -e "$branco                           ██║   ██╔══██╗██╔══██║██╔══╝  ██╔══╝  ██║██╔═██╗ \e[0m"
    echo -e "$branco                           ██║   ██║  ██║██║  ██║███████╗██║     ██║██║  ██╗\e[0m"
    echo -e "$branco                           ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}


## Titulo Chatwoot [2]

nome_chatwoot(){
    clear
    echo ""
    echo -e "$branco               ██████╗██╗  ██╗ █████╗ ████████╗██╗    ██╗ ██████╗  ██████╗ ████████╗\e[0m"
    echo -e "$branco              ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██║    ██║██╔═══██╗██╔═══██╗╚══██╔══╝\e[0m"
    echo -e "$branco              ██║     ███████║███████║   ██║   ██║ █╗ ██║██║   ██║██║   ██║   ██║   \e[0m"
    echo -e "$branco              ██║     ██╔══██║██╔══██║   ██║   ██║███╗██║██║   ██║██║   ██║   ██║   \e[0m"
    echo -e "$branco              ╚██████╗██║  ██║██║  ██║   ██║   ╚███╔███╔╝╚██████╔╝╚██████╔╝   ██║   \e[0m"
    echo -e "$branco               ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚══╝╚══╝  ╚═════╝  ╚═════╝    ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo Evolution [3]

nome_evolution() {
    clear
    echo ""
    echo -e "$branco ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗     █████╗ ██████╗ ██╗\e[0m"
    echo -e "$branco ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██║\e[0m"
    echo -e "$branco █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ███████║██████╔╝██║\e[0m"
    echo -e "$branco ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ██╔══██║██╔═══╝ ██║\e[0m"
    echo -e "$branco ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║    ██║  ██║██║     ██║\e[0m"
    echo -e "$branco ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""                                                                                        
}

nome_evolution_lite() {
    clear
    echo ""
    echo ""
    echo -e "$branco ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗     █████╗ ██████╗ ██╗\e[0m"
    echo -e "$branco ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██║\e[0m"
    echo -e "$branco █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ███████║██████╔╝██║\e[0m"
    echo -e "$branco ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ██╔══██║██╔═══╝ ██║\e[0m"
    echo -e "$branco ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║    ██║  ██║██║     ██║\e[0m"
    echo -e "$branco ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo -e "$branco                                                                                                  \e[0m"
    echo -e "$branco                                   ██╗     ██╗████████╗███████╗                                   \e[0m"                                  
    echo -e "$branco                                   ██║     ██║╚══██╔══╝██╔════╝                                   \e[0m"                                  
    echo -e "$branco                                   ██║     ██║   ██║   █████╗                                     \e[0m"                                  
    echo -e "$branco                                   ██║     ██║   ██║   ██╔══╝                                     \e[0m"                                  
    echo -e "$branco                                   ███████╗██║   ██║   ███████╗                                   \e[0m"                                  
    echo -e "$branco                                   ╚══════╝╚═╝   ╚═╝   ╚══════╝                                   \e[0m"  
    echo ""
    echo ""
}

## Titulo Evolution [2.beta]

nome_evolution_v2() {
    clear
    echo ""
    echo -e "$branco  ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗     █████╗ ██████╗ ██╗\e[0m"
    echo -e "$branco  ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██║\e[0m"
    echo -e "$branco  █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ███████║██████╔╝██║\e[0m"
    echo -e "$branco  ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ██╔══██║██╔═══╝ ██║\e[0m"
    echo -e "$branco  ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║    ██║  ██║██║     ██║\e[0m"
    echo -e "$branco  ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo -e "$branco                                                                                                \e[0m"
    echo -e "$branco                                    ██╗   ██╗██████╗     ██████╗                                 \e[0m"
    echo -e "$branco                                    ██║   ██║╚════██╗   ██╔═████╗                                \e[0m"
    echo -e "$branco                                    ██║   ██║ █████╔╝   ██║██╔██║                                \e[0m"
    echo -e "$branco                                    ╚██╗ ██╔╝██╔═══╝    ████╔╝██║                                \e[0m"
    echo -e "$branco                                     ╚████╔╝ ███████╗██╗╚██████╔╝                                \e[0m"
    echo -e "$branco                                      ╚═══╝  ╚══════╝╚═╝ ╚═════╝                                 \e[0m"
    echo ""
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo=                    $branco Esta é uma versão Alfa e não deve ser usada em produção.                    $amarel=\e[0m"
    echo -e "$amarelo=                                                                                                 =\e[0m"
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
}    

## Titulo Minio [4]

nome_minio() {
    clear
    echo ""
    echo -e "$branco                              ███╗   ███╗██╗███╗   ██╗██╗ ██████╗ \e[0m"
    echo -e "$branco                              ████╗ ████║██║████╗  ██║██║██╔═══██╗\e[0m"
    echo -e "$branco                              ██╔████╔██║██║██╔██╗ ██║██║██║   ██║\e[0m"
    echo -e "$branco                              ██║╚██╔╝██║██║██║╚██╗██║██║██║   ██║\e[0m"
    echo -e "$branco                              ██║ ╚═╝ ██║██║██║ ╚████║██║╚██████╔╝\e[0m"
    echo -e "$branco                              ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝ ╚═════╝ \e[0m"
    echo ""
    echo ""                                   
}

## Titulo Typebot [5]

nome_typebot() {
    clear
    echo ""
    echo -e "$branco                    ████████╗██╗   ██╗██████╗ ███████╗██████╗  ██████╗ ████████╗\e[0m"
    echo -e "$branco                    ╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗╚══██╔══╝\e[0m"
    echo -e "$branco                       ██║    ╚████╔╝ ██████╔╝█████╗  ██████╔╝██║   ██║   ██║   \e[0m"
    echo -e "$branco                       ██║     ╚██╔╝  ██╔═══╝ ██╔══╝  ██╔══██╗██║   ██║   ██║   \e[0m"
    echo -e "$branco                       ██║      ██║   ██║     ███████╗██████╔╝╚██████╔╝   ██║   \e[0m"
    echo -e "$branco                       ╚═╝      ╚═╝   ╚═╝     ╚══════╝╚═════╝  ╚═════╝    ╚═╝   \e[0m"
    echo ""
    echo ""                                                    
}

## Titulo N8N [6]

nome_n8n() {
    clear
    echo ""
    echo -e "$branco                            ███╗   ██╗ █████╗ ███╗   ██╗\e[0m"
    echo -e "$branco                            ████╗  ██║██╔══██╗████╗  ██║\e[0m"
    echo -e "$branco                            ██╔██╗ ██║╚█████╔╝██╔██╗ ██║\e[0m"
    echo -e "$branco                            ██║╚██╗██║██╔══██╗██║╚██╗██║\e[0m"
    echo -e "$branco                            ██║ ╚████║╚█████╔╝██║ ╚████║\e[0m"
    echo -e "$branco                            ╚═╝  ╚═══╝ ╚════╝ ╚═╝  ╚═══╝\e[0m"
    echo ""
    echo ""                     
}

## Titulo Flowise [7]

nome_flowise() {
    clear
    echo ""
    echo -e "$branco                      ███████╗██╗      ██████╗ ██╗    ██╗██╗███████╗███████╗\e[0m"
    echo -e "$branco                      ██╔════╝██║     ██╔═══██╗██║    ██║██║██╔════╝██╔════╝\e[0m"
    echo -e "$branco                      █████╗  ██║     ██║   ██║██║ █╗ ██║██║███████╗█████╗  \e[0m"
    echo -e "$branco                      ██╔══╝  ██║     ██║   ██║██║███╗██║██║╚════██║██╔══╝  \e[0m"
    echo -e "$branco                      ██║     ███████╗╚██████╔╝╚███╔███╔╝██║███████║███████╗\e[0m"
    echo -e "$branco                      ╚═╝     ╚══════╝ ╚═════╝  ╚══╝╚══╝ ╚═╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo PgAdmin [8]

nome_pgAdmin_4() {
    clear
    echo ""
    echo -e "$branco               ██████╗  ██████╗  █████╗ ██████╗ ███╗   ███╗██╗███╗   ██╗    ██╗  ██╗\e[0m"
    echo -e "$branco               ██╔══██╗██╔════╝ ██╔══██╗██╔══██╗████╗ ████║██║████╗  ██║    ██║  ██║\e[0m"
    echo -e "$branco               ██████╔╝██║  ███╗███████║██║  ██║██╔████╔██║██║██╔██╗ ██║    ███████║\e[0m"
    echo -e "$branco               ██╔═══╝ ██║   ██║██╔══██║██║  ██║██║╚██╔╝██║██║██║╚██╗██║    ╚════██║\e[0m"
    echo -e "$branco               ██║     ╚██████╔╝██║  ██║██████╔╝██║ ╚═╝ ██║██║██║ ╚████║         ██║\e[0m"
    echo -e "$branco               ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝         ╚═╝\e[0m"
    echo ""
    echo ""                                                                  
}

## Titulo Nocobase [9]

nome_nocobase() {
    clear
    echo ""
    echo -e "$branco               ███╗   ██╗ ██████╗  ██████╗ ██████╗ ██████╗  █████╗ ███████╗███████╗\e[0m"
    echo -e "$branco               ████╗  ██║██╔═══██╗██╔════╝██╔═══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝\e[0m"
    echo -e "$branco               ██╔██╗ ██║██║   ██║██║     ██║   ██║██████╔╝███████║███████╗█████╗  \e[0m"
    echo -e "$branco               ██║╚██╗██║██║   ██║██║     ██║   ██║██╔══██╗██╔══██║╚════██║██╔══╝  \e[0m"
    echo -e "$branco               ██║ ╚████║╚██████╔╝╚██████╗╚██████╔╝██████╔╝██║  ██║███████║███████╗\e[0m"
    echo -e "$branco               ╚═╝  ╚═══╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""                                                                 
}

## Titulo Botpress [10]

nome_botpress() {
    clear
    echo ""
    echo -e "$branco              ██████╗  ██████╗ ████████╗██████╗ ██████╗ ███████╗███████╗███████╗\e[0m"
    echo -e "$branco              ██╔══██╗██╔═══██╗╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██╔════╝\e[0m"
    echo -e "$branco              ██████╔╝██║   ██║   ██║   ██████╔╝██████╔╝█████╗  ███████╗███████╗\e[0m"
    echo -e "$branco              ██╔══██╗██║   ██║   ██║   ██╔═══╝ ██╔══██╗██╔══╝  ╚════██║╚════██║\e[0m"
    echo -e "$branco              ██████╔╝╚██████╔╝   ██║   ██║     ██║  ██║███████╗███████║███████║\e[0m"
    echo -e "$branco              ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""                                                          
}

## Titulo Wordpress [11]

nome_wordpress() {
    clear
    echo ""
    echo -e "$branco           ██╗    ██╗ ██████╗ ██████╗ ██████╗ ██████╗ ██████╗ ███████╗███████╗███████╗\e[0m"
    echo -e "$branco           ██║    ██║██╔═══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝██╔════╝\e[0m"
    echo -e "$branco           ██║ █╗ ██║██║   ██║██████╔╝██║  ██║██████╔╝██████╔╝█████╗  ███████╗███████╗\e[0m"
    echo -e "$branco           ██║███╗██║██║   ██║██╔══██╗██║  ██║██╔═══╝ ██╔══██╗██╔══╝  ╚════██║╚════██║\e[0m"
    echo -e "$branco           ╚███╔███╔╝╚██████╔╝██║  ██║██████╔╝██║     ██║  ██║███████╗███████║███████║\e[0m"
    echo -e "$branco            ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Baserow [12]

nome_baserow() {
    clear
    echo ""
    echo -e "$branco                      ██████╗  █████╗ ███████╗███████╗██████╗  ██████╗ ██╗    ██╗\e[0m"
    echo -e "$branco                      ██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔═══██╗██║    ██║\e[0m"
    echo -e "$branco                      ██████╔╝███████║███████╗█████╗  ██████╔╝██║   ██║██║ █╗ ██║\e[0m"
    echo -e "$branco                      ██╔══██╗██╔══██║╚════██║██╔══╝  ██╔══██╗██║   ██║██║███╗██║\e[0m"
    echo -e "$branco                      ██████╔╝██║  ██║███████║███████╗██║  ██║╚██████╔╝╚███╔███╔╝\e[0m"
    echo -e "$branco                      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝ \e[0m"
    echo ""
    echo ""                                                          
}

## Titulo MongoDB [13]

nome_mongodb() {
  clear
  echo ""
  echo -e "$branco               ███╗   ███╗ ██████╗ ███╗   ██╗ ██████╗  ██████╗     ██████╗ ██████╗ \e[0m"
  echo -e "$branco               ████╗ ████║██╔═══██╗████╗  ██║██╔════╝ ██╔═══██╗    ██╔══██╗██╔══██╗\e[0m"
  echo -e "$branco               ██╔████╔██║██║   ██║██╔██╗ ██║██║  ███╗██║   ██║    ██║  ██║██████╔╝\e[0m"
  echo -e "$branco               ██║╚██╔╝██║██║   ██║██║╚██╗██║██║   ██║██║   ██║    ██║  ██║██╔══██╗\e[0m"
  echo -e "$branco               ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║╚██████╔╝╚██████╔╝    ██████╔╝██████╔╝\e[0m"
  echo -e "$branco               ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝  ╚═════╝     ╚═════╝ ╚═════╝ \e[0m"
  echo ""
  echo ""                                                               
}

## Titulo RabbitMQ [14]

nome_rabbitmq() {
  clear
  echo ""
  echo -e "$branco               ██████╗  █████╗ ██████╗ ██████╗ ██╗████████╗    ███╗   ███╗ ██████╗ \e[0m"
  echo -e "$branco               ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██║╚══██╔══╝    ████╗ ████║██╔═══██╗\e[0m"
  echo -e "$branco               ██████╔╝███████║██████╔╝██████╔╝██║   ██║       ██╔████╔██║██║   ██║\e[0m"
  echo -e "$branco               ██╔══██╗██╔══██║██╔══██╗██╔══██╗██║   ██║       ██║╚██╔╝██║██║▄▄ ██║\e[0m"
  echo -e "$branco               ██║  ██║██║  ██║██████╔╝██████╔╝██║   ██║       ██║ ╚═╝ ██║╚██████╔╝\e[0m"
  echo -e "$branco               ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚═════╝ ╚═╝   ╚═╝       ╚═╝     ╚═╝ ╚══▀▀═╝ \e[0m"
  echo ""
  echo ""                                                                 
}

## Titulo UptimeKuma [15]

nome_uptimekuma() {
  clear
  echo ""
  echo -e "$branco      ██╗   ██╗██████╗ ████████╗██╗███╗   ███╗███████╗    ██╗  ██╗██╗   ██╗███╗   ███╗ █████╗ \e[0m"
  echo -e "$branco      ██║   ██║██╔══██╗╚══██╔══╝██║████╗ ████║██╔════╝    ██║ ██╔╝██║   ██║████╗ ████║██╔══██╗\e[0m"
  echo -e "$branco      ██║   ██║██████╔╝   ██║   ██║██╔████╔██║█████╗      █████╔╝ ██║   ██║██╔████╔██║███████║\e[0m"
  echo -e "$branco      ██║   ██║██╔═══╝    ██║   ██║██║╚██╔╝██║██╔══╝      ██╔═██╗ ██║   ██║██║╚██╔╝██║██╔══██║\e[0m"
  echo -e "$branco      ╚██████╔╝██║        ██║   ██║██║ ╚═╝ ██║███████╗    ██║  ██╗╚██████╔╝██║ ╚═╝ ██║██║  ██║\e[0m"
  echo -e "$branco       ╚═════╝ ╚═╝        ╚═╝   ╚═╝╚═╝     ╚═╝╚══════╝    ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝\e[0m"
  echo ""
  echo ""
}

## Titulo Calcom [16]

nome_calcom() {
  clear
  echo ""
  echo -e "$branco                       ██████╗ █████╗ ██╗         ██████╗ ██████╗ ███╗   ███╗\e[0m"
  echo -e "$branco                      ██╔════╝██╔══██╗██║        ██╔════╝██╔═══██╗████╗ ████║\e[0m"
  echo -e "$branco                      ██║     ███████║██║        ██║     ██║   ██║██╔████╔██║\e[0m"
  echo -e "$branco                      ██║     ██╔══██║██║        ██║     ██║   ██║██║╚██╔╝██║\e[0m"
  echo -e "$branco                      ╚██████╗██║  ██║███████╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\e[0m"
  echo -e "$branco                       ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝\e[0m"
  echo ""
  echo ""
}

## Titulo Mautic [17]

nome_mautic(){
    clear
    echo ""
    echo -e "$branco                         ███╗   ███╗ █████╗ ██╗   ██╗████████╗██╗ ██████╗\e[0m"
    echo -e "$branco                         ████╗ ████║██╔══██╗██║   ██║╚══██╔══╝██║██╔════╝\e[0m"
    echo -e "$branco                         ██╔████╔██║███████║██║   ██║   ██║   ██║██║     \e[0m"
    echo -e "$branco                         ██║╚██╔╝██║██╔══██║██║   ██║   ██║   ██║██║     \e[0m"
    echo -e "$branco                         ██║ ╚═╝ ██║██║  ██║╚██████╔╝   ██║   ██║╚██████╗\e[0m"
    echo -e "$branco                         ╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝\e[0m"
    echo ""
    echo ""                                              
}

## Titulo Appsmith [18]

nome_appsmith() {
    clear
    echo ""
    echo -e "$branco                   █████╗ ██████╗ ██████╗ ███████╗███╗   ███╗██╗████████╗██╗  ██╗\e[0m"
    echo -e "$branco                  ██╔══██╗██╔══██╗██╔══██╗██╔════╝████╗ ████║██║╚══██╔══╝██║  ██║\e[0m"
    echo -e "$branco                  ███████║██████╔╝██████╔╝███████╗██╔████╔██║██║   ██║   ███████║\e[0m"
    echo -e "$branco                  ██╔══██║██╔═══╝ ██╔═══╝ ╚════██║██║╚██╔╝██║██║   ██║   ██╔══██║\e[0m"
    echo -e "$branco                  ██║  ██║██║     ██║     ███████║██║ ╚═╝ ██║██║   ██║   ██║  ██║\e[0m"
    echo -e "$branco                  ╚═╝  ╚═╝╚═╝     ╚═╝     ╚══════╝╚═╝     ╚═╝╚═╝   ╚═╝   ╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Qdrant [19]

nome_qdrant() {
    clear
    echo ""
    echo -e "$branco                        ██████╗ ██████╗ ██████╗  █████╗ ███╗   ██╗████████╗\e[0m"
    echo -e "$branco                       ██╔═══██╗██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══██╔══╝\e[0m"
    echo -e "$branco                       ██║   ██║██║  ██║██████╔╝███████║██╔██╗ ██║   ██║   \e[0m"
    echo -e "$branco                       ██║▄▄ ██║██║  ██║██╔══██╗██╔══██║██║╚██╗██║   ██║   \e[0m"
    echo -e "$branco                       ╚██████╔╝██████╔╝██║  ██║██║  ██║██║ ╚████║   ██║   \e[0m"
    echo -e "$branco                        ╚══▀▀═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo WoofedCRM [20]

nome_woofedcrm() {
    clear
    echo ""
    echo -e "$branco        ██╗    ██╗ ██████╗  ██████╗ ███████╗███████╗██████╗      ██████╗██████╗ ███╗   ███╗\e[0m"
    echo -e "$branco        ██║    ██║██╔═══██╗██╔═══██╗██╔════╝██╔════╝██╔══██╗    ██╔════╝██╔══██╗████╗ ████║\e[0m"
    echo -e "$branco        ██║ █╗ ██║██║   ██║██║   ██║█████╗  █████╗  ██║  ██║    ██║     ██████╔╝██╔████╔██║\e[0m"
    echo -e "$branco        ██║███╗██║██║   ██║██║   ██║██╔══╝  ██╔══╝  ██║  ██║    ██║     ██╔══██╗██║╚██╔╝██║\e[0m"
    echo -e "$branco        ╚███╔███╔╝╚██████╔╝╚██████╔╝██║     ███████╗██████╔╝    ╚██████╗██║  ██║██║ ╚═╝ ██║\e[0m"
    echo -e "$branco         ╚══╝╚══╝  ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝╚═════╝      ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Formbricks [21]

nome_formbricks() {
    clear
    echo ""
    echo -e "$branco          ███████╗ ██████╗ ██████╗ ███╗   ███╗██████╗ ██████╗ ██╗ ██████╗██╗  ██╗███████╗\e[0m"
    echo -e "$branco          ██╔════╝██╔═══██╗██╔══██╗████╗ ████║██╔══██╗██╔══██╗██║██╔════╝██║ ██╔╝██╔════╝\e[0m"
    echo -e "$branco          █████╗  ██║   ██║██████╔╝██╔████╔██║██████╔╝██████╔╝██║██║     █████╔╝ ███████╗\e[0m"
    echo -e "$branco          ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║██╔══██╗██╔══██╗██║██║     ██╔═██╗ ╚════██║\e[0m"
    echo -e "$branco          ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║██████╔╝██║  ██║██║╚██████╗██║  ██╗███████║\e[0m"
    echo -e "$branco          ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚═════╝ ╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo NocoDB [22]

nome_nocodb() {
    clear
    echo ""
    echo -e "$branco                       ███╗   ██╗ ██████╗  ██████╗ ██████╗ ██████╗ ██████╗ \e[0m"
    echo -e "$branco                       ████╗  ██║██╔═══██╗██╔════╝██╔═══██╗██╔══██╗██╔══██╗\e[0m"
    echo -e "$branco                       ██╔██╗ ██║██║   ██║██║     ██║   ██║██║  ██║██████╔╝\e[0m"
    echo -e "$branco                       ██║╚██╗██║██║   ██║██║     ██║   ██║██║  ██║██╔══██╗\e[0m"
    echo -e "$branco                       ██║ ╚████║╚██████╔╝╚██████╗╚██████╔╝██████╔╝██████╔╝\e[0m"
    echo -e "$branco                       ╚═╝  ╚═══╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚═════╝ ╚═════╝ \e[0m"
    echo ""
    echo ""                                                 
}

## Titulo Langfuse [23]

nome_langfuse() {
    clear
    echo ""
    echo -e "$branco               ██╗      █████╗ ███╗   ██╗ ██████╗ ███████╗██╗   ██╗███████╗███████╗\e[0m"
    echo -e "$branco               ██║     ██╔══██╗████╗  ██║██╔════╝ ██╔════╝██║   ██║██╔════╝██╔════╝\e[0m"
    echo -e "$branco               ██║     ███████║██╔██╗ ██║██║  ███╗█████╗  ██║   ██║███████╗█████╗  \e[0m"
    echo -e "$branco               ██║     ██╔══██║██║╚██╗██║██║   ██║██╔══╝  ██║   ██║╚════██║██╔══╝  \e[0m"
    echo -e "$branco               ███████╗██║  ██║██║ ╚████║╚██████╔╝██║     ╚██████╔╝███████║███████╗\e[0m"
    echo -e "$branco               ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝      ╚═════╝ ╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Metabase [24]

nome_metabase() {
    clear
    echo ""
    echo -e "$branco               ███╗   ███╗███████╗████████╗ █████╗ ██████╗  █████╗ ███████╗███████╗\e[0m"
    echo -e "$branco               ████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝\e[0m"
    echo -e "$branco               ██╔████╔██║█████╗     ██║   ███████║██████╔╝███████║███████╗█████╗  \e[0m"
    echo -e "$branco               ██║╚██╔╝██║██╔══╝     ██║   ██╔══██║██╔══██╗██╔══██║╚════██║██╔══╝  \e[0m"
    echo -e "$branco               ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║██████╔╝██║  ██║███████║███████╗\e[0m"
    echo -e "$branco               ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}   

## Titulo Odoo [25]

nome_odoo() {
    clear
    echo ""
    echo -e "$branco                                 ██████╗ ██████╗  ██████╗  ██████╗ \e[0m"
    echo -e "$branco                                ██╔═══██╗██╔══██╗██╔═══██╗██╔═══██╗\e[0m"
    echo -e "$branco                                ██║   ██║██║  ██║██║   ██║██║   ██║\e[0m"
    echo -e "$branco                                ██║   ██║██║  ██║██║   ██║██║   ██║\e[0m"
    echo -e "$branco                                ╚██████╔╝██████╔╝╚██████╔╝╚██████╔╝\e[0m"
    echo -e "$branco                                 ╚═════╝ ╚═════╝  ╚═════╝  ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Chatwoot Nestor [26]
nome_chatwoot_nestor(){
    clear
    echo ""
    echo -e "$branco               ██████╗██╗  ██╗ █████╗ ████████╗██╗    ██╗ ██████╗  ██████╗ ████████╗\e[0m"
    echo -e "$branco              ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██║    ██║██╔═══██╗██╔═══██╗╚══██╔══╝\e[0m"
    echo -e "$branco              ██║     ███████║███████║   ██║   ██║ █╗ ██║██║   ██║██║   ██║   ██║   \e[0m"
    echo -e "$branco              ██║     ██╔══██║██╔══██║   ██║   ██║███╗██║██║   ██║██║   ██║   ██║   \e[0m"
    echo -e "$branco              ╚██████╗██║  ██║██║  ██║   ██║   ╚███╔███╔╝╚██████╔╝╚██████╔╝   ██║   \e[0m"
    echo -e "$branco               ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚══╝╚══╝  ╚═════╝  ╚═════╝    ╚═╝   \e[0m"
    echo -e "$branco                      ███╗   ██╗███████╗███████╗████████╗ ██████╗ ██████╗           \e[0m"
    echo -e "$branco                      ████╗  ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗          \e[0m"
    echo -e "$branco                      ██╔██╗ ██║█████╗  ███████╗   ██║   ██║   ██║██████╔╝          \e[0m"
    echo -e "$branco                      ██║╚██╗██║██╔══╝  ╚════██║   ██║   ██║   ██║██╔══██╗          \e[0m"
    echo -e "$branco                      ██║ ╚████║███████╗███████║   ██║   ╚██████╔╝██║  ██║          \e[0m"
    echo -e "$branco                      ╚═╝  ╚═══╝╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝          \e[0m"
    echo ""
    echo ""
}

nome_unoapi() {
    clear
    echo ""
    echo -e "$branco                     ██╗   ██╗███╗   ██╗ ██████╗      █████╗ ██████╗ ██╗\e[0m"
    echo -e "$branco                     ██║   ██║████╗  ██║██╔═══██╗    ██╔══██╗██╔══██╗██║\e[0m"
    echo -e "$branco                     ██║   ██║██╔██╗ ██║██║   ██║    ███████║██████╔╝██║\e[0m"
    echo -e "$branco                     ██║   ██║██║╚██╗██║██║   ██║    ██╔══██║██╔═══╝ ██║\e[0m"
    echo -e "$branco                     ╚██████╔╝██║ ╚████║╚██████╔╝    ██║  ██║██║     ██║\e[0m"
    echo -e "$branco                      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝     ╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Uno API [27]

nome_n8n_quepasa(){
    clear
    echo ""
    echo -e "$branco         ███╗   ██╗ █████╗ ███╗   ██╗    ███╗   ██╗ ██████╗ ██████╗ ███████╗███████╗\e[0m"
    echo -e "$branco         ████╗  ██║██╔══██╗████╗  ██║    ████╗  ██║██╔═══██╗██╔══██╗██╔════╝██╔════╝\e[0m"
    echo -e "$branco         ██╔██╗ ██║╚█████╔╝██╔██╗ ██║    ██╔██╗ ██║██║   ██║██║  ██║█████╗  ███████╗\e[0m"
    echo -e "$branco         ██║╚██╗██║██╔══██╗██║╚██╗██║    ██║╚██╗██║██║   ██║██║  ██║██╔══╝  ╚════██║\e[0m"
    echo -e "$branco         ██║ ╚████║╚█████╔╝██║ ╚████║    ██║ ╚████║╚██████╔╝██████╔╝███████╗███████║\e[0m"
    echo -e "$branco         ╚═╝  ╚═══╝ ╚════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═══╝ ╚═════╝ ╚═════╝ ╚══════╝╚══════╝\e[0m"
    echo -e "$branco                                                                                       \e[0m"                            
    echo -e "$branco        ██████╗  ██████╗      ██████╗ ██╗   ██╗███████╗██████╗  █████╗ ███████╗ █████╗ \e[0m"                
    echo -e "$branco        ██╔══██╗██╔═══██╗    ██╔═══██╗██║   ██║██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗\e[0m"                
    echo -e "$branco        ██║  ██║██║   ██║    ██║   ██║██║   ██║█████╗  ██████╔╝███████║███████╗███████║\e[0m"                
    echo -e "$branco        ██║  ██║██║   ██║    ██║▄▄ ██║██║   ██║██╔══╝  ██╔═══╝ ██╔══██║╚════██║██╔══██║\e[0m"                
    echo -e "$branco        ██████╔╝╚██████╔╝    ╚██████╔╝╚██████╔╝███████╗██║     ██║  ██║███████║██║  ██║\e[0m"                
    echo -e "$branco        ╚═════╝  ╚═════╝      ╚══▀▀═╝  ╚═════╝ ╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\e[0m"                                                                                                                           
    echo ""
    echo ""
}

## Titulo Quepasa API [29]

nome_quepasa() {
    clear
    echo ""
    echo -e "$branco                  ██████╗ ██╗   ██╗███████╗██████╗  █████╗ ███████╗ █████╗ \e[0m"
    echo -e "$branco                 ██╔═══██╗██║   ██║██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗\e[0m"
    echo -e "$branco                 ██║   ██║██║   ██║█████╗  ██████╔╝███████║███████╗███████║\e[0m"
    echo -e "$branco                 ██║▄▄ ██║██║   ██║██╔══╝  ██╔═══╝ ██╔══██║╚════██║██╔══██║\e[0m"
    echo -e "$branco                 ╚██████╔╝╚██████╔╝███████╗██║     ██║  ██║███████║██║  ██║\e[0m"
    echo -e "$branco                  ╚══▀▀═╝  ╚═════╝ ╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Docuseal [30]

nome_docuseal(){
    clear
    echo ""
    echo -e "$branco                ██████╗  ██████╗  ██████╗██╗   ██╗███████╗███████╗ █████╗ ██╗     \e[0m"
    echo -e "$branco                ██╔══██╗██╔═══██╗██╔════╝██║   ██║██╔════╝██╔════╝██╔══██╗██║     \e[0m"
    echo -e "$branco                ██║  ██║██║   ██║██║     ██║   ██║███████╗█████╗  ███████║██║     \e[0m"
    echo -e "$branco                ██║  ██║██║   ██║██║     ██║   ██║╚════██║██╔══╝  ██╔══██║██║     \e[0m"
    echo -e "$branco                ██████╔╝╚██████╔╝╚██████╗╚██████╔╝███████║███████╗██║  ██║███████╗\e[0m"
    echo -e "$branco                ╚═════╝  ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Grafana + Prometheus + cAdvisor [31]

nome_monitor() {
    clear
    echo ""
    echo -e "$branco                     ██████╗ ██████╗  █████╗ ███████╗ █████╗ ███╗   ██╗ █████╗ \e[0m"
    echo -e "$branco                    ██╔════╝ ██╔══██╗██╔══██╗██╔════╝██╔══██╗████╗  ██║██╔══██╗\e[0m"
    echo -e "$branco                    ██║  ███╗██████╔╝███████║█████╗  ███████║██╔██╗ ██║███████║\e[0m"
    echo -e "$branco                    ██║   ██║██╔══██╗██╔══██║██╔══╝  ██╔══██║██║╚██╗██║██╔══██║\e[0m"
    echo -e "$branco                    ╚██████╔╝██║  ██║██║  ██║██║     ██║  ██║██║ ╚████║██║  ██║\e[0m"
    echo -e "$branco                     ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Dify AI [32]

nome_dify() {
    clear
    echo ""
    echo -e "$branco                            ██████╗ ██╗███████╗██╗   ██╗ █████╗ ██╗\e[0m"
    echo -e "$branco                            ██╔══██╗██║██╔════╝╚██╗ ██╔╝██╔══██╗██║\e[0m"
    echo -e "$branco                            ██║  ██║██║█████╗   ╚████╔╝ ███████║██║\e[0m"
    echo -e "$branco                            ██║  ██║██║██╔══╝    ╚██╔╝  ██╔══██║██║\e[0m"
    echo -e "$branco                            ██████╔╝██║██║        ██║██╗██║  ██║██║\e[0m"
    echo -e "$branco                            ╚═════╝ ╚═╝╚═╝        ╚═╝╚═╝╚═╝  ╚═╝╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Ollama [33]

nome_ollama() {
    clear
    echo ""
    echo -e "$branco                            ██████╗ ██╗     ██╗      █████╗ ███╗   ███╗ █████╗ \e[0m"
    echo -e "$branco                           ██╔═══██╗██║     ██║     ██╔══██╗████╗ ████║██╔══██╗\e[0m"
    echo -e "$branco                           ██║   ██║██║     ██║     ███████║██╔████╔██║███████║\e[0m"
    echo -e "$branco                           ██║   ██║██║     ██║     ██╔══██║██║╚██╔╝██║██╔══██║\e[0m"
    echo -e "$branco                           ╚██████╔╝███████╗███████╗██║  ██║██║ ╚═╝ ██║██║  ██║\e[0m"
    echo -e "$branco                            ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""                                   
}

## Titulo Affine [34]

nome_affine(){
    clear
    echo ""
    echo -e "$branco                         █████╗ ███████╗███████╗██╗███╗   ██╗███████╗\e[0m"
    echo -e "$branco                        ██╔══██╗██╔════╝██╔════╝██║████╗  ██║██╔════╝\e[0m"
    echo -e "$branco                        ███████║█████╗  █████╗  ██║██╔██╗ ██║█████╗  \e[0m"
    echo -e "$branco                        ██╔══██║██╔══╝  ██╔══╝  ██║██║╚██╗██║██╔══╝  \e[0m"
    echo -e "$branco                        ██║  ██║██║     ██║     ██║██║ ╚████║███████╗\e[0m"
    echo -e "$branco                        ╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚═╝  ╚═══╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Directus [35]

nome_directus(){
clear
echo ""
echo -e "$branco                   ██████╗ ██╗██████╗ ███████╗ ██████╗████████╗██╗   ██╗███████╗\e[0m"
echo -e "$branco                   ██╔══██╗██║██╔══██╗██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔════╝\e[0m"
echo -e "$branco                   ██║  ██║██║██████╔╝█████╗  ██║        ██║   ██║   ██║███████╗\e[0m"
echo -e "$branco                   ██║  ██║██║██╔══██╗██╔══╝  ██║        ██║   ██║   ██║╚════██║\e[0m"
echo -e "$branco                   ██████╔╝██║██║  ██║███████╗╚██████╗   ██║   ╚██████╔╝███████║\e[0m"
echo -e "$branco                   ╚═════╝ ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚══════╝\e[0m"
echo ""
echo ""
}

## Titulo VaultWarden [36]

nome_vaultwarden() {
    clear
    echo ""
    echo -e "$branco   ██╗   ██╗ █████╗ ██╗   ██╗██╗  ████████╗██╗    ██╗ █████╗ ██████╗ ██████╗ ███████╗███╗   ██╗\e[0m"
    echo -e "$branco   ██║   ██║██╔══██╗██║   ██║██║  ╚══██╔══╝██║    ██║██╔══██╗██╔══██╗██╔══██╗██╔════╝████╗  ██║\e[0m"
    echo -e "$branco   ██║   ██║███████║██║   ██║██║     ██║   ██║ █╗ ██║███████║██████╔╝██║  ██║█████╗  ██╔██╗ ██║\e[0m"
    echo -e "$branco   ╚██╗ ██╔╝██╔══██║██║   ██║██║     ██║   ██║███╗██║██╔══██║██╔══██╗██║  ██║██╔══╝  ██║╚██╗██║\e[0m"
    echo -e "$branco    ╚████╔╝ ██║  ██║╚██████╔╝███████╗██║   ╚███╔███╔╝██║  ██║██║  ██║██████╔╝███████╗██║ ╚████║\e[0m"
    echo -e "$branco     ╚═══╝  ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝    ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚═╝  ╚═══╝\e[0m"
    echo ""
    echo ""
}

## Titulo NextCloud [37]

nome_nextcloud() {
    clear
    echo ""
    echo -e "$branco           ███╗   ██╗███████╗██╗  ██╗████████╗ ██████╗██╗      ██████╗ ██╗   ██╗██████╗ \e[0m"
    echo -e "$branco           ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝██╔════╝██║     ██╔═══██╗██║   ██║██╔══██╗\e[0m"
    echo -e "$branco           ██╔██╗ ██║█████╗   ╚███╔╝    ██║   ██║     ██║     ██║   ██║██║   ██║██║  ██║\e[0m"
    echo -e "$branco           ██║╚██╗██║██╔══╝   ██╔██╗    ██║   ██║     ██║     ██║   ██║██║   ██║██║  ██║\e[0m"
    echo -e "$branco           ██║ ╚████║███████╗██╔╝ ██╗   ██║   ╚██████╗███████╗╚██████╔╝╚██████╔╝██████╔╝\e[0m"
    echo -e "$branco           ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝    ╚═════╝╚══════╝ ╚═════╝  ╚═════╝ ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Strapi [38]

nome_strapi() {
    clear
    echo ""
    echo -e "$branco                         ███████╗████████╗██████╗  █████╗ ██████╗ ██╗\e[0m"
    echo -e "$branco                         ██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██║\e[0m"
    echo -e "$branco                         ███████╗   ██║   ██████╔╝███████║██████╔╝██║\e[0m"
    echo -e "$branco                         ╚════██║   ██║   ██╔══██╗██╔══██║██╔═══╝ ██║\e[0m"
    echo -e "$branco                         ███████║   ██║   ██║  ██║██║  ██║██║     ██║\e[0m"
    echo -e "$branco                         ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo PhpMyAdmin [39]

nome_phpmyadmin(){
    clear
    echo "" 
    echo -e "$branco    ██████╗ ██╗  ██╗██████╗     ███╗   ███╗██╗   ██╗     █████╗ ██████╗ ███╗   ███╗██╗███╗   ██╗\e[0m"
    echo -e "$branco    ██╔══██╗██║  ██║██╔══██╗    ████╗ ████║╚██╗ ██╔╝    ██╔══██╗██╔══██╗████╗ ████║██║████╗  ██║\e[0m"
    echo -e "$branco    ██████╔╝███████║██████╔╝    ██╔████╔██║ ╚████╔╝     ███████║██║  ██║██╔████╔██║██║██╔██╗ ██║\e[0m"
    echo -e "$branco    ██╔═══╝ ██╔══██║██╔═══╝     ██║╚██╔╝██║  ╚██╔╝      ██╔══██║██║  ██║██║╚██╔╝██║██║██║╚██╗██║\e[0m"
    echo -e "$branco    ██║     ██║  ██║██║         ██║ ╚═╝ ██║   ██║       ██║  ██║██████╔╝██║ ╚═╝ ██║██║██║ ╚████║\e[0m"
    echo -e "$branco    ╚═╝     ╚═╝  ╚═╝╚═╝         ╚═╝     ╚═╝   ╚═╝       ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝\e[0m"
    echo "" 
    echo "" 
}

## Titulo Supabase [40]

nome_supabase(){
    clear
    echo ""
    echo -e "$branco              ███████╗██╗   ██╗██████╗  █████╗ ██████╗  █████╗ ███████╗███████╗\e[0m"
    echo -e "$branco              ██╔════╝██║   ██║██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝\e[0m"
    echo -e "$branco              ███████╗██║   ██║██████╔╝███████║██████╔╝███████║███████╗█████╗  \e[0m"
    echo -e "$branco              ╚════██║██║   ██║██╔═══╝ ██╔══██║██╔══██╗██╔══██║╚════██║██╔══╝  \e[0m"
    echo -e "$branco              ███████║╚██████╔╝██║     ██║  ██║██████╔╝██║  ██║███████║███████╗\e[0m"
    echo -e "$branco              ╚══════╝ ╚═════╝ ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝\e[0m"
    echo "" 
    echo "" 
}

## Titulo Ntfy [41]

nome_ntfy(){
    clear
    echo ""
    echo -e "$branco                                ███╗   ██╗████████╗███████╗██╗   ██╗\e[0m"
    echo -e "$branco                                ████╗  ██║╚══██╔══╝██╔════╝╚██╗ ██╔╝\e[0m"
    echo -e "$branco                                ██╔██╗ ██║   ██║   █████╗   ╚████╔╝ \e[0m"
    echo -e "$branco                                ██║╚██╗██║   ██║   ██╔══╝    ╚██╔╝  \e[0m"
    echo -e "$branco                                ██║ ╚████║   ██║   ██║        ██║   \e[0m"
    echo -e "$branco                                ╚═╝  ╚═══╝   ╚═╝   ╚═╝        ╚═╝   \e[0m"
    echo "" 
    echo ""
}
 
## Titulo Lowcoder [42]

nome_lowcoder(){
    clear
    echo ""
    echo -e "$branco               ██╗      ██████╗ ██╗    ██╗ ██████╗ ██████╗ ██████╗ ███████╗██████╗ \e[0m"
    echo -e "$branco               ██║     ██╔═══██╗██║    ██║██╔════╝██╔═══██╗██╔══██╗██╔════╝██╔══██╗\e[0m"
    echo -e "$branco               ██║     ██║   ██║██║ █╗ ██║██║     ██║   ██║██║  ██║█████╗  ██████╔╝\e[0m"
    echo -e "$branco               ██║     ██║   ██║██║███╗██║██║     ██║   ██║██║  ██║██╔══╝  ██╔══██╗\e[0m"
    echo -e "$branco               ███████╗╚██████╔╝╚███╔███╔╝╚██████╗╚██████╔╝██████╔╝███████╗██║  ██║\e[0m"
    echo -e "$branco               ╚══════╝ ╚═════╝  ╚══╝╚══╝  ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""  
}

## Titulo Langflow [43]

nome_langflow() {
    clear
    echo ""
    echo -e "$branco               ██╗      █████╗ ███╗   ██╗ ██████╗ ███████╗██╗      ██████╗ ██╗    ██╗\e[0m"
    echo -e "$branco               ██║     ██╔══██╗████╗  ██║██╔════╝ ██╔════╝██║     ██╔═══██╗██║    ██║\e[0m"
    echo -e "$branco               ██║     ███████║██╔██╗ ██║██║  ███╗█████╗  ██║     ██║   ██║██║ █╗ ██║\e[0m"
    echo -e "$branco               ██║     ██╔══██║██║╚██╗██║██║   ██║██╔══╝  ██║     ██║   ██║██║███╗██║\e[0m"
    echo -e "$branco               ███████╗██║  ██║██║ ╚████║╚██████╔╝██║     ███████╗╚██████╔╝╚███╔███╔╝\e[0m"
    echo -e "$branco               ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝  ╚══╝╚══╝ \e[0m"
    echo ""
    echo ""
}

## Titulo OpenProject [44]

nome_openproject() {
    clear
    echo ""
    echo -e "$branco   ██████╗ ██████╗ ███████╗███╗   ██╗    ██████╗ ██████╗  ██████╗      ██╗███████╗ ██████╗████████╗\e[0m"
    echo -e "$branco  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║    ██╔══██╗██╔══██╗██╔═══██╗     ██║██╔════╝██╔════╝╚══██╔══╝\e[0m"
    echo -e "$branco  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║    ██████╔╝██████╔╝██║   ██║     ██║█████╗  ██║        ██║   \e[0m"
    echo -e "$branco  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║    ██╔═══╝ ██╔══██╗██║   ██║██   ██║██╔══╝  ██║        ██║   \e[0m"
    echo -e "$branco  ╚██████╔╝██║     ███████╗██║ ╚████║    ██║     ██║  ██║╚██████╔╝╚█████╔╝███████╗╚██████╗   ██║   \e[0m"
    echo -e "$branco   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}                

## Titulo Zep [45]

nome_zep() {
    clear
    echo ""
    echo -e "$branco                                      ███████╗███████╗██████╗ \e[0m"
    echo -e "$branco                                      ╚══███╔╝██╔════╝██╔══██╗\e[0m"
    echo -e "$branco                                        ███╔╝ █████╗  ██████╔╝\e[0m"
    echo -e "$branco                                       ███╔╝  ██╔══╝  ██╔═══╝ \e[0m"
    echo -e "$branco                                      ███████╗███████╗██║     \e[0m"
    echo -e "$branco                                      ╚══════╝╚══════╝╚═╝     \e[0m"
    echo ""
    echo ""
}

## Titulo HumHub [46]

nome_humhub() {
    clear
    echo ""
    echo -e "$branco                       ██╗  ██╗██╗   ██╗███╗   ███╗██╗  ██╗██╗   ██╗██████╗ \e[0m"
    echo -e "$branco                       ██║  ██║██║   ██║████╗ ████║██║  ██║██║   ██║██╔══██╗\e[0m"
    echo -e "$branco                       ███████║██║   ██║██╔████╔██║███████║██║   ██║██████╔╝\e[0m"
    echo -e "$branco                       ██╔══██║██║   ██║██║╚██╔╝██║██╔══██║██║   ██║██╔══██╗\e[0m"
    echo -e "$branco                       ██║  ██║╚██████╔╝██║ ╚═╝ ██║██║  ██║╚██████╔╝██████╔╝\e[0m"
    echo -e "$branco                       ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Yourls [47]

nome_yourls() {
clear
echo ""
echo -e "$branco                        ██╗   ██╗ ██████╗ ██╗   ██╗██████╗ ██╗     ███████╗\e[0m"
echo -e "$branco                        ╚██╗ ██╔╝██╔═══██╗██║   ██║██╔══██╗██║     ██╔════╝\e[0m"
echo -e "$branco                         ╚████╔╝ ██║   ██║██║   ██║██████╔╝██║     ███████╗\e[0m"
echo -e "$branco                          ╚██╔╝  ██║   ██║██║   ██║██╔══██╗██║     ╚════██║\e[0m"
echo -e "$branco                           ██║   ╚██████╔╝╚██████╔╝██║  ██║███████╗███████║\e[0m"
echo -e "$branco                           ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝\e[0m"
echo ""
echo ""
}

## Titulo TwentyCRM [48]

nome_twentycrm() {
clear
echo ""
echo -e "$branco         ████████╗██╗    ██╗███████╗███╗   ██╗████████╗██╗   ██╗ ██████╗██████╗ ███╗   ███╗\e[0m"
echo -e "$branco         ╚══██╔══╝██║    ██║██╔════╝████╗  ██║╚══██╔══╝╚██╗ ██╔╝██╔════╝██╔══██╗████╗ ████║\e[0m"
echo -e "$branco            ██║   ██║ █╗ ██║█████╗  ██╔██╗ ██║   ██║    ╚████╔╝ ██║     ██████╔╝██╔████╔██║\e[0m"
echo -e "$branco            ██║   ██║███╗██║██╔══╝  ██║╚██╗██║   ██║     ╚██╔╝  ██║     ██╔══██╗██║╚██╔╝██║\e[0m"
echo -e "$branco            ██║   ╚███╔███╔╝███████╗██║ ╚████║   ██║      ██║   ╚██████╗██║  ██║██║ ╚═╝ ██║\e[0m"
echo -e "$branco            ╚═╝    ╚══╝╚══╝ ╚══════╝╚═╝  ╚═══╝   ╚═╝      ╚═╝    ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
echo ""
echo ""
}

## Titulo Mattermost [49]

nome_mattermost() {
clear
echo ""
echo -e "$branco    ███╗   ███╗ █████╗ ████████╗████████╗███████╗██████╗ ███╗   ███╗ ██████╗ ███████╗████████╗\e[0m"
echo -e "$branco    ████╗ ████║██╔══██╗╚══██╔══╝╚══██╔══╝██╔════╝██╔══██╗████╗ ████║██╔═══██╗██╔════╝╚══██╔══╝\e[0m"
echo -e "$branco    ██╔████╔██║███████║   ██║      ██║   █████╗  ██████╔╝██╔████╔██║██║   ██║███████╗   ██║   \e[0m"
echo -e "$branco    ██║╚██╔╝██║██╔══██║   ██║      ██║   ██╔══╝  ██╔══██╗██║╚██╔╝██║██║   ██║╚════██║   ██║   \e[0m"
echo -e "$branco    ██║ ╚═╝ ██║██║  ██║   ██║      ██║   ███████╗██║  ██║██║ ╚═╝ ██║╚██████╔╝███████║   ██║   \e[0m"
echo -e "$branco    ╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝ ╚══════╝   ╚═╝   \e[0m"
echo ""
echo ""
}

## Titulo Outline [50]

nome_outline() {
clear
echo ""
echo -e "$branco                       ██████╗ ██╗   ██╗████████╗██╗     ██╗███╗   ██╗███████╗\e[0m"
echo -e "$branco                      ██╔═══██╗██║   ██║╚══██╔══╝██║     ██║████╗  ██║██╔════╝\e[0m"
echo -e "$branco                      ██║   ██║██║   ██║   ██║   ██║     ██║██╔██╗ ██║█████╗  \e[0m"
echo -e "$branco                      ██║   ██║██║   ██║   ██║   ██║     ██║██║╚██╗██║██╔══╝  \e[0m"
echo -e "$branco                      ╚██████╔╝╚██████╔╝   ██║   ███████╗██║██║ ╚████║███████╗\e[0m"
echo -e "$branco                       ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝╚═╝  ╚═══╝╚══════╝\e[0m"
echo ""
echo ""
}

## Titulo FocalBoard [51]

nome_focalboard() {
    clear
    echo ""
    echo -e "$branco         ███████╗ ██████╗  ██████╗ █████╗ ██╗     ██████╗  ██████╗  █████╗ ██████╗ ██████╗ \e[0m"
    echo -e "$branco         ██╔════╝██╔═══██╗██╔════╝██╔══██╗██║     ██╔══██╗██╔═══██╗██╔══██╗██╔══██╗██╔══██╗\e[0m"
    echo -e "$branco         █████╗  ██║   ██║██║     ███████║██║     ██████╔╝██║   ██║███████║██████╔╝██║  ██║\e[0m"
    echo -e "$branco         ██╔══╝  ██║   ██║██║     ██╔══██║██║     ██╔══██╗██║   ██║██╔══██║██╔══██╗██║  ██║\e[0m"
    echo -e "$branco         ██║     ╚██████╔╝╚██████╗██║  ██║███████╗██████╔╝╚██████╔╝██║  ██║██║  ██║██████╔╝\e[0m"
    echo -e "$branco         ╚═╝      ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo GLPI [52]

nome_glpi() {
    clear
    echo ""
    echo -e "$branco                                     ██████╗ ██╗     ██████╗ ██╗\e[0m"
    echo -e "$branco                                    ██╔════╝ ██║     ██╔══██╗██║\e[0m"
    echo -e "$branco                                    ██║  ███╗██║     ██████╔╝██║\e[0m"
    echo -e "$branco                                    ██║   ██║██║     ██╔═══╝ ██║\e[0m"
    echo -e "$branco                                    ╚██████╔╝███████╗██║     ██║\e[0m"
    echo -e "$branco                                     ╚═════╝ ╚══════╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Anything LLM [53]

nome_anythingllm() {
    clear
    echo ""
    echo ""
    echo -e "$branco  █████╗ ███╗   ██╗██╗   ██╗████████╗██╗  ██╗██╗███╗   ██╗ ██████╗     ██╗     ██╗     ███╗   ███╗\e[0m"
    echo -e "$branco ██╔══██╗████╗  ██║╚██╗ ██╔╝╚══██╔══╝██║  ██║██║████╗  ██║██╔════╝     ██║     ██║     ████╗ ████║\e[0m"
    echo -e "$branco ███████║██╔██╗ ██║ ╚████╔╝    ██║   ███████║██║██╔██╗ ██║██║  ███╗    ██║     ██║     ██╔████╔██║\e[0m"
    echo -e "$branco ██╔══██║██║╚██╗██║  ╚██╔╝     ██║   ██╔══██║██║██║╚██╗██║██║   ██║    ██║     ██║     ██║╚██╔╝██║\e[0m"
    echo -e "$branco ██║  ██║██║ ╚████║   ██║      ██║   ██║  ██║██║██║ ╚████║╚██████╔╝    ███████╗███████╗██║ ╚═╝ ██║\e[0m"
    echo -e "$branco ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝      ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝     ╚══════╝╚══════╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Excalidraw [54]

nome_excalidraw() {
    clear
    echo ""
    echo ""
    echo -e "$branco           ███████╗██╗  ██╗ ██████╗ █████╗ ██╗     ██╗██████╗ ██████╗  █████╗ ██╗    ██╗\e[0m"
    echo -e "$branco           ██╔════╝╚██╗██╔╝██╔════╝██╔══██╗██║     ██║██╔══██╗██╔══██╗██╔══██╗██║    ██║\e[0m"
    echo -e "$branco           █████╗   ╚███╔╝ ██║     ███████║██║     ██║██║  ██║██████╔╝███████║██║ █╗ ██║\e[0m"
    echo -e "$branco           ██╔══╝   ██╔██╗ ██║     ██╔══██║██║     ██║██║  ██║██╔══██╗██╔══██║██║███╗██║\e[0m"
    echo -e "$branco           ███████╗██╔╝ ██╗╚██████╗██║  ██║███████╗██║██████╔╝██║  ██║██║  ██║╚███╔███╔╝\e[0m"
    echo -e "$branco           ╚══════╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚══╝╚══╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Excalidraw [53]

nome_easyappointments() {
    clear
    echo ""
    echo ""
    echo -e "$branco                                ███████╗ █████╗ ███████╗██╗   ██╗██╗                                 \e[0m"
    echo -e "$branco                                ██╔════╝██╔══██╗██╔════╝╚██╗ ██╔╝██║                                 \e[0m"
    echo -e "$branco                                █████╗  ███████║███████╗ ╚████╔╝ ██║                                 \e[0m"
    echo -e "$branco                                ██╔══╝  ██╔══██║╚════██║  ╚██╔╝  ╚═╝                                 \e[0m"
    echo -e "$branco                                ███████╗██║  ██║███████║   ██║   ██╗                                 \e[0m"
    echo -e "$branco                                ╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝                                 \e[0m"
    echo -e "$branco                                                                                                     \e[0m"
    echo -e "$branco █████╗ ██████╗ ██████╗  ██████╗ ██╗███╗   ██╗████████╗███╗   ███╗███████╗███╗   ██╗████████╗███████╗\e[0m"
    echo -e "$branco██╔══██╗██╔══██╗██╔══██╗██╔═══██╗██║████╗  ██║╚══██╔══╝████╗ ████║██╔════╝████╗  ██║╚══██╔══╝██╔════╝\e[0m"
    echo -e "$branco███████║██████╔╝██████╔╝██║   ██║██║██╔██╗ ██║   ██║   ██╔████╔██║█████╗  ██╔██╗ ██║   ██║   ███████╗\e[0m"
    echo -e "$branco██╔══██║██╔═══╝ ██╔═══╝ ██║   ██║██║██║╚██╗██║   ██║   ██║╚██╔╝██║██╔══╝  ██║╚██╗██║   ██║   ╚════██║\e[0m"
    echo -e "$branco██║  ██║██║     ██║     ╚██████╔╝██║██║ ╚████║   ██║   ██║ ╚═╝ ██║███████╗██║ ╚████║   ██║   ███████║\e[0m"
    echo -e "$branco╚═╝  ╚═╝╚═╝     ╚═╝      ╚═════╝ ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Documenso [54]

nome_documenso() {
    clear
    echo ""
    echo ""
    echo -e "$branco          ██████╗  ██████╗  ██████╗██╗   ██╗███╗   ███╗███████╗███╗   ██╗███████╗ ██████╗ \e[0m"
    echo -e "$branco          ██╔══██╗██╔═══██╗██╔════╝██║   ██║████╗ ████║██╔════╝████╗  ██║██╔════╝██╔═══██╗\e[0m"
    echo -e "$branco          ██║  ██║██║   ██║██║     ██║   ██║██╔████╔██║█████╗  ██╔██╗ ██║███████╗██║   ██║\e[0m"
    echo -e "$branco          ██║  ██║██║   ██║██║     ██║   ██║██║╚██╔╝██║██╔══╝  ██║╚██╗██║╚════██║██║   ██║\e[0m"
    echo -e "$branco          ██████╔╝╚██████╔╝╚██████╗╚██████╔╝██║ ╚═╝ ██║███████╗██║ ╚████║███████║╚██████╔╝\e[0m"
    echo -e "$branco          ╚═════╝  ╚═════╝  ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Moodle [55]

#nome_moodle() {
#    clear
#    echo ""
#    echo ""
#    echo -e "$branco                       ███╗   ███╗ ██████╗  ██████╗ ██████╗ ██╗     ███████╗\e[0m"
#    echo -e "$branco                       ████╗ ████║██╔═══██╗██╔═══██╗██╔══██╗██║     ██╔════╝\e[0m"
#    echo -e "$branco                       ██╔████╔██║██║   ██║██║   ██║██║  ██║██║     █████╗  \e[0m"
#    echo -e "$branco                       ██║╚██╔╝██║██║   ██║██║   ██║██║  ██║██║     ██╔══╝  \e[0m"
#    echo -e "$branco                       ██║ ╚═╝ ██║╚██████╔╝╚██████╔╝██████╔╝███████╗███████╗\e[0m"
#    echo -e "$branco                       ╚═╝     ╚═╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝╚══════╝\e[0m"
#    echo ""
#    echo ""
#}

## Titulo ToolJet [55]

nome_tooljet() {
    clear
    echo ""
    echo ""
    echo -e "$branco                    ████████╗ ██████╗  ██████╗ ██╗          ██╗███████╗████████╗\e[0m"
    echo -e "$branco                    ╚══██╔══╝██╔═══██╗██╔═══██╗██║          ██║██╔════╝╚══██╔══╝\e[0m"
    echo -e "$branco                       ██║   ██║   ██║██║   ██║██║          ██║█████╗     ██║   \e[0m"
    echo -e "$branco                       ██║   ██║   ██║██║   ██║██║     ██   ██║██╔══╝     ██║   \e[0m"
    echo -e "$branco                       ██║   ╚██████╔╝╚██████╔╝███████╗╚█████╔╝███████╗   ██║   \e[0m"
    echo -e "$branco                       ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝ ╚════╝ ╚══════╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo Stirling PDF [56]

nome_stirlingpdf() {
    clear
    echo ""
    echo ""
    echo -e "$branco      ███████╗████████╗██╗██████╗ ██╗     ██╗███╗   ██╗ ██████╗     ██████╗ ██████╗ ███████╗\e[0m"
    echo -e "$branco      ██╔════╝╚══██╔══╝██║██╔══██╗██║     ██║████╗  ██║██╔════╝     ██╔══██╗██╔══██╗██╔════╝\e[0m"
    echo -e "$branco      ███████╗   ██║   ██║██████╔╝██║     ██║██╔██╗ ██║██║  ███╗    ██████╔╝██║  ██║█████╗  \e[0m"
    echo -e "$branco      ╚════██║   ██║   ██║██╔══██╗██║     ██║██║╚██╗██║██║   ██║    ██╔═══╝ ██║  ██║██╔══╝  \e[0m"
    echo -e "$branco      ███████║   ██║   ██║██║  ██║███████╗██║██║ ╚████║╚██████╔╝    ██║     ██████╔╝██║     \e[0m"
    echo -e "$branco      ╚══════╝   ╚═╝   ╚═╝╚═╝  ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝ ╚═════╝     ╚═╝     ╚═════╝ ╚═╝     \e[0m"
    echo ""
    echo ""
}

## Titulo ClickHouse [57]

nome_clickhouse() {
    clear
    echo ""
    echo ""
    echo -e "$branco            ██████╗██╗     ██╗ ██████╗██╗  ██╗██╗  ██╗ ██████╗ ██╗   ██╗███████╗███████╗\e[0m"
    echo -e "$branco           ██╔════╝██║     ██║██╔════╝██║ ██╔╝██║  ██║██╔═══██╗██║   ██║██╔════╝██╔════╝\e[0m"
    echo -e "$branco           ██║     ██║     ██║██║     █████╔╝ ███████║██║   ██║██║   ██║███████╗█████╗  \e[0m"
    echo -e "$branco           ██║     ██║     ██║██║     ██╔═██╗ ██╔══██║██║   ██║██║   ██║╚════██║██╔══╝  \e[0m"
    echo -e "$branco           ╚██████╗███████╗██║╚██████╗██║  ██╗██║  ██║╚██████╔╝╚██████╔╝███████║███████╗\e[0m"
    echo -e "$branco            ╚═════╝╚══════╝╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo RedisInsight [58]

nome_redisinsight() {
    clear
    echo ""
    echo ""
    echo -e "$branco       ██████╗ ███████╗██████╗ ██╗███████╗██╗███╗   ██╗███████╗██╗ ██████╗ ██╗  ██╗████████╗\e[0m"
    echo -e "$branco       ██╔══██╗██╔════╝██╔══██╗██║██╔════╝██║████╗  ██║██╔════╝██║██╔════╝ ██║  ██║╚══██╔══╝\e[0m"
    echo -e "$branco       ██████╔╝█████╗  ██║  ██║██║███████╗██║██╔██╗ ██║███████╗██║██║  ███╗███████║   ██║   \e[0m"
    echo -e "$branco       ██╔══██╗██╔══╝  ██║  ██║██║╚════██║██║██║╚██╗██║╚════██║██║██║   ██║██╔══██║   ██║   \e[0m"
    echo -e "$branco       ██║  ██║███████╗██████╔╝██║███████║██║██║ ╚████║███████║██║╚██████╔╝██║  ██║   ██║   \e[0m"
    echo -e "$branco       ╚═╝  ╚═╝╚══════╝╚═════╝ ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo Traccar [59]

nome_traccar() {
    clear
    echo ""
    echo ""
    echo -e "$branco                     ████████╗██████╗  █████╗  ██████╗ ██████╗ █████╗ ██████╗ \e[0m"
    echo -e "$branco                     ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔══██╗\e[0m"
    echo -e "$branco                        ██║   ██████╔╝███████║██║     ██║     ███████║██████╔╝\e[0m"
    echo -e "$branco                        ██║   ██╔══██╗██╔══██║██║     ██║     ██╔══██║██╔══██╗\e[0m"
    echo -e "$branco                        ██║   ██║  ██║██║  ██║╚██████╗╚██████╗██║  ██║██║  ██║\e[0m"
    echo -e "$branco                        ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Firecrawl [60]

nome_firecrawl() {
    clear
    echo ""
    echo ""
    echo -e "$branco               ███████╗██╗██████╗ ███████╗ ██████╗██████╗  █████╗ ██╗    ██╗██╗     \e[0m"
    echo -e "$branco               ██╔════╝██║██╔══██╗██╔════╝██╔════╝██╔══██╗██╔══██╗██║    ██║██║     \e[0m"
    echo -e "$branco               █████╗  ██║██████╔╝█████╗  ██║     ██████╔╝███████║██║ █╗ ██║██║     \e[0m"
    echo -e "$branco               ██╔══╝  ██║██╔══██╗██╔══╝  ██║     ██╔══██╗██╔══██║██║███╗██║██║     \e[0m"
    echo -e "$branco               ██║     ██║██║  ██║███████╗╚██████╗██║  ██║██║  ██║╚███╔███╔╝███████╗\e[0m"
    echo -e "$branco               ╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚══╝╚══╝ ╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Wuzapi [61]

nome_wuzapi() {
    clear
    echo ""
    echo ""
    echo -e "$branco                          ██╗    ██╗██╗   ██╗███████╗ █████╗ ██████╗ ██╗\e[0m"
    echo -e "$branco                          ██║    ██║██║   ██║╚══███╔╝██╔══██╗██╔══██╗██║\e[0m"
    echo -e "$branco                          ██║ █╗ ██║██║   ██║  ███╔╝ ███████║██████╔╝██║\e[0m"
    echo -e "$branco                          ██║███╗██║██║   ██║ ███╔╝  ██╔══██║██╔═══╝ ██║\e[0m"
    echo -e "$branco                          ╚███╔███╔╝╚██████╔╝███████╗██║  ██║██║     ██║\e[0m"
    echo -e "$branco                           ╚══╝╚══╝  ╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Krayin CRM [62]

nome_krayincrm() {
    clear
    echo ""
    echo ""
    echo -e "$branco           ██╗  ██╗██████╗  █████╗ ██╗   ██╗██╗███╗   ██╗     ██████╗██████╗ ███╗   ███╗\e[0m"
    echo -e "$branco           ██║ ██╔╝██╔══██╗██╔══██╗╚██╗ ██╔╝██║████╗  ██║    ██╔════╝██╔══██╗████╗ ████║\e[0m"
    echo -e "$branco           █████╔╝ ██████╔╝███████║ ╚████╔╝ ██║██╔██╗ ██║    ██║     ██████╔╝██╔████╔██║\e[0m"
    echo -e "$branco           ██╔═██╗ ██╔══██╗██╔══██║  ╚██╔╝  ██║██║╚██╗██║    ██║     ██╔══██╗██║╚██╔╝██║\e[0m"
    echo -e "$branco           ██║  ██╗██║  ██║██║  ██║   ██║   ██║██║ ╚████║    ╚██████╗██║  ██║██║ ╚═╝ ██║\e[0m"
    echo -e "$branco           ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝     ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Planka [63]

nome_planka() {
    clear
    echo ""
    echo ""
    echo -e "$branco                        ██████╗ ██╗      █████╗ ███╗   ██╗██╗  ██╗ █████╗ \e[0m"
    echo -e "$branco                        ██╔══██╗██║     ██╔══██╗████╗  ██║██║ ██╔╝██╔══██╗\e[0m"
    echo -e "$branco                        ██████╔╝██║     ███████║██╔██╗ ██║█████╔╝ ███████║\e[0m"
    echo -e "$branco                        ██╔═══╝ ██║     ██╔══██║██║╚██╗██║██╔═██╗ ██╔══██║\e[0m"
    echo -e "$branco                        ██║     ███████╗██║  ██║██║ ╚████║██║  ██╗██║  ██║\e[0m"
    echo -e "$branco                        ╚═╝     ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo WppConnect [64]

nome_wppconnect() {
    clear
    echo ""
    echo ""
    echo -e "$branco     ██╗    ██╗██████╗ ██████╗  ██████╗ ██████╗ ███╗   ██╗███╗   ██╗███████╗ ██████╗████████╗\e[0m"
    echo -e "$branco     ██║    ██║██╔══██╗██╔══██╗██╔════╝██╔═══██╗████╗  ██║████╗  ██║██╔════╝██╔════╝╚══██╔══╝\e[0m"
    echo -e "$branco     ██║ █╗ ██║██████╔╝██████╔╝██║     ██║   ██║██╔██╗ ██║██╔██╗ ██║█████╗  ██║        ██║   \e[0m"
    echo -e "$branco     ██║███╗██║██╔═══╝ ██╔═══╝ ██║     ██║   ██║██║╚██╗██║██║╚██╗██║██╔══╝  ██║        ██║   \e[0m"
    echo -e "$branco     ╚███╔███╔╝██║     ██║     ╚██████╗╚██████╔╝██║ ╚████║██║ ╚████║███████╗╚██████╗   ██║   \e[0m"
    echo -e "$branco      ╚══╝╚══╝ ╚═╝     ╚═╝      ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝ ╚═════╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo Browserless [65]

nome_browserless() {
    clear
    echo ""
    echo ""
    echo -e "$branco    ██████╗ ██████╗  ██████╗ ██╗    ██╗███████╗███████╗██████╗ ██╗     ███████╗███████╗███████╗\e[0m"
    echo -e "$branco    ██╔══██╗██╔══██╗██╔═══██╗██║    ██║██╔════╝██╔════╝██╔══██╗██║     ██╔════╝██╔════╝██╔════╝\e[0m"
    echo -e "$branco    ██████╔╝██████╔╝██║   ██║██║ █╗ ██║███████╗█████╗  ██████╔╝██║     █████╗  ███████╗███████╗\e[0m"
    echo -e "$branco    ██╔══██╗██╔══██╗██║   ██║██║███╗██║╚════██║██╔══╝  ██╔══██╗██║     ██╔══╝  ╚════██║╚════██║\e[0m"
    echo -e "$branco    ██████╔╝██║  ██║╚██████╔╝╚███╔███╔╝███████║███████╗██║  ██║███████╗███████╗███████║███████║\e[0m"
    echo -e "$branco    ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Frappe [66]

nome_frappe() {
    clear
    echo ""
    echo ""
    echo -e "$branco                         ███████╗██████╗  █████╗ ██████╗ ██████╗ ███████╗\e[0m"
    echo -e "$branco                         ██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝\e[0m"
    echo -e "$branco                         █████╗  ██████╔╝███████║██████╔╝██████╔╝█████╗  \e[0m"
    echo -e "$branco                         ██╔══╝  ██╔══██╗██╔══██║██╔═══╝ ██╔═══╝ ██╔══╝  \e[0m"
    echo -e "$branco                         ██║     ██║  ██║██║  ██║██║     ██║     ███████╗\e[0m"
    echo -e "$branco                         ╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Bolt [67]

nome_bolt() {
    clear
    echo ""
    echo ""
    echo -e "$branco                                  ██████╗  ██████╗ ██╗  ████████╗\e[0m"
    echo -e "$branco                                  ██╔══██╗██╔═══██╗██║  ╚══██╔══╝\e[0m"
    echo -e "$branco                                  ██████╔╝██║   ██║██║     ██║   \e[0m"
    echo -e "$branco                                  ██╔══██╗██║   ██║██║     ██║   \e[0m"
    echo -e "$branco                                  ██████╔╝╚██████╔╝███████╗██║   \e[0m"
    echo -e "$branco                                  ╚═════╝  ╚═════╝ ╚══════╝╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo WiseMapping [68]

nome_wisemapping() {
    clear
    echo ""
    echo ""
    echo -e "$branco      ██╗    ██╗██╗███████╗███████╗███╗   ███╗ █████╗ ██████╗ ██████╗ ██╗███╗   ██╗ ██████╗ \e[0m"
    echo -e "$branco      ██║    ██║██║██╔════╝██╔════╝████╗ ████║██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║██╔════╝ \e[0m"
    echo -e "$branco      ██║ █╗ ██║██║███████╗█████╗  ██╔████╔██║███████║██████╔╝██████╔╝██║██╔██╗ ██║██║  ███╗\e[0m"
    echo -e "$branco      ██║███╗██║██║╚════██║██╔══╝  ██║╚██╔╝██║██╔══██║██╔═══╝ ██╔═══╝ ██║██║╚██╗██║██║   ██║\e[0m"
    echo -e "$branco      ╚███╔███╔╝██║███████║███████╗██║ ╚═╝ ██║██║  ██║██║     ██║     ██║██║ ╚████║╚██████╔╝\e[0m"
    echo -e "$branco       ╚══╝╚══╝ ╚═╝╚══════╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Evo AI [69]

nome_evoai() {
    clear
    echo ""
    echo ""
    echo -e "$branco                             ███████╗██╗   ██╗ ██████╗      █████╗ ██╗\e[0m"
    echo -e "$branco                             ██╔════╝██║   ██║██╔═══██╗    ██╔══██╗██║\e[0m"
    echo -e "$branco                             █████╗  ██║   ██║██║   ██║    ███████║██║\e[0m"
    echo -e "$branco                             ██╔══╝  ╚██╗ ██╔╝██║   ██║    ██╔══██║██║\e[0m"
    echo -e "$branco                             ███████╗ ╚████╔╝ ╚██████╔╝    ██║  ██║██║\e[0m"
    echo -e "$branco                             ╚══════╝  ╚═══╝   ╚═════╝     ╚═╝  ╚═╝╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Evo AI [70]

nome_keycloak(){
    clear
    echo ""
    echo ""
    echo -e "$branco                ██╗  ██╗███████╗██╗   ██╗ ██████╗██╗      ██████╗  █████╗ ██╗  ██╗\e[0m"
    echo -e "$branco                ██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔════╝██║     ██╔═══██╗██╔══██╗██║ ██╔╝\e[0m"
    echo -e "$branco                █████╔╝ █████╗   ╚████╔╝ ██║     ██║     ██║   ██║███████║█████╔╝ \e[0m"
    echo -e "$branco                ██╔═██╗ ██╔══╝    ╚██╔╝  ██║     ██║     ██║   ██║██╔══██║██╔═██╗ \e[0m"
    echo -e "$branco                ██║  ██╗███████╗   ██║   ╚██████╗███████╗╚██████╔╝██║  ██║██║  ██╗\e[0m"
    echo -e "$branco                ╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Passbolt [71]

nome_passbolt(){
    clear
    echo ""
    echo ""
    echo -e "$branco                  ██████╗  █████╗ ███████╗███████╗██████╗  ██████╗ ██╗  ████████╗\e[0m"
    echo -e "$branco                  ██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔═══██╗██║  ╚══██╔══╝\e[0m"
    echo -e "$branco                  ██████╔╝███████║███████╗███████╗██████╔╝██║   ██║██║     ██║   \e[0m"
    echo -e "$branco                  ██╔═══╝ ██╔══██║╚════██║╚════██║██╔══██╗██║   ██║██║     ██║   \e[0m"
    echo -e "$branco                  ██║     ██║  ██║███████║███████║██████╔╝╚██████╔╝███████╗██║   \e[0m"
    echo -e "$branco                  ╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝  ╚═════╝ ╚══════╝╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo Gotenberg [72]

nome_gotenberg(){
    clear
    echo ""
    echo ""
    echo -e "$branco           ██████╗  ██████╗ ████████╗███████╗███╗   ██╗██████╗ ███████╗██████╗  ██████╗ \e[0m"
    echo -e "$branco          ██╔════╝ ██╔═══██╗╚══██╔══╝██╔════╝████╗  ██║██╔══██╗██╔════╝██╔══██╗██╔════╝ \e[0m"
    echo -e "$branco          ██║  ███╗██║   ██║   ██║   █████╗  ██╔██╗ ██║██████╔╝█████╗  ██████╔╝██║  ███╗\e[0m"
    echo -e "$branco          ██║   ██║██║   ██║   ██║   ██╔══╝  ██║╚██╗██║██╔══██╗██╔══╝  ██╔══██╗██║   ██║\e[0m"
    echo -e "$branco          ╚██████╔╝╚██████╔╝   ██║   ███████╗██║ ╚████║██████╔╝███████╗██║  ██║╚██████╔╝\e[0m"
    echo -e "$branco           ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝ ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo Wiki.js [73]

nome_wiki(){
    clear
    echo ""
    echo ""
    echo -e "$branco                           ██╗    ██╗██╗██╗  ██╗██╗        ██╗███████╗\e[0m"
    echo -e "$branco                           ██║    ██║██║██║ ██╔╝██║        ██║██╔════╝\e[0m"
    echo -e "$branco                           ██║ █╗ ██║██║█████╔╝ ██║        ██║███████╗\e[0m"
    echo -e "$branco                           ██║███╗██║██║██╔═██╗ ██║   ██   ██║╚════██║\e[0m"
    echo -e "$branco                           ╚███╔███╔╝██║██║  ██╗██║██╗╚█████╔╝███████║\e[0m"
    echo -e "$branco                            ╚══╝╚══╝ ╚═╝╚═╝  ╚═╝╚═╝╚═╝ ╚════╝ ╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo AzuraCast [74]

nome_azuracast(){
    clear
    echo ""
    echo ""
    echo -e "$branco             █████╗ ███████╗██╗   ██╗██████╗  █████╗  ██████╗ █████╗ ███████╗████████╗\e[0m"
    echo -e "$branco            ██╔══██╗╚══███╔╝██║   ██║██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔════╝╚══██╔══╝\e[0m"
    echo -e "$branco            ███████║  ███╔╝ ██║   ██║██████╔╝███████║██║     ███████║███████╗   ██║   \e[0m"
    echo -e "$branco            ██╔══██║ ███╔╝  ██║   ██║██╔══██╗██╔══██║██║     ██╔══██║╚════██║   ██║   \e[0m"
    echo -e "$branco            ██║  ██║███████╗╚██████╔╝██║  ██║██║  ██║╚██████╗██║  ██║███████║   ██║   \e[0m"
    echo -e "$branco            ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo Shlink [75]

nome_shlink(){
    clear
    echo ""
    echo ""
    echo -e "$branco                           ███████╗██╗  ██╗██╗     ██╗███╗   ██╗██╗  ██╗\e[0m"
    echo -e "$branco                           ██╔════╝██║  ██║██║     ██║████╗  ██║██║ ██╔╝\e[0m"
    echo -e "$branco                           ███████╗███████║██║     ██║██╔██╗ ██║█████╔╝ \e[0m"
    echo -e "$branco                           ╚════██║██╔══██║██║     ██║██║╚██╗██║██╔═██╗ \e[0m"
    echo -e "$branco                           ███████║██║  ██║███████╗██║██║ ╚████║██║  ██╗\e[0m"
    echo -e "$branco                           ╚══════╝╚═╝  ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo RustDesk [76]

nome_rustdesk(){
    clear
    echo ""
    echo ""
    echo -e "$branco                ██████╗ ██╗   ██╗███████╗████████╗██████╗ ███████╗███████╗██╗  ██╗\e[0m"
    echo -e "$branco                ██╔══██╗██║   ██║██╔════╝╚══██╔══╝██╔══██╗██╔════╝██╔════╝██║ ██╔╝\e[0m"
    echo -e "$branco                ██████╔╝██║   ██║███████╗   ██║   ██║  ██║█████╗  ███████╗█████╔╝ \e[0m"
    echo -e "$branco                ██╔══██╗██║   ██║╚════██║   ██║   ██║  ██║██╔══╝  ╚════██║██╔═██╗ \e[0m"
    echo -e "$branco                ██║  ██║╚██████╔╝███████║   ██║   ██████╔╝███████╗███████║██║  ██╗\e[0m"
    echo -e "$branco                ╚═╝  ╚═╝ ╚═════╝ ╚══════╝   ╚═╝   ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Hoppscotch [77]

    nome_hoppscotch(){
    clear
    echo ""
    echo ""
    echo -e "$branco         ██╗  ██╗ ██████╗ ██████╗ ██████╗ ███████╗ ██████╗ ██████╗ ████████╗ ██████╗██╗  ██╗\e[0m"
    echo -e "$branco         ██║  ██║██╔═══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝██╔═══██╗╚══██╔══╝██╔════╝██║  ██║\e[0m"
    echo -e "$branco         ███████║██║   ██║██████╔╝██████╔╝███████╗██║     ██║   ██║   ██║   ██║     ███████║\e[0m"
    echo -e "$branco         ██╔══██║██║   ██║██╔═══╝ ██╔═══╝ ╚════██║██║     ██║   ██║   ██║   ██║     ██╔══██║\e[0m"
    echo -e "$branco         ██║  ██║╚██████╔╝██║     ██║     ███████║╚██████╗╚██████╔╝   ██║   ╚██████╗██║  ██║\e[0m"
    echo -e "$branco         ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝     ╚══════╝ ╚═════╝ ╚═════╝    ╚═╝    ╚═════╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Transcreve Zap [78]

nome_transcrevezap(){
    clear
    echo ""
    echo ""
    echo -e "$branco        ████████╗██████╗  █████╗ ███╗   ██╗███████╗ ██████╗██████╗ ███████╗██╗   ██╗███████╗\e[0m"
    echo -e "$branco        ╚══██╔══╝██╔══██╗██╔══██╗████╗  ██║██╔════╝██╔════╝██╔══██╗██╔════╝██║   ██║██╔════╝\e[0m"
    echo -e "$branco           ██║   ██████╔╝███████║██╔██╗ ██║███████╗██║     ██████╔╝█████╗  ██║   ██║█████╗  \e[0m"
    echo -e "$branco           ██║   ██╔══██╗██╔══██║██║╚██╗██║╚════██║██║     ██╔══██╗██╔══╝  ╚██╗ ██╔╝██╔══╝  \e[0m"
    echo -e "$branco           ██║   ██║  ██║██║  ██║██║ ╚████║███████║╚██████╗██║  ██║███████╗ ╚████╔╝ ███████╗\e[0m"
    echo -e "$branco           ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝  ╚═══╝  ╚══════╝\e[0m"
    echo -e "$branco                                                                                            \e[0m"
    echo -e "$branco                                        ███████╗ █████╗ ██████╗                             \e[0m"
    echo -e "$branco                                        ╚══███╔╝██╔══██╗██╔══██╗                            \e[0m"
    echo -e "$branco                                          ███╔╝ ███████║██████╔╝                            \e[0m"
    echo -e "$branco                                         ███╔╝  ██╔══██║██╔═══╝                             \e[0m"
    echo -e "$branco                                        ███████╗██║  ██║██║                                 \e[0m"
    echo -e "$branco                                        ╚══════╝╚═╝  ╚═╝╚═╝                                 \e[0m"
    echo ""
    echo ""
}

## Titulo OmniTools [79]

nome_omnitools(){
    clear
    echo ""
    echo ""
    echo -e "$branco             ██████╗ ███╗   ███╗███╗   ██╗██╗████████╗ ██████╗  ██████╗ ██╗     ███████╗\e[0m"
    echo -e "$branco            ██╔═══██╗████╗ ████║████╗  ██║██║╚══██╔══╝██╔═══██╗██╔═══██╗██║     ██╔════╝\e[0m"
    echo -e "$branco            ██║   ██║██╔████╔██║██╔██╗ ██║██║   ██║   ██║   ██║██║   ██║██║     ███████╗\e[0m"
    echo -e "$branco            ██║   ██║██║╚██╔╝██║██║╚██╗██║██║   ██║   ██║   ██║██║   ██║██║     ╚════██║\e[0m"
    echo -e "$branco            ╚██████╔╝██║ ╚═╝ ██║██║ ╚████║██║   ██║   ╚██████╔╝╚██████╔╝███████╗███████║\e[0m"
    echo -e "$branco             ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═══╝╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo serpbear [80]

nome_serpbear(){
    clear
    echo ""
    echo ""
    echo -e "$branco                  ███████╗███████╗██████╗ ██████╗ ██████╗ ███████╗ █████╗ ██████╗ \e[0m"
    echo -e "$branco                  ██╔════╝██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔══██╗\e[0m"
    echo -e "$branco                  ███████╗█████╗  ██████╔╝██████╔╝██████╔╝█████╗  ███████║██████╔╝\e[0m"
    echo -e "$branco                  ╚════██║██╔══╝  ██╔══██╗██╔═══╝ ██╔══██╗██╔══╝  ██╔══██║██╔══██╗\e[0m"
    echo -e "$branco                  ███████║███████╗██║  ██║██║     ██████╔╝███████╗██║  ██║██║  ██║\e[0m"
    echo -e "$branco                  ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo ActivePieces [81]

nome_activepieces(){
    clear
    echo ""
    echo ""
    echo -e "$branco       █████╗  ██████╗████████╗██╗██╗   ██╗███████╗██████╗ ██╗███████╗ ██████╗███████╗███████╗\e[0m"
    echo -e "$branco      ██╔══██╗██╔════╝╚══██╔══╝██║██║   ██║██╔════╝██╔══██╗██║██╔════╝██╔════╝██╔════╝██╔════╝\e[0m"
    echo -e "$branco      ███████║██║        ██║   ██║██║   ██║█████╗  ██████╔╝██║█████╗  ██║     █████╗  ███████╗\e[0m"
    echo -e "$branco      ██╔══██║██║        ██║   ██║╚██╗ ██╔╝██╔══╝  ██╔═══╝ ██║██╔══╝  ██║     ██╔══╝  ╚════██║\e[0m"
    echo -e "$branco      ██║  ██║╚██████╗   ██║   ██║ ╚████╔╝ ███████╗██║     ██║███████╗╚██████╗███████╗███████║\e[0m"
    echo -e "$branco      ╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚═╝  ╚═══╝  ╚══════╝╚═╝     ╚═╝╚══════╝ ╚═════╝╚══════╝╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Authentik [82]

nome_authentik(){
    clear
    echo ""
    echo ""
    echo -e "$branco               █████╗ ██╗   ██╗████████╗██╗  ██╗███████╗███╗   ██╗████████╗██╗██╗  ██╗\e[0m"
    echo -e "$branco              ██╔══██╗██║   ██║╚══██╔══╝██║  ██║██╔════╝████╗  ██║╚══██╔══╝██║██║ ██╔╝\e[0m"
    echo -e "$branco              ███████║██║   ██║   ██║   ███████║█████╗  ██╔██╗ ██║   ██║   ██║█████╔╝ \e[0m"
    echo -e "$branco              ██╔══██║██║   ██║   ██║   ██╔══██║██╔══╝  ██║╚██╗██║   ██║   ██║██╔═██╗ \e[0m"
    echo -e "$branco              ██║  ██║╚██████╔╝   ██║   ██║  ██║███████╗██║ ╚████║   ██║   ██║██║  ██╗\e[0m"
    echo -e "$branco              ╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}     

## Titulo Checkmate [83]

nome_checkmate(){
    clear
    echo ""
    echo ""
    echo -e "$branco           ██████╗██╗  ██╗███████╗ ██████╗██╗  ██╗███╗   ███╗ █████╗ ████████╗███████╗\e[0m"
    echo -e "$branco          ██╔════╝██║  ██║██╔════╝██╔════╝██║ ██╔╝████╗ ████║██╔══██╗╚══██╔══╝██╔════╝\e[0m"
    echo -e "$branco          ██║     ███████║█████╗  ██║     █████╔╝ ██╔████╔██║███████║   ██║   █████╗  \e[0m"
    echo -e "$branco          ██║     ██╔══██║██╔══╝  ██║     ██╔═██╗ ██║╚██╔╝██║██╔══██║   ██║   ██╔══╝  \e[0m"
    echo -e "$branco          ╚██████╗██║  ██║███████╗╚██████╗██║  ██╗██║ ╚═╝ ██║██║  ██║   ██║   ███████╗\e[0m"
    echo -e "$branco           ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝\e[0m"
    echo ""
    echo ""
}

## Titulo Heyform [84]

nome_heyform(){
    clear
    echo ""
    echo ""
    echo -e "$branco                   ██╗  ██╗███████╗██╗   ██╗███████╗ ██████╗ ██████╗ ███╗   ███╗\e[0m"
    echo -e "$branco                   ██║  ██║██╔════╝╚██╗ ██╔╝██╔════╝██╔═══██╗██╔══██╗████╗ ████║\e[0m"
    echo -e "$branco                   ███████║█████╗   ╚████╔╝ █████╗  ██║   ██║██████╔╝██╔████╔██║\e[0m"
    echo -e "$branco                   ██╔══██║██╔══╝    ╚██╔╝  ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║\e[0m"
    echo -e "$branco                   ██║  ██║███████╗   ██║   ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║\e[0m"
    echo -e "$branco                   ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Wekan [85]
nome_wekan(){
  clear
  echo ""
  echo ""
  echo -e "$branco                          ██╗    ██╗███████╗██╗  ██╗ █████╗ ███╗   ██╗\e[0m"
  echo -e "$branco                          ██║    ██║██╔════╝██║ ██╔╝██╔══██╗████╗  ██║\e[0m"
  echo -e "$branco                          ██║ █╗ ██║█████╗  █████╔╝ ███████║██╔██╗ ██║\e[0m"
  echo -e "$branco                          ██║███╗██║██╔══╝  ██╔═██╗ ██╔══██║██║╚██╗██║\e[0m"
  echo -e "$branco                          ╚███╔███╔╝███████╗██║  ██╗██║  ██║██║ ╚████║\e[0m"
  echo -e "$branco                           ╚══╝╚══╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝\e[0m"
  echo ""
  echo ""
}

## Titulo OpenSing [86]

nome_opensign(){
    clear
    echo ""
    echo ""
    echo -e "$branco                  ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗ ███╗   ██╗\e[0m"
    echo -e "$branco                 ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝ ████╗  ██║\e[0m"
    echo -e "$branco                 ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║  ███╗██╔██╗ ██║\e[0m"
    echo -e "$branco                 ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║╚════██║██║██║   ██║██║╚██╗██║\e[0m"
    echo -e "$branco                 ╚██████╔╝██║     ███████╗██║ ╚████║███████║██║╚██████╔╝██║ ╚████║\e[0m"
    echo -e "$branco                  ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝\e[0m"
    echo ""
    echo ""
}

## Titulo Docmost [87]

nome_docmost() {
    clear
    echo ""
    echo ""
    echo -e "$branco                  ██████╗  ██████╗  ██████╗███╗   ███╗ ██████╗ ███████╗████████╗\e[0m"
    echo -e "$branco                  ██╔══██╗██╔═══██╗██╔════╝████╗ ████║██╔═══██╗██╔════╝╚══██╔══╝\e[0m"
    echo -e "$branco                  ██║  ██║██║   ██║██║     ██╔████╔██║██║   ██║███████╗   ██║   \e[0m"
    echo -e "$branco                  ██║  ██║██║   ██║██║     ██║╚██╔╝██║██║   ██║╚════██║   ██║   \e[0m"
    echo -e "$branco                  ██████╔╝╚██████╔╝╚██████╗██║ ╚═╝ ██║╚██████╔╝███████║   ██║   \e[0m"
    echo -e "$branco                  ╚═════╝  ╚═════╝  ╚═════╝╚═╝     ╚═╝ ╚═════╝ ╚══════╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo NetBox [88]

nome_netbox(){
    clear
    echo ""
    echo ""
    echo -e "$branco                        ███╗   ██╗███████╗████████╗██████╗  ██████╗ ██╗  ██╗\e[0m"
    echo -e "$branco                        ████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██╔═══██╗╚██╗██╔╝\e[0m"
    echo -e "$branco                        ██╔██╗ ██║█████╗     ██║   ██████╔╝██║   ██║ ╚███╔╝ \e[0m"
    echo -e "$branco                        ██║╚██╗██║██╔══╝     ██║   ██╔══██╗██║   ██║ ██╔██╗ \e[0m"
    echo -e "$branco                        ██║ ╚████║███████╗   ██║   ██████╔╝╚██████╔╝██╔╝ ██╗\e[0m"
    echo -e "$branco                        ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═════╝  ╚═════╝ ╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Kafka [89]

nome_kafka(){
    clear
    echo ""
    echo ""
    echo -e "$branco                              ██╗  ██╗ █████╗ ███████╗██╗  ██╗ █████╗ \e[0m"
    echo -e "$branco                              ██║ ██╔╝██╔══██╗██╔════╝██║ ██╔╝██╔══██╗\e[0m"
    echo -e "$branco                              █████╔╝ ███████║█████╗  █████╔╝ ███████║\e[0m"
    echo -e "$branco                              ██╔═██╗ ██╔══██║██╔══╝  ██╔═██╗ ██╔══██║\e[0m"
    echo -e "$branco                              ██║  ██╗██║  ██║██║     ██║  ██╗██║  ██║\e[0m"
    echo -e "$branco                              ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo AstraCampaign [90]

nome_astracampaign(){
    clear
    echo ""
    echo ""
    echo -e "$branco                              █████╗ ███████╗████████╗██████╗  █████╗             \e[0m"
    echo -e "$branco                             ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗            \e[0m"
    echo -e "$branco                             ███████║███████╗   ██║   ██████╔╝███████║            \e[0m"
    echo -e "$branco                             ██╔══██║╚════██║   ██║   ██╔══██╗██╔══██║            \e[0m"
    echo -e "$branco                             ██║  ██║███████║   ██║   ██║  ██║██║  ██║            \e[0m"
    echo -e "$branco                             ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝            \e[0m"
    echo -e "$branco                                                                                  \e[0m"
    echo -e "$branco                  ██████╗ █████╗ ███╗   ███╗██████╗  █████╗ ██╗ ██████╗ ███╗   ██╗\e[0m"
    echo -e "$branco                 ██╔════╝██╔══██╗████╗ ████║██╔══██╗██╔══██╗██║██╔════╝ ████╗  ██║\e[0m"
    echo -e "$branco                 ██║     ███████║██╔████╔██║██████╔╝███████║██║██║  ███╗██╔██╗ ██║\e[0m"
    echo -e "$branco                 ██║     ██╔══██║██║╚██╔╝██║██╔═══╝ ██╔══██║██║██║   ██║██║╚██╗██║\e[0m"
    echo -e "$branco                 ╚██████╗██║  ██║██║ ╚═╝ ██║██║     ██║  ██║██║╚██████╔╝██║ ╚████║\e[0m"
    echo -e "$branco                  ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝\e[0m"
    echo ""
    echo ""
}

## Titulo Duplicati [91]

nome_duplicati(){
    clear
    echo ""
    echo ""
    echo -e "$branco                  ██████╗ ██╗   ██╗██████╗ ██╗     ██╗ ██████╗ █████╗ ████████╗██╗\e[0m"
    echo -e "$branco                  ██╔══██╗██║   ██║██╔══██╗██║     ██║██╔════╝██╔══██╗╚══██╔══╝██║\e[0m"
    echo -e "$branco                  ██║  ██║██║   ██║██████╔╝██║     ██║██║     ███████║   ██║   ██║\e[0m"
    echo -e "$branco                  ██║  ██║██║   ██║██╔═══╝ ██║     ██║██║     ██╔══██║   ██║   ██║\e[0m"
    echo -e "$branco                  ██████╔╝╚██████╔╝██║     ███████╗██║╚██████╗██║  ██║   ██║   ██║\e[0m"
    echo -e "$branco                  ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝╚═╝ ╚═════╝╚═╝  ╚═╝   ╚═╝   ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo PgBackWeb [92]

nome_pgbackweb(){
    clear
    echo ""
    echo ""
    echo -e "$branco            ██████╗  ██████╗ ██████╗  █████╗  ██████╗██╗  ██╗██╗    ██╗███████╗██████╗ \e[0m"
    echo -e "$branco            ██╔══██╗██╔════╝ ██╔══██╗██╔══██╗██╔════╝██║ ██╔╝██║    ██║██╔════╝██╔══██╗\e[0m"
    echo -e "$branco            ██████╔╝██║  ███╗██████╔╝███████║██║     █████╔╝ ██║ █╗ ██║█████╗  ██████╔╝\e[0m"
    echo -e "$branco            ██╔═══╝ ██║   ██║██╔══██╗██╔══██║██║     ██╔═██╗ ██║███╗██║██╔══╝  ██╔══██╗\e[0m"
    echo -e "$branco            ██║     ╚██████╔╝██████╔╝██║  ██║╚██████╗██║  ██╗╚███╔███╔╝███████╗██████╔╝\e[0m"
    echo -e "$branco            ╚═╝      ╚═════╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝ ╚══╝╚══╝ ╚══════╝╚═════╝ \e[0m"
    echo ""
    echo ""
}

## Titulo JitsiMeet [93]

nome_jitsi(){
    clear
    echo ""
    echo ""
    echo -e "$branco                   ██╗██╗████████╗███████╗██╗    ███╗   ███╗███████╗███████╗████████╗\e[0m"
    echo -e "$branco                   ██║██║╚══██╔══╝██╔════╝██║    ████╗ ████║██╔════╝██╔════╝╚══██╔══╝\e[0m"
    echo -e "$branco                   ██║██║   ██║   ███████╗██║    ██╔████╔██║█████╗  █████╗     ██║   \e[0m"
    echo -e "$branco              ██   ██║██║   ██║   ╚════██║██║    ██║╚██╔╝██║██╔══╝  ██╔══╝     ██║   \e[0m"
    echo -e "$branco              ╚█████╔╝██║   ██║   ███████║██║    ██║ ╚═╝ ██║███████╗███████╗   ██║   \e[0m"
    echo -e "$branco               ╚════╝ ╚═╝   ╚═╝   ╚══════╝╚═╝    ╚═╝     ╚═╝╚══════╝╚══════╝   ╚═╝   \e[0m"
    echo ""
    echo ""
}

## Titulo CodeServer [94]

nome_code_server(){
    clear
    echo ""
    echo ""
    echo -e "$branco        ██████╗ ██████╗ ██████╗ ███████╗    ███████╗███████╗██████╗ ██╗   ██╗███████╗██████╗ \e[0m"
    echo -e "$branco       ██╔════╝██╔═══██╗██╔══██╗██╔════╝    ██╔════╝██╔════╝██╔══██╗██║   ██║██╔════╝██╔══██╗\e[0m"
    echo -e "$branco       ██║     ██║   ██║██║  ██║█████╗      ███████╗█████╗  ██████╔╝██║   ██║█████╗  ██████╔╝\e[0m"
    echo -e "$branco       ██║     ██║   ██║██║  ██║██╔══╝      ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██╔══╝  ██╔══██╗\e[0m"
    echo -e "$branco       ╚██████╗╚██████╔╝██████╔╝███████╗    ███████║███████╗██║  ██║ ╚████╔╝ ███████╗██║  ██║\e[0m"
    echo -e "$branco        ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝    ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Papra [95]

nome_papra(){
    clear
    echo ""
    echo ""
    echo -e "$branco                              ██████╗  █████╗ ██████╗ ██████╗  █████╗ \e[0m"
    echo -e "$branco                              ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗\e[0m"
    echo -e "$branco                              ██████╔╝███████║██████╔╝██████╔╝███████║\e[0m"
    echo -e "$branco                              ██╔═══╝ ██╔══██║██╔═══╝ ██╔══██╗██╔══██║\e[0m"
    echo -e "$branco                              ██║     ██║  ██║██║     ██║  ██║██║  ██║\e[0m"
    echo -e "$branco                              ╚═╝     ╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

## Titulo Zerobyte [96]

nome_zerobyte(){
    clear
    echo ""
    echo ""
    echo -e "$branco                ███████╗███████╗██████╗  ██████╗ ██████╗ ██╗   ██╗████████╗███████╗\e[0m"
    echo -e "$branco                ╚══███╔╝██╔════╝██╔══██╗██╔═══██╗██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔════╝\e[0m"
    echo -e "$branco                  ███╔╝ █████╗  ██████╔╝██║   ██║██████╔╝ ╚████╔╝    ██║   █████╗  \e[0m"
    echo -e "$branco                 ███╔╝  ██╔══╝  ██╔══██╗██║   ██║██╔══██╗  ╚██╔╝     ██║   ██╔══╝  \e[0m"
    echo -e "$branco                ███████╗███████╗██║  ██║╚██████╔╝██████╔╝   ██║      ██║   ███████╗\e[0m"
    echo -e "$branco                ╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝    ╚═╝      ╚═╝   ╚══════╝\e[0m"
    echo ""
    echo ""
}

nome_openwebui(){
    clear
    echo ""
    echo ""
    echo -e "$branco          ██████╗ ██████╗ ███████╗███╗   ██╗    ██╗    ██╗███████╗██████╗     ██╗   ██╗██╗\e[0m"
    echo -e "$branco         ██╔═══██╗██╔══██╗██╔════╝████╗  ██║    ██║    ██║██╔════╝██╔══██╗    ██║   ██║██║\e[0m"
    echo -e "$branco         ██║   ██║██████╔╝█████╗  ██╔██╗ ██║    ██║ █╗ ██║█████╗  ██████╔╝    ██║   ██║██║\e[0m"
    echo -e "$branco         ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║    ██║███╗██║██╔══╝  ██╔══██╗    ██║   ██║██║\e[0m"
    echo -e "$branco         ╚██████╔╝██║     ███████╗██║ ╚████║    ╚███╔███╔╝███████╗██████╔╝    ╚██████╔╝██║\e[0m"
    echo -e "$branco          ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝     ╚══╝╚══╝ ╚══════╝╚═════╝      ╚═════╝ ╚═╝\e[0m"
    echo ""
    echo ""
}

# ===================================================================================================


## Titulo Saindo do setup

nome_saindo() {
    clear
    echo ""
    echo -e "$branco                ███████╗ █████╗ ██╗███╗   ██╗██████╗  ██████╗     ██████╗  ██████╗ \e[0m"
    echo -e "$branco                ██╔════╝██╔══██╗██║████╗  ██║██╔══██╗██╔═══██╗    ██╔══██╗██╔═══██╗\e[0m"
    echo -e "$branco                ███████╗███████║██║██╔██╗ ██║██║  ██║██║   ██║    ██║  ██║██║   ██║\e[0m"
    echo -e "$branco                ╚════██║██╔══██║██║██║╚██╗██║██║  ██║██║   ██║    ██║  ██║██║   ██║\e[0m"
    echo -e "$branco                ███████║██║  ██║██║██║ ╚████║██████╔╝╚██████╔╝    ██████╔╝╚██████╔╝\e[0m"
    echo -e "$branco                ╚══════╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝     ╚═════╝  ╚═════╝ \e[0m"
    echo -e "$branco                                                                   \e[0m"
    echo -e "$branco                           ███████╗███████╗████████╗██╗   ██╗██████╗                   \e[0m"
    echo -e "$branco                           ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗                  \e[0m"
    echo -e "$branco                           ███████╗█████╗     ██║   ██║   ██║██████╔╝                  \e[0m"
    echo -e "$branco                           ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝                   \e[0m"       
    echo -e "$branco                           ███████║███████╗   ██║   ╚██████╔╝██║                       \e[0m"
    echo -e "$branco                           ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝                       \e[0m"
    echo ""
    echo "" 
}

## Titulo Remover Stack

nome_remover_stack() {
    clear
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
    echo -e "$branco                  ██████╗ ███████╗███╗   ███╗ ██████╗ ██╗   ██╗███████╗██████╗ \e[0m"
    echo -e "$branco                  ██╔══██╗██╔════╝████╗ ████║██╔═══██╗██║   ██║██╔════╝██╔══██╗\e[0m"
    echo -e "$branco                  ██████╔╝█████╗  ██╔████╔██║██║   ██║██║   ██║█████╗  ██████╔╝\e[0m"
    echo -e "$branco                  ██╔══██╗██╔══╝  ██║╚██╔╝██║██║   ██║╚██╗ ██╔╝██╔══╝  ██╔══██╗\e[0m"
    echo -e "$branco                  ██║  ██║███████╗██║ ╚═╝ ██║╚██████╔╝ ╚████╔╝ ███████╗██║  ██║\e[0m"
    echo -e "$branco                  ╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝ ╚═════╝   ╚═══╝  ╚══════╝╚═╝  ╚═╝\e[0m"
    echo -e "$branco                                                                               \e[0m"
    echo -e "$branco                           ███████╗████████╗ █████╗  ██████╗██╗  ██╗            \e[0m"
    echo -e "$branco                           ██╔════╝╚══██╔══╝██╔══██╗██╔════╝██║ ██╔╝            \e[0m"
    echo -e "$branco                           ███████╗   ██║   ███████║██║     █████╔╝             \e[0m"
    echo -e "$branco                           ╚════██║   ██║   ██╔══██║██║     ██╔═██╗             \e[0m"
    echo -e "$branco                           ███████║   ██║   ██║  ██║╚██████╗██║  ██╗            \e[0m"
    echo -e "$branco                           ╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝            \e[0m"
    echo ""
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
    echo""                                                                                             
}
nome_portainer.reset() {
    clear
    echo -e "$amarelo===================================================================================================\e[0m"
    echo ""
    echo ""
    echo -e "$branco           ██████╗ ███████╗███████╗███████╗████████╗ █████╗ ███╗   ██╗██████╗  ██████╗ \e[0m"
    echo -e "$branco           ██╔══██╗██╔════╝██╔════╝██╔════╝╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗██╔═══██╗\e[0m"
    echo -e "$branco           ██████╔╝█████╗  ███████╗█████╗     ██║   ███████║██╔██╗ ██║██║  ██║██║   ██║\e[0m"
    echo -e "$branco           ██╔══██╗██╔══╝  ╚════██║██╔══╝     ██║   ██╔══██║██║╚██╗██║██║  ██║██║   ██║\e[0m"
    echo -e "$branco           ██║  ██║███████╗███████║███████╗   ██║   ██║  ██║██║ ╚████║██████╔╝╚██████╔╝\e[0m"
    echo -e "$branco           ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ \e[0m"
    echo -e "$branco                                                                                       \e[0m"
    echo -e "$branco                           ███████╗███████╗███╗   ██╗██╗  ██╗ █████╗                   \e[0m"
    echo -e "$branco                           ██╔════╝██╔════╝████╗  ██║██║  ██║██╔══██╗                  \e[0m"
    echo -e "$branco                           ███████╗█████╗  ██╔██╗ ██║███████║███████║                  \e[0m"
    echo -e "$branco                           ╚════██║██╔══╝  ██║╚██╗██║██╔══██║██╔══██║                  \e[0m"
    echo -e "$branco                           ███████║███████╗██║ ╚████║██║  ██║██║  ██║                  \e[0m"
    echo -e "$branco                           ╚══════╝╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝                  \e[0m"
    echo ""
    echo ""
    echo -e "$amarelo===================================================================================================\e[0m"
}

nome_verificar_stack() {
    clear
    echo ""
    echo ""
    echo -e "$branco                 ███████╗████████╗ █████╗  ██████╗██╗  ██╗         ██╗ █████╗      \e[0m"
    echo -e "$branco                 ██╔════╝╚══██╔══╝██╔══██╗██╔════╝██║ ██╔╝         ██║██╔══██╗     \e[0m"
    echo -e "$branco                 ███████╗   ██║   ███████║██║     █████╔╝          ██║███████║     \e[0m"
    echo -e "$branco                 ╚════██║   ██║   ██╔══██║██║     ██╔═██╗     ██   ██║██╔══██║     \e[0m"
    echo -e "$branco                 ███████║   ██║   ██║  ██║╚██████╗██║  ██╗    ╚█████╔╝██║  ██║     \e[0m"
    echo -e "$branco                 ╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝     ╚════╝ ╚═╝  ╚═╝     \e[0m"
    echo -e "$branco                                                                                   \e[0m"
    echo -e "$branco             ██╗███╗   ██╗███████╗████████╗ █████╗ ██╗      █████╗ ██████╗  █████╗ \e[0m"
    echo -e "$branco             ██║████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██║     ██╔══██╗██╔══██╗██╔══██╗\e[0m"
    echo -e "$branco             ██║██╔██╗ ██║███████╗   ██║   ███████║██║     ███████║██║  ██║███████║\e[0m"
    echo -e "$branco             ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║     ██╔══██║██║  ██║██╔══██║\e[0m"
    echo -e "$branco             ██║██║ ╚████║███████║   ██║   ██║  ██║███████╗██║  ██║██████╔╝██║  ██║\e[0m"
    echo -e "$branco             ╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝\e[0m"
    echo ""
    echo ""
}

nome_expurgando() {
clear
echo ""
echo ""
echo -e "$branco       ███████╗██╗  ██╗██████╗ ██╗   ██╗██████╗  ██████╗  █████╗ ███╗   ██╗██████╗  ██████╗ \e[0m"
echo -e "$branco       ██╔════╝╚██╗██╔╝██╔══██╗██║   ██║██╔══██╗██╔════╝ ██╔══██╗████╗  ██║██╔══██╗██╔═══██╗\e[0m"
echo -e "$branco       █████╗   ╚███╔╝ ██████╔╝██║   ██║██████╔╝██║  ███╗███████║██╔██╗ ██║██║  ██║██║   ██║\e[0m"
echo -e "$branco       ██╔══╝   ██╔██╗ ██╔═══╝ ██║   ██║██╔══██╗██║   ██║██╔══██║██║╚██╗██║██║  ██║██║   ██║\e[0m"
echo -e "$branco       ███████╗██╔╝ ██╗██║     ╚██████╔╝██║  ██║╚██████╔╝██║  ██║██║ ╚████║██████╔╝╚██████╔╝\e[0m"
echo -e "$branco       ╚══════╝╚═╝  ╚═╝╚═╝      ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ \e[0m"
echo -e "$branco                                                                                            \e[0m"
echo -e "$branco                  ███████╗███████╗██████╗ ██╗   ██╗██╗██████╗  ██████╗ ██████╗              \e[0m"
echo -e "$branco                  ██╔════╝██╔════╝██╔══██╗██║   ██║██║██╔══██╗██╔═══██╗██╔══██╗             \e[0m"
echo -e "$branco                  ███████╗█████╗  ██████╔╝██║   ██║██║██║  ██║██║   ██║██████╔╝             \e[0m"
echo -e "$branco                  ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██║██║  ██║██║   ██║██╔══██╗             \e[0m"
echo -e "$branco                  ███████║███████╗██║  ██║ ╚████╔╝ ██║██████╔╝╚██████╔╝██║  ██║             \e[0m"
echo -e "$branco                  ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚═════╝  ╚═════╝ ╚═╝  ╚═╝             \e[0m"
echo ""
echo ""
}


## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Defasados

nome_trocar_logos() {
    clear
    echo ""
    echo -e "$branco████████╗██████╗  ██████╗  ██████╗ █████╗ ██████╗     ██╗      ██████╗  ██████╗  ██████╗ ███████╗\e[0m"
    echo -e "$branco╚══██╔══╝██╔══██╗██╔═══██╗██╔════╝██╔══██╗██╔══██╗    ██║     ██╔═══██╗██╔════╝ ██╔═══██╗██╔════╝\e[0m"
    echo -e "$branco   ██║   ██████╔╝██║   ██║██║     ███████║██████╔╝    ██║     ██║   ██║██║  ███╗██║   ██║███████╗\e[0m"
    echo -e "$branco   ██║   ██╔══██╗██║   ██║██║     ██╔══██║██╔══██╗    ██║     ██║   ██║██║   ██║██║   ██║╚════██║\e[0m"
    echo -e "$branco   ██║   ██║  ██║╚██████╔╝╚██████╗██║  ██║██║  ██║    ███████╗╚██████╔╝╚██████╔╝╚██████╔╝███████║\e[0m"
    echo -e "$branco   ╚═╝   ╚═╝  ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝    ╚══════╝ ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝\e[0m"
    echo -e "$branco                                                                                                 \e[0m"
    echo -e "$branco   ██████╗  ██████╗      ██████╗██╗  ██╗ █████╗ ████████╗██╗    ██╗ ██████╗  ██████╗ ████████╗      \e[0m"
    echo -e "$branco   ██╔══██╗██╔═══██╗    ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██║    ██║██╔═══██╗██╔═══██╗╚══██╔══╝      \e[0m"
    echo -e "$branco   ██║  ██║██║   ██║    ██║     ███████║███████║   ██║   ██║ █╗ ██║██║   ██║██║   ██║   ██║         \e[0m"
    echo -e "$branco   ██║  ██║██║   ██║    ██║     ██╔══██║██╔══██║   ██║   ██║███╗██║██║   ██║██║   ██║   ██║         \e[0m"
    echo -e "$branco   ██████╔╝╚██████╔╝    ╚██████╗██║  ██║██║  ██║   ██║   ╚███╔███╔╝╚██████╔╝╚██████╔╝   ██║         \e[0m"
    echo -e "$branco   ╚═════╝  ╚═════╝      ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚══╝╚══╝  ╚═════╝  ╚═════╝    ╚═╝         \e[0m"
    echo ""
    echo ""
}

nome_finalizado() {
    clear
    echo ""
    echo -e "$branco             ███████╗██╗███╗   ██╗ █████╗ ██╗     ██╗███████╗ █████╗ ██████╗  ██████╗ \e[0m"
    echo -e "$branco             ██╔════╝██║████╗  ██║██╔══██╗██║     ██║╚══███╔╝██╔══██╗██╔══██╗██╔═══██╗\e[0m"
    echo -e "$branco             █████╗  ██║██╔██╗ ██║███████║██║     ██║  ███╔╝ ███████║██║  ██║██║   ██║\e[0m"
    echo -e "$branco             ██╔══╝  ██║██║╚██╗██║██╔══██║██║     ██║ ███╔╝  ██╔══██║██║  ██║██║   ██║\e[0m"
    echo -e "$branco             ██║     ██║██║ ╚████║██║  ██║███████╗██║███████╗██║  ██║██████╔╝╚██████╔╝\e[0m"
    echo -e "$branco             ╚═╝     ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚═╝╚══════╝╚═╝  ╚═╝╚═════╝  ╚═════╝ \e[0m"
    echo ""
    echo ""
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Menu de opções

#menu_instalador(){
#    echo -e "${amarelo}[ 00 ]${reset} - ${branco}Testar SMTP                             ${verde}| ${reset}  ${amarelo}[ 21 ]${reset} - ${branco}Formbricks${reset}"
#    echo -e "${amarelo}[ 01 ]${reset} - ${branco}Traefik & Portainer                     ${verde}| ${reset}  ${amarelo}[ 22 ]${reset} - ${branco}NocoDB${reset}"
#    echo -e "${amarelo}[ 02 ]${reset} - ${branco}Chatwoot                                ${verde}| ${reset}  ${amarelo}[ 23 ]${reset} - ${branco}Langfuse${reset}"
#    echo -e "${branco}  '-->${amarelo}[ 2.1 ]${reset} - ${branco}Chatwoot (ARM)                   ${verde}| ${reset}  ${amarelo}[ 24 ]${reset} - ${branco}Metabase${reset}"
#    echo -e "${amarelo}[ 03 ]${reset} -  ${branco}Evolution API                          ${verde}| ${reset}  ${amarelo}[ 25 ]${reset} - ${branco}Odoo${reset}"
#    echo -e "${branco}  '-->${amarelo}[ 3.1 ]${reset} - ${branco}Evolution API (ARM)              ${verde}| ${reset}  ${amarelo}[ 26 ]${reset} - ${branco}Chatwoot Nestor${reset}"
#    echo -e "${amarelo}[ 04 ]${reset} - ${branco}MinIO                                   ${verde}| ${reset}  ${amarelo}[ 27 ]${reset} - ${branco}Uno API${reset}"
#    echo -e "${amarelo}[ 05 ]${reset} - ${branco}Typebot                                 ${verde}| ${reset}  ${amarelo}[ 28 ]${reset} - ${branco}N8N + Nodes Quepasa $vermelho[OFF]${reset}"
#    echo -e "${amarelo}[ 06 ]${reset} - ${branco}N8N                                     ${verde}| ${reset}  ${amarelo}[ 29 ]${reset} - ${branco}Quepasa API $vermelho[OFF]${reset}"
#    echo -e "${amarelo}[ 07 ]${reset} - ${branco}Flowise                                 ${verde}| ${reset}  ${amarelo}[ 30 ]${reset} - ${branco}Docuseal${reset}"
#    echo -e "${amarelo}[ 08 ]${reset} - ${branco}PgAdmin 4                               ${verde}| ${reset}  ${amarelo}[ 31 ]${reset} - ${branco}Grafana + Prometheus + cAdvisor${reset}"
#    echo -e "${amarelo}[ 09 ]${reset} - ${branco}Nocobase                                ${verde}| ${reset}  ${amarelo}[ 32 ]${reset} - ${branco}Dify AI${reset}"
#    echo -e "${amarelo}[ 10 ]${reset} - ${branco}Botpress                                ${verde}| ${reset}  ${amarelo}[ 33 ]${reset} - ${branco}Ollama${reset}"
#    echo -e "${amarelo}[ 11 ]${reset} - ${branco}Wordpress                               ${verde}| ${reset}  ${amarelo}[ 34 ]${reset} - ${branco}Affine${reset}"
#    echo -e "${amarelo}[ 12 ]${reset} - ${branco}Baserow                                 ${verde}| ${reset}  ${amarelo}[ 35 ]${reset} - ${branco}Directus${reset}"
#    echo -e "${amarelo}[ 13 ]${reset} - ${branco}MongoDB                                 ${verde}| ${reset}  ${amarelo}[ 36 ]${reset} - ${branco}VaultWarden${reset}"
#    echo -e "${amarelo}[ 14 ]${reset} - ${branco}RabbitMQ                                ${verde}| ${reset}  ${amarelo}[ 37 ]${reset} - ${branco}NextCloud${reset}"
#    echo -e "${amarelo}[ 15 ]${reset} - ${branco}Uptime Kuma                             ${verde}| ${reset}  ${amarelo}[ 38 ]${reset} - ${branco}Strapi${reset}"
#    echo -e "${amarelo}[ 16 ]${reset} - ${branco}Cal.com                                 ${verde}| ${reset}  ${amarelo}[ 39 ]${reset} - ${branco}PhpMyAdmin${reset}"
#    echo -e "${amarelo}[ 17 ]${reset} - ${branco}Mautic                                  ${verde}| ${reset}  ${amarelo}[ 40 ]${reset} - ${branco}Supabase${reset}"
#    echo -e "${amarelo}[ 18 ]${reset} - ${branco}Appsmith                                ${verde}| ${reset}  ${amarelo}[ 41 ]${reset} - ${branco}Ntfy ${verde}[NOVO]${reset}"
#    echo -e "${amarelo}[ 19 ]${reset} - ${branco}Qdrant                                  ${verde}| ${reset}  ${amarelo}[ 42 ]${reset} - ${branco}REMOVER STACK${reset}"
#    echo -e "${amarelo}[ 20 ]${reset} - ${branco}Woofed CRM                              ${verde}| ${reset}  ${amarelo}[ 43 ]${reset} - ${branco}Sair do instalador${reset}"
#    echo""
#}

menu_instalador() {
  case $menu_instalador in
    1) menu_instalador_pg_1 ;;
    2) menu_instalador_pg_2 ;;
    3) menu_instalador_pg_3 ;;
    4) menu_comandos ;;
    *) echo "Erro ao listar menu..." ;;
  esac
}

menu_instalador_pg_1(){
    echo -e "${amarelo}[ 00 ]${reset} - ${branco}Testar SMTP                            ${verde}| ${reset}  ${amarelo}[ 23 ]${reset} - ${branco}Langfuse ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 01 ]${reset} - ${branco}Traefik & Portainer ${verde}[1/1]${reset}              ${verde}| ${reset}  ${amarelo}[ 24 ]${reset} - ${branco}Metabase ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 02 ]${reset} - ${branco}Chatwoot ${verde}[2/2]${reset}                         ${verde}| ${reset}  ${amarelo}[ 25 ]${reset} - ${branco}Odoo ${verde}[2/2] ${reset}"
    echo -e "${amarelo}[ 03 ]${reset} - ${branco}Evolution API ${verde}[1/1]${reset}                    ${verde}| ${reset}  ${amarelo}[ 26 ]${reset} - ${branco}Uno API ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 04 ]${reset} - ${branco}MinIO ${verde}[1/1]${reset}                            ${verde}| ${reset}  ${amarelo}[ 27 ]${reset} - ${branco}Quepasa API ${verde}[2/2] ${reset}"
    echo -e "${amarelo}[ 05 ]${reset} - ${branco}Typebot ${verde}[2/2]${reset}                          ${verde}| ${reset}  ${amarelo}[ 28 ]${reset} - ${branco}Docuseal ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 06 ]${reset} - ${branco}N8N ${verde}[2/2]${reset}                              ${verde}| ${reset}  ${amarelo}[ 29 ]${reset} - ${branco}Grafana + Prometheus + cAdvisor ${verde}[2/2] ${reset}"
    echo -e "${amarelo}[ 07 ]${reset} - ${branco}Flowise ${verde}[1/1]${reset}                          ${verde}| ${reset}  ${amarelo}[ 30 ]${reset} - ${branco}Dify AI ${verde}[2/4] ${reset}"
    echo -e "${amarelo}[ 08 ]${reset} - ${branco}PgAdmin 4 ${verde}[1/1]${reset}                        ${verde}| ${reset}  ${amarelo}[ 31 ]${reset} - ${branco}Ollama ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 09 ]${reset} - ${branco}Nocobase ${verde}[1/1]${reset}                         ${verde}| ${reset}  ${amarelo}[ 32 ]${reset} - ${branco}Affine ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 10 ]${reset} - ${branco}Botpress ${verde}[1/1]${reset}                         ${verde}| ${reset}  ${amarelo}[ 33 ]${reset} - ${branco}Directus ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 11 ]${reset} - ${branco}Wordpress ${verde}[1/1]${reset}                        ${verde}| ${reset}  ${amarelo}[ 34 ]${reset} - ${branco}VaultWarden ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 12 ]${reset} - ${branco}Baserow ${verde}[2/4]${reset}                          ${verde}| ${reset}  ${amarelo}[ 35 ]${reset} - ${branco}NextCloud ${verde}[2/2] ${reset}"
    echo -e "${amarelo}[ 13 ]${reset} - ${branco}MongoDB ${verde}[1/2]${reset}                          ${verde}| ${reset}  ${amarelo}[ 36 ]${reset} - ${branco}Strapi ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 14 ]${reset} - ${branco}RabbitMQ ${verde}[1/1]${reset}                         ${verde}| ${reset}  ${amarelo}[ 37 ]${reset} - ${branco}PhpMyAdmin ${verde}[1/2] ${reset}"
    echo -e "${amarelo}[ 15 ]${reset} - ${branco}Uptime Kuma ${verde}[1/1]${reset}                      ${verde}| ${reset}  ${amarelo}[ 38 ]${reset} - ${branco}Supabase ${verde}[2/4] ${reset}"
    echo -e "${amarelo}[ 16 ]${reset} - ${branco}Cal.com ${verde}[1/1]${reset}                          ${verde}| ${reset}  ${amarelo}[ 39 ]${reset} - ${branco}Ntfy ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 17 ]${reset} - ${branco}Mautic ${verde}[2/2]${reset}                           ${verde}| ${reset}  ${amarelo}[ 40 ]${reset} - ${branco}LowCoder ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 18 ]${reset} - ${branco}Appsmith ${verde}[2/4]${reset}                         ${verde}| ${reset}  ${amarelo}[ 41 ]${reset} - ${branco}LangFlow ${verde}[2/2] ${reset}"
    echo -e "${amarelo}[ 19 ]${reset} - ${branco}Qdrant ${verde}[1/1]${reset}                           ${verde}| ${reset}  ${amarelo}[ 42 ]${reset} - ${branco}OpenProject ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 20 ]${reset} - ${branco}Woofed CRM ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 43 ]${reset} - ${branco}ZEP ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 21 ]${reset} - ${branco}Formbricks ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 44 ]${reset} - ${branco}HumHub ${verde}[1/1] ${reset}"
    echo -e "${amarelo}[ 22 ]${reset} - ${branco}NocoDB ${verde}[1/1]${reset}                           ${verde}| ${reset}  ${amarelo}[ 45 ]${reset} - ${branco}Yourls ${verde}[1/1] ${reset}"
    echo -e ""
    echo -e "${branco}<-- Digite ${amarelo}P1 ${branco}para ir para pagina 1             ${amarelo}|${branco}              Digite ${amarelo}P2${branco} para ir para pagina 2 -->${reset}"
    echo -e ""
}

menu_instalador_pg_2(){
    echo -e "${amarelo}[ 46 ]${reset} - ${branco}TwentyCRM${vermelho} ${verde}[1/4]${reset}                        ${verde}| ${reset}  ${amarelo}[ 69 ]${reset} - ${branco}Evo AI ${verde}[1/1]${reset}${reset}"
    echo -e "${amarelo}[ 47 ]${reset} - ${branco}Mattermost ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 70 ]${reset} - ${branco}Keycloak ${verde}[2/2]${reset}${reset}"
    echo -e "${amarelo}[ 48 ]${reset} - ${branco}Outline ${verde}[1/1]${reset}                          ${verde}| ${reset}  ${amarelo}[ 71 ]${reset} - ${branco}Passbolt ${verde}[1/1]${reset}${reset}"
    echo -e "${amarelo}[ 49 ]${reset} - ${branco}Focalboard ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 72 ]${reset} - ${branco}Gotenberg ${verde}[1/1]${reset}"
    echo -e "${amarelo}[ 50 ]${reset} - ${branco}GLPI ${verde}[1/1]${reset}                             ${verde}| ${reset}  ${amarelo}[ 73 ]${reset} - ${branco}Wiki.js ${verde}[1/1]${reset}"
    echo -e "${amarelo}[ 51 ]${reset} - ${branco}Anything LLM ${verde}[1/1]${reset}                     ${verde}| ${reset}  ${amarelo}[ 74 ]${reset} - ${branco}AzuraCast ${verde}[1/1]${reset}"
    echo -e "${amarelo}[ 52 ]${reset} - ${branco}Excalidraw ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 75 ]${reset} - ${branco}Shlink ${verde}[1/1]${reset}"
    echo -e "${amarelo}[ 53 ]${reset} - ${branco}Easy!Apointments ${verde}[1/1]${reset}                 ${verde}| ${reset}  ${amarelo}[ 76 ]${reset} - ${branco}RustDesk ${verde}[1/1]${reset}"
    echo -e "${amarelo}[ 54 ]${reset} - ${branco}Documenso ${verde}[1/1]${reset}                        ${verde}| ${reset}  ${amarelo}[ 77 ]${reset} - ${branco}Hoppscotch ${verde}[1/1]${reset}"
    echo -e "${amarelo}[ 55 ]${reset} - ${branco}ToolJet ${verde}[2/4]${reset}                          ${verde}| ${reset}  ${amarelo}[ 78 ]${reset} - ${branco}Transcreve Zap ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 56 ]${reset} - ${branco}Stirling PDF ${verde}[1/1]${reset}                     ${verde}| ${reset}  ${amarelo}[ 79 ]${reset} - ${branco}OmniTools ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 57 ]${reset} - ${branco}ClickHouse ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 80 ]${reset} - ${branco}SerpBear ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 58 ]${reset} - ${branco}RedisInsight ${verde}[1/1]${reset}                     ${verde}| ${reset}  ${amarelo}[ 81 ]${reset} - ${branco}ActivePieces ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 59 ]${reset} - ${branco}Traccar ${verde}[1/1]${reset}                          ${verde}| ${reset}  ${amarelo}[ 82 ]${reset} - ${branco}Authentik ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 60 ]${reset} - ${branco}Firecrawl ${verde}[2/4]${reset}                        ${verde}| ${reset}  ${amarelo}[ 83 ]${reset} - ${branco}Checkmate ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 61 ]${reset} - ${branco}Wuzapi ${verde}[1/1]${reset}                           ${verde}| ${reset}  ${amarelo}[ 84 ]${reset} - ${branco}Heyform ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 62 ]${reset} - ${branco}krayin CRM ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 85 ]${reset} - ${branco}Wekan ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 63 ]${reset} - ${branco}Planka ${verde}[1/1]${reset}                           ${verde}| ${reset}  ${amarelo}[ 86 ]${reset} - ${branco}OpenSing ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 64 ]${reset} - ${branco}WppConnect ${verde}[1/1]${reset}                       ${verde}| ${reset}  ${amarelo}[ 87 ]${reset} - ${branco}Docmost ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 65 ]${reset} - ${branco}Browserless ${verde}[2/4]${reset}                      ${verde}| ${reset}  ${amarelo}[ 88 ]${reset} - ${branco}NetBox ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 66 ]${reset} - ${branco}Frappe ${verde}[2/4]${reset}                           ${verde}| ${reset}  ${amarelo}[ 89 ]${reset} - ${branco}Kafka ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 67 ]${reset} - ${branco}Bolt ${verde}[2/4]${reset}                             ${verde}| ${reset}  ${amarelo}[ 90 ]${reset} - ${branco}AstraCampaign ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e "${amarelo}[ 68 ]${reset} - ${branco}WiseMapping ${verde}[1/1]${reset}                      ${verde}| ${reset}  ${amarelo}[ 91 ]${reset} - ${branco}Duplicati ${verde}[1/1]${reset} ${verde}[NOVO]${reset}"
    echo -e ""
    echo -e "${branco}<-- Digite ${amarelo}P1 ${branco}para ir para pagina 1             ${amarelo}|${branco}              Digite ${amarelo}P3${branco} para ir para pagina 3 -->${reset}"
    echo -e ""
}

menu_instalador_pg_3(){
    echo -e "${amarelo}[ 92 ]${reset} - ${branco}PgBackWeb ${verde}[1/1]${reset} ${verde}[NOVO]${reset}                 ${verde}| ${reset}  ${amarelo}[ 115 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 93 ]${reset} - ${branco}Jitsi Meet ${verde}[2/2]${reset} ${verde}[NOVO]${reset}                ${verde}| ${reset}  ${amarelo}[ 116 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 94 ]${reset} - ${branco}Code Server ${verde}[1/1]${reset} ${verde}[NOVO]${reset}               ${verde}| ${reset}  ${amarelo}[ 117 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 95 ]${reset} - ${branco}Papra  ${verde}[1/1]${reset} ${verde}[NOVO]${reset}                    ${verde}| ${reset}  ${amarelo}[ 118 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 96 ]${reset} - ${branco}ZeroByte  ${verde}[1/1]${reset} ${verde}[NOVO]${reset}                 ${verde}| ${reset}  ${amarelo}[ 119 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 97 ]${reset} - ${branco}EM BREVE...${reset}                            ${verde}| ${reset}  ${amarelo}[ 120 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 98 ]${reset} - ${branco}EM BREVE...${reset}                            ${verde}| ${reset}  ${amarelo}[ 121 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 99 ]${reset} - ${branco}EM BREVE...${reset}                            ${verde}| ${reset}  ${amarelo}[ 122 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 100 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 123 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 101 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 124 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 102 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 125 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 103 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 126 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 104 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 127 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 105 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 128 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 106 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 129 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 107 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 130 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 108 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 131 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 109 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 132 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 110 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 133 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 111 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 134 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 112 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 135 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 113 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 136 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e "${amarelo}[ 114 ]${reset} - ${branco}EM BREVE...${reset}                           ${verde}| ${reset}  ${amarelo}[ 137 ]${reset} - ${branco}EM BREVE...${reset}"
    echo -e ""
    echo -e "${branco}<-- Digite ${amarelo}P2 ${branco}para ir para pagina 2             ${amarelo}|${branco}              Digite ${amarelo}P3${branco} para ir para pagina 3 -->${reset}"
    echo -e ""
}

menu_comandos(){
  ## Portainer
  echo -e "> ${verde}Gerenciamento de Serviços:${reset}"
  echo -e "${branco} • ${amarelo}portainer.restart${reset} - ${branco}Reinicia o Portainer${reset}"
  echo -e "${branco} • ${amarelo}portainer.reset${reset} - ${branco}Reseta a senha do Portainer${reset}"
  echo -e "${branco} • ${amarelo}portainer.update${reset} - ${branco}Atualiza o Portainer${reset}"
  echo -e "${branco} • ${amarelo}traefik.update${reset} - ${branco}Atualiza o Traefik${reset}"
  echo -e "${branco} • ${amarelo}traefik.dash${reset} - ${branco}Ativa o Dashboard do Traefik${reset}"
  echo ""

  ## Monitoramento
  echo -e "> ${verde}Comandos de Monitoramento:${reset}"
  echo -e "${branco} • ${amarelo}ctop${reset} - ${branco}Instala o CTOP${reset}"
  echo -e "${branco} • ${amarelo}htop${reset} - ${branco}Instala o HTOP${reset}"
  echo ""

  ## Chatwoot
  echo -e "> ${verde}Comandos do Chatwoot:${reset}"
  echo -e "${branco} • ${amarelo}chatwoot.mail${reset} - ${branco}Troca os Emails do Chatwoot pela versão do Orion${reset}"
  echo -e "${branco} • ${amarelo}chatwoot.n.mail${reset} - ${branco}Troca os Emails do Chatwoot Mega pela versão do Orion${reset}"
  echo ""

  ## Ferramentas
  echo -e "> ${verde}Comandos de Ferramentas:${reset}"
  echo -e "${branco} • ${amarelo}evolution.v1${reset} - ${branco}Instala a Evolution v1.8+${reset}"
  echo -e "${branco} • ${amarelo}evolution.lite${reset} - ${branco}Instala a Evolution Lite${reset}"
  echo -e "${branco} • ${amarelo}transcrevezap${reset} - ${branco}Instala o Transcreve Zap${reset}"
  echo -e "${branco} • ${amarelo}minio.bucket${reset} - ${branco}Cria Buckets Publicas no MinIO${reset}"
  echo ""

  ## Quepasa
  echo -e "> ${verde}Comandos do Quepasa:${reset}"
  echo -e "${branco} • ${amarelo}quepasa.setup.off${reset} - ${branco}Desativa o Setup do Quepasa${reset}"
  echo -e "${branco} • ${amarelo}quepasa.setup.on${reset} - ${branco}Ativa o Setup do Quepasa${reset}"
  echo ""

  ## Manutenção
  echo -e "> ${verde}Comandos de Manutenção:${reset}"
  echo -e "${branco} • ${amarelo}limpar${reset} - ${branco}Limpa Logs, volumes e imagens do Docker não usadas${reset}"

  echo -e ""
  echo -e "${branco}<-- Digite ${amarelo}P1 ${branco}para ir para pagina 1             ${amarelo}|${branco}              Digite ${amarelo}P2${branco} para ir para pagina 2 -->${reset}"
  echo -e ""
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Verificar se stack já existe
verificar_stack() {
    clear
    local nome_stack="$1"

    if docker stack ls --format "{{.Name}}" | grep -q "^${nome_stack}$"; then
        nome_verificar_stack
        echo -e "A stack '$amarelo${nome_stack}\e[0m' existe."
        echo -e "Caso deseje refazer a instalação, por favor, remova a stack $amarelo${nome_stack}\e[0m do"
        echo -e "seu Portainer e tente novamente..."
        echo -e ""
        echo -e "Voltando ao menu principal em 10 segundos"
        sleep 10

        clear 

        return 0
    else
        return 1
    fi
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

# Função para verificar recursos
recursos() {
    # Parâmetros de entrada: vCPU e GbRam
    vcpu_requerido=$1
    ram_requerido=$2

    # Obtendo a quantidade de vCPUs e GB de RAM disponíveis
    if command -v neofetch >/dev/null 2>&1; then
        # Debian 11
        vcpu_disponivel=$(neofetch --stdout | grep "CPU" | grep -oP '\(\d+\)' | tr -d '()')
        ram_disponivel=$(neofetch --stdout | grep "Memory" | awk '{print $4}' | tr -d 'MiB' | awk '{print int($1/1024 + 0.5)}')
    elif command -v fastfetch >/dev/null 2>&1; then
        # Debian 13 (usa saída JSON do fastfetch)
        vcpu_disponivel=$(fastfetch --json | jq '.cpu.cores')
        ram_disponivel=$(fastfetch --json | jq '.memory.total / 1024 / 1024' | awk '{print int($1+0.5)}')
    else
        echo "Erro: nem neofetch nem fastfetch encontrados. Instale um deles para continuar."
        return 1
    fi

    # Comparando os recursos
    if [[ $vcpu_disponivel -ge $vcpu_requerido && $ram_disponivel -ge $ram_requerido ]]; then
        echo "ok"
        clear
        return 0
    else
        clear
        erro_msg
        echo -e "Ops, parece que o seu servidor não atende os requisitos mínimos dessa aplicação."
        echo -e "Esse serviço precisa de \e[32m$vcpu_requerido vCPU${reset} e \e[32m$ram_requerido Gb RAM${reset}."
        echo -e "Atualmente, seu servidor possui apenas: \e[32m$vcpu_disponivel vCPU${reset} com \e[32m$ram_disponivel Gb RAM${reset}."
        echo -e "Você pode ter problemas de desempenho, falhas na execução ou problemas na instalação."

        echo ""
        read -p "Deseja continuar mesmo assim? (y/n): " escolha
        if [[ "$escolha" =~ ^[Yy]$ ]]; then
            return 0
        else
            echo ""
            echo "Voltando ao menu em 10 segundos."
            sleep 10
            nome_menu
            menu_instalador
            return 1
        fi
    fi
}


## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

stack_editavel(){

    ## Instalar jq
    sudo apt install jq -y > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "2/10 - [ OK ] - Instalando JQ Método 1/2"
    else
        echo "2/10 - [ OFF ] - Erro ao instalar JQ Método 1/2"
    fi

    sudo apt-get install -y jq > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "3/10 - [ OK ] - Instalando JQ Método 2/2"
    else
        echo "3/10 - [ OFF ] - Erro ao instalar JQ Método 2/2"
    fi

    ## Definindo o diretório do arquivo dados_portainer
    arquivo="/root/dados_vps/dados_portainer"

    ## Verifica se o arquivo existe
    if [ ! -f "$arquivo" ]; then
        echo "Arquivo não encontrado: $arquivo"
        sleep 2

        ## Cria o arquivo caso não exista
        criar_arquivo
    fi

    ## Remove o https:// caso existir
    sed -i 's/Dominio do portainer: https:\/\/\(.*\)/Dominio do portainer: \1/' "$arquivo"

    ## Pega o usuario do portainer
    USUARIO=$(grep "Usuario: " /root/dados_vps/dados_portainer | awk -F "Usuario: " '{print $2}')
    if [ $? -eq 0 ]; then
        echo -e "4/10 - [ OK ] - Pegando usuario do portainer: $bege$USUARIO$reset"
    else
        echo "4/10 - [ OFF ] - Erro ao pegar usuario do portainer"
    fi


    ## Pega a senha do portainer
    SENHA=$(grep "Senha: " /root/dados_vps/dados_portainer | awk -F "Senha: " '{print $2}')
    esconder_senha "$SENHA"
    if [ $? -eq 0 ]; then
        echo -e "5/10 - [ OK ] - Pegando a senha do portainer: $bege$SENHAOCULTA$reset"
    else
        echo "5/10 - [ OFF ] - Erro ao pegar senha do portainer"
    fi

    ## Pega a URL do portainer
    PORTAINER_URL=$(grep "Dominio do portainer: " /root/dados_vps/dados_portainer | awk -F "Dominio do portainer: " '{print $2}')
    if [ $? -eq 0 ]; then
        echo -e "6/10 - [ OK ] - Pegando dominio do Portainer: $bege$PORTAINER_URL$reset"
    else
        echo "6/10 - [ OFF ] - Erro ao pegar dominio do Portainer"
    fi

    ## Usa o token do portainer
    #TOKEN=$(grep "Token: " /root/dados_vps/dados_portainer | awk -F "Token: " '{print $2}')
    
    ## Pega um token do portainer
    #TOKEN=$(curl -k -X POST -H "Content-Type: application/json" -d "{\"username\":\"$USUARIO\",\"password\":\"$SENHA\"}" https://$PORTAINER_URL/api/auth | jq -r .jwt)

    TOKEN=""
    Tentativa_atual=0
    Maximo_de_tentativas=6
    
    while [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; do
        TOKEN=$(curl -k -s -X POST -H "Content-Type: application/json" -d "{\"username\":\"$USUARIO\",\"password\":\"$SENHA\"}" https://$PORTAINER_URL/api/auth | jq -r .jwt)
    
        Tentativa_atual=$((Tentativa_atual + 1))
    
        ## Verifica se atingiu o número máximo de tentativas
        if [ "$Tentativa_atual" -ge "$Maximo_de_tentativas" ]; then
            clear
            erro_msg
            echo "7/10 - [ OFF ] - Erro: Falha ao obter token após $Maximo_de_tentativas tentativas."
            echo "Verifique suas credenciais do Portainer para conseguirmos realizar o deploy."
            sleep 5
            criar_arquivo
            return
            #exit 1
        fi
    
        ## Se o token foi obtido com sucesso, sair do loop
        if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
            break
        fi
    
        ## Aguarda alguns segundos antes de tentar novamente
        echo -e "Tentando gerar token do portainer. Tentativa atual $bege$Tentativa_atual/5$reset"
        sleep 5
    done
    
    if [ $? -eq 0 ]; then
        esconder_senha "$TOKEN"
        echo -e "7/10 - [ OK ] - Pegando token do Portainer: $bege$SENHAOCULTA$reset"
    fi
    

    ### Verifica se o token veio vazio
    #if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
    #    echo "Erro: Falha ao obter token. Preencha com suas credenciais do portainer a seguir."
    #    sleep 5
    #    criar_arquivo
    #    #exit 1
    #fi

    ## Salva dados no arquivo do portainer
    echo -e "[ PORTAINER ]\nDominio do portainer: $PORTAINER_URL\n\nUsuario: $USUARIO\n\nSenha: $SENHA\n\nToken: $TOKEN" > "/root/dados_vps/dados_portainer"

    ## Pegando o id do portainer
    ENDPOINT_ID=$(curl -k -s -X GET -H "Authorization: Bearer $TOKEN" https://$PORTAINER_URL/api/endpoints | jq -r '.[] | select(.Name == "primary") | .Id')
    if [ $? -eq 0 ]; then
        echo -e "8/10 - [ OK ] - Pegando ID do Portainer: $bege$ENDPOINT_ID$reset"
    else
        echo "8/10 - [ OFF ] - Erro ao pegar ID do Portainer"
    fi

    ## Definindo id 1 do Portainer
    #ENDPOINT_ID=1
    
    ## Pegando o ID do Swarm
    SWARM_ID=$(curl -k -s -X GET -H "Authorization: Bearer $TOKEN" "https://$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/swarm" | jq -r .ID)
    if [ $? -eq 0 ]; then
        echo -e "9/10 - [ OK ] - Pegando ID do Swarm: $bege$SWARM_ID$reset"
    else
        echo "9/10 - [ OFF ] - Erro ao pegar ID do Swarm"
    fi

    ## Testa o Swarm
    SWARM_STATUS=$(docker info --format '{{.Swarm.LocalNodeState}}')
    if [ "$SWARM_STATUS" != "active" ]; then
        echo "Erro: Docker Swarm não está ativo."
        exit 1
    fi

    # Arquivo temporário para capturar a saída de erro e a resposta
    erro_output=$(mktemp)
    response_output=$(mktemp)

    ## Fazendo deploy da stack pelo portainer
    http_code=$(curl -s -o "$response_output" -w "%{http_code}" -k -X POST \
    -H "Authorization: Bearer $TOKEN" \
    -F "Name=$STACK_NAME" \
    -F "file=@$(pwd)/$STACK_NAME.yaml" \
    -F "SwarmID=$SWARM_ID" \
    -F "endpointId=$ENDPOINT_ID" \
    "https://$PORTAINER_URL/api/stacks/create/swarm/file" 2> "$erro_output")

    response_body=$(cat "$response_output")

    if [ "$http_code" -eq 200 ]; then
        # Verifica o conteúdo da resposta para garantir que o deploy foi bem-sucedido
        if echo "$response_body" | grep -q "\"Id\""; then
            echo -e "10/10 - [ OK ] - Deploy da stack $bege$STACK_NAME$reset feito com sucesso!"
        else
            echo -e "10/10 - [ OFF ] - Erro, resposta inesperada do servidor ao tentar efetuar deploy da stack $bege$STACK_NAME$reset."
            echo "Resposta do servidor: $(echo "$response_body" | jq .)"
        fi
    else
        echo "10/10 - [ OFF ] - Erro ao efetuar deploy. Resposta HTTP: $http_code"
        echo "Mensagem de erro: $(cat "$erro_output")"
        echo "Detalhes: $(echo "$response_body" | jq .)"
    fi

    echo ""

    # Remove os arquivos temporários
    rm "$erro_output"
    rm "$response_output"
}

## Função para verificar se o arquivo de dados do Portainer existe
verificar_arquivo() {
    sudo apt install jq -y > /dev/null 2>&1
    if [ ! -f "/root/dados_vps/dados_portainer" ]; then
        nome_credenciais
        criar_arquivo
    else
        verificar_campos
    fi
}


## Função para criar o arquivo de dados do Portainer
criar_arquivo() {
    if [ -f "/root/dados_vps/dados_portainer" ]; then
        rm "/root/dados_vps/dados_portainer"
        echo "Arquivo existente removido."
    fi

    ## Caso não exista o arquivo ele vai pedir os dados para criar.
    nome_credenciais
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    #echo -e "\e[97mObs: Coloque o https:// antes do link do portainer\e[0m"
    read -p "Digite a Url do Portainer (ex: portainer.oriondesign.art.br): " PORTAINER_URL
    echo ""

    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    read -p "Digite seu Usuario (ex: admin): " USUARIO
    echo ""

    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "\e[97mObs: A Senha não aparecera ao digitar\e[0m"
    read -s -p "Digite a Senha (ex: @Senha123_): " SENHA
    echo ""

    verificar_token "$PORTAINER_URL" "$USUARIO" "$SENHA" true
}


## Função para verificar os campos do arquivo de dados do Portainer
verificar_campos() {
    PORTAINER_URL=$(grep -oP '(?<=Dominio do portainer: ).*' /root/dados_vps/dados_portainer)
    USUARIO=$(grep -oP '(?<=Usuario: ).*' /root/dados_vps/dados_portainer)
    SENHA=$(grep -oP '(?<=Senha: ).*' /root/dados_vps/dados_portainer)

    ## se por acaso não tiver login nem senha lá vem para ca
    if [ -z "$USUARIO" ] || [ -z "$SENHA" ]; then
        
        nome_credenciais
        echo -e "\e[97mPasso$amarelo 1/3\e[0m"
        #echo -e "\e[97mObs: Coloque o https:// antes do link do portainer\e[0m"
        read -p "Digite a Url do Portainer (ex: portainer.oriondesign.art.br): " PORTAINER_URL
        echo ""
    
        echo -e "\e[97mPasso$amarelo 2/3\e[0m"
        read -p "Digite seu Usuario (ex: admin): " USUARIO
        echo ""
    
        echo -e "\e[97mPasso$amarelo 3/3\e[0m"
        echo -e "\e[97mObs: A Senha não aparecera ao digitar\e[0m"
        read -s -p "Digite a Senha (ex: @Senha123_): " SENHA
        echo ""

        ATUALIZAR="true" ## Verificar se já existe TOKEN no arquivo
        verificar_token "$PORTAINER_URL" "$USUARIO" "$SENHA" true
    ## Caso o usuario e senha estiver como "Precisa criar dentro do portainer" como o arquivo oficial vem para ca
    elif [ "$USUARIO" == "Precisa criar dentro do portainer" ] || [ "$SENHA" == "Precisa criar dentro do portainer" ]; then
        
        nome_credenciais
        echo -e "\e[97mPasso$amarelo 1/3\e[0m"
        #echo -e "\e[97mObs: Coloque o https:// antes do link do portainer\e[0m"
        read -p "Digite a Url do Portainer (ex: portainer.oriondesign.art.br): " PORTAINER_URL
        echo ""
    
        echo -e "\e[97mPasso$amarelo 2/3\e[0m"
        read -p "Digite seu Usuario (ex: admin): " USUARIO
        echo ""
    
        echo -e "\e[97mPasso$amarelo 3/3\e[0m"
        echo -e "\e[97mObs: A Senha não aparecera ao digitar\e[0m"
        read -s -p "Digite a Senha (ex: @Senha123_): " NOVA_SENHA
        echo ""

        verificar_token "$PORTAINER_URL" "$NOVO_USUARIO" "$NOVA_SENHA" true
    else
        verificar_token "$PORTAINER_URL" "$USUARIO" "$SENHA" false
    fi
}

## Função para verificar se o token é válido
verificar_token() {
    PORTAINER_URL="$1"
    USUARIO="$2"
    SENHA="$3"
    ATUALIZAR="$4"
    TENTATIVAS=0
    MAX_TENTATIVAS=5

    while [ $TENTATIVAS -lt $MAX_TENTATIVAS ]; do
        TENTATIVAS=$((TENTATIVAS+1))

        #echo -e "Dados a serem testados:"
        #echo "Link do Portainer: $PORTAINER_URL"
        #echo "Usuário: $USUARIO"
        #echo "Senha: $SENHA"

        RESPONSE=$(curl -s -w "\n%{http_code}" -k -X POST -H "Content-Type: application/json" -d "{\"username\":\"$USUARIO\",\"password\":\"$SENHA\"}" "https://$PORTAINER_URL/api/auth")
        TOKEN=$(echo "$RESPONSE" | sed '$d' | jq -r '.jwt')
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)

        if [ "$HTTP_STATUS" -eq 200 ] && [ ! -z "$TOKEN" ]; then
    
            if [ "$ATUALIZAR" == true ]; then
                atualizar_arquivo
            fi

            $APP_ORION

            break
        else
            if [ $TENTATIVAS -gt 1 ]; then
                clear
                erro_msg
                echo ""
                echo ""
                echo "              Não foi possivel autenticar suas credenciais. Por favor tente novamente"
                echo "                                           Tentativa: $TENTATIVAS/$MAX_TENTATIVAS"
    
                sleep 3

            else
                clear
                nome_credenciais
            fi

            if [ $TENTATIVAS -lt $MAX_TENTATIVAS ]; then
                
                nome_credenciais
                echo -e "\e[97mPasso$amarelo 1/3\e[0m"
                #echo -e "\e[97mObs: Coloque o https:// antes do link do portainer\e[0m"
                read -p "Digite a Url do Portainer (ex: portainer.oriondesign.art.br): " PORTAINER_URL
                echo ""
            
                echo -e "\e[97mPasso$amarelo 2/3\e[0m"
                read -p "Digite seu Usuario (ex: admin): " USUARIO
                echo ""
            
                echo -e "\e[97mPasso$amarelo 3/3\e[0m"
                echo -e "\e[97mObs: A Senha não aparecera ao digitar\e[0m"
                read -s -p "Digite a Senha (ex: @Senha123_): " SENHA
                echo ""
                ATUALIZAR="true"
            else
                clear
                erro_msg

                echo ""
                echo ""
                echo "                         Você atingiu o limite maximo de tentativas ($TENTATIVAS/$MAX_TENTATIVAS)."
                echo "                         Tente novamente quando lembrar da sua credencial!"
                echo 5
                clear
                break
            fi
        fi
    done
}

## Função para atualizar o arquivo de dados do Portainer com o novo usuário e senha
atualizar_arquivo() {
    echo -e "[ PORTAINER ]\nDominio do portainer: $PORTAINER_URL\n\nUsuario: $USUARIO\n\nSenha: $SENHA\n\nToken: $TOKEN" > "/root/dados_vps/dados_portainer"
    echo -e "\nArquivo de dados do Portainer atualizado com sucesso!"
}

telemetria() {
    ## Pega o IP da máquina
    read -r ip _ <<< "$(hostname -I)"

    ip="$ip"
    ferramenta="$1"
    status="$2"

    curl --max-time 30 -X POST 'https://telemetria.oriondesign.art.br/api/telemetria' \
    -H "Content-Type: application/json" \
    -d '{
      "ip": "'"$ip"'",
      "ferramenta": "'"$ferramenta"'",
      "status": "'"$status"'"
    }' > /dev/null 2>&1
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Verificadores


## Verifica se existe Docker, Portainer e Traefik na VPS
verificar_docker_e_portainer_traefik() {
    ## Verifica se o Docker está instalado
    if ! command -v docker &> /dev/null; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[1] Traefik e Portainer${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    ## Verifica se o Portainer está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "portainer"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[1] Traefik e Portainer${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    ## Verificar se o Traefik está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "traefik"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[1] Traefik e Portainer${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verifica se existe Minio
verificar_antes_se_tem_minio() {

    ## Verifica se o Portainer está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "minio"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 4 ] - MinIO${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

verificar_antes_se_tem_clickhouse() {
  
  ## Verifica se o Portainer está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "clickhouse"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 58 ] - ClickHouse${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verifica se existe rabbitMQ
verificar_antes_se_tem_rabbitmq() {

    ## Verifica se o Portainer está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "rabbitmq"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 14 ] - RabbitMQ${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verifica se existe Minio RabbitMQ e Chatwoot 
verificar_antes_se_tem_minio_e_rabbitmq_e_chatwoot() {
    ## Verifica se o minio está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "minio"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 4 ] - MinIO${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    ## Verifica se o rabbitmq está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "rabbitmq"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 14 ] - RabbitMQ${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    ## Verificar se o chatwoot está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "chatwoot"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 2 ] - Chatwoot${reset} ou  \e[32m[ 26 ] - Chatwoot Nestor (ft. Francis) ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verifica se existe Minio e Qdrant
verificar_antes_se_tem_minio_e_qdrant() {
    ## Verifica se o minio está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "minio"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 4 ] - MinIO${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    ## Verifica se o rabbitmq está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "qdrant"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 19 ] - Qdrant${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verifica se existe Minio
verificar_antes_se_tem_mongo() {

    ## Verifica se o Portainer está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "mongodb"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 13 ] - MongoDB${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verifica se existe Qdrant
verificar_antes_se_tem_qdrant() {

    ## Verifica se o Portainer está instalado
    if ! docker ps -a --format "{{.Names}}" | grep -q "qdrant"; then
        clear
        erro_msg
        echo -e "Ops, parece que você não instalou a opção \e[32m[ 19 ] - Qdrant${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."

        echo ""
        echo "Voltando ao menu em 5 segundos."
        sleep 5

        nome_menu
        menu_instalador

        return 1
    fi

    return 0
}

## Verificar Container Postgres

verificar_container_postgres() {
    if docker ps -q --filter "name=postgres_postgres.1" | grep -q .; then
        return 0
    else
        return 1
    fi
}

## Verificar Container PgVector

verificar_container_pgvector() {
    if docker ps -q --filter "name=pgvector_pgvector.1" | grep -q .; then
        return 0
    else
        return 1
    fi
}

## Verificar Container Mysql

verificar_container_mysql() {
    if docker ps -q --filter "name=mysql_mysql.1" | grep -q .; then
        return 0
    else
        return 1
    fi
}

## Verificar Container Redis

verificar_container_redis() {
    if docker ps -q --filter "name=redis_redis.1" | grep -q .; then
        return 0
    else
        return 1
    fi
}

## Verificar Container Minio

verificar_container_minio() {
    if docker ps -q --filter "name=minio_minio.1" | grep -q .; then
        return 0
    else
        return 1
    fi
}

## Esperar Postgres estar pronto

wait_for_postgres() {
    dados
    local container_name="postgres_postgres"

    while true; do
        CONTAINER_ID=$(docker ps -q --filter "name=.*$container_name.*")

        if [ -n "$CONTAINER_ID" ]; then

            break
        fi

        sleep 5
    done
}

wait_for_pgvector() {
    dados
    local container_name="pgvector_pgvector.1"

    while true; do
        CONTAINER_ID=$(docker ps -q --filter "name=.*$container_name.*")

        if [ -n "$CONTAINER_ID" ]; then

            break
        fi

        sleep 5
    done
}

## Verificar se o Traefik esta online

wait_30_sec() {
    sleep 30
}

#wait_stack() {
#    echo "Este processo pode demorar um pouco. Se levar mais de 5 minutos, cancele, pois algo deu errado."
#    while true; do
#        # Verifica se o serviço trarik está ativo
#        if docker service ls --filter "name=$1" | grep "1/1"; then
#            sleep 10
#            echo ""
#            break
#        fi
#
#        sleep 5
#    done
#}
wait_stack() {
    echo "Este processo pode demorar um pouco. Se levar mais de 10 minutos, cancele, pois algo deu errado."
    declare -A services_status

    # Inicializa o status de todos os serviços como "pendente"
    for service in "$@"; do
        services_status["$service"]="pendente"
    done

    while true; do
        all_active=true

        for service in "${!services_status[@]}"; do
            if docker service ls --filter "name=$service" | grep -q "1/1"; then
                if [ "${services_status["$service"]}" != "ativo" ]; then
                    echo -e "🟢 O serviço \e[32m$service\e[0m está online."
                    services_status["$service"]="ativo"
                fi
            else
                if [ "${services_status["$service"]}" != "pendente" ]; then
                    services_status["$service"]="pendente"
                fi
                all_active=false
            fi
        done

        # Sai do loop quando todos os serviços estiverem ativos
        if $all_active; then
            sleep 1
            break
        fi
        sleep 30
        echo ""
    done
}

#pull() {
#
#    for image in "$@"; do     
#        if docker pull "$image" > /dev/null 2>&1; then
#            sleep 1
#        else
#            echo "*"
#            sleep 1
#        fi
#    done
#}

pull() {
    for image in "$@"; do
        while true; do
            if docker pull "$image" > /dev/null 2>&1; then
                sleep 1
                break
            else
                echo "Erro ao baixar $image. Tentando novamente..."
                
                # Verifica se o erro é relacionado a limite de taxa
                if docker pull "$image" 2>&1 | grep -q "toomanyrequests"; then
                    echo "Limite de taxa atingido no Docker Hub. Faça login para continuar."
                    docker login
                else
                    echo "Erro desconhecido. Tentando novamente em 5s..."
                    sleep 5
                fi
            fi
        done
    done
}

requisitar_outra_instalacao(){
    read -p "Deseja instalar outra aplicação? (Y/N): " choice
    if [ "$choice" = "Y" ] || [ "$choice" = "y" ]; then
        return
    else
        cd
        cd
        clear
        exit 1
    fi
}

esconder_senha() {
  local senha="$1"
  local tamanho=${#senha}

  if (( tamanho > 55 )); then
    SENHAOCULTA=$(printf '%*s' 54 '' | tr ' ' '*')
  else
    SENHAOCULTA=$(printf '%*s' "$tamanho" '' | tr ' ' '*')
  fi
}



## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Pegar informações


## Pegar senha Postgres

pegar_senha_postgres() {
    while :; do
        if [ -f /root/postgres.yaml ]; then
            senha_postgres=$(grep "POSTGRES_PASSWORD" /root/postgres.yaml | awk -F '=' '{print $2}')
            break
        else
            sleep 5
        fi
    done
}

pegar_senha_pgvector() {
    while :; do
        if [ -f /root/pgvector.yaml ]; then
            senha_pgvector=$(grep "POSTGRES_PASSWORD" /root/pgvector.yaml | awk -F '=' '{print $2}')
            break
        else
            sleep 5
        fi
    done
}

pegar_user_senha_rabbitmq() {
    while :; do
        if [ -f /root/rabbitmq.yaml ]; then
            user_rabbit_mqs=$(grep "RABBITMQ_DEFAULT_USER" /root/rabbitmq.yaml | awk -F ': ' '{print $2}')
            senha_rabbit_mqs=$(grep "RABBITMQ_DEFAULT_PASS" /root/rabbitmq.yaml | awk -F ': ' '{print $2}')
            url_rabbit_mqs=$(grep "traefik.http.routers.rabbitmq.rule" /root/rabbitmq.yaml | awk -F'[`]' '{print $2}')
            break
        else
            sleep 5
            echo "erro"
        fi
    done
}

## Pegar senha Mysql

pegar_senha_mysql() {
    while :; do
        if [ -f /root/mysql.yaml ]; then
            senha_mysql=$(grep "MYSQL_ROOT_PASSWORD" /root/mysql.yaml | awk -F '=' '{print $2}')
            break
        else
            sleep 5
        fi
    done
}

## Pegar senha Minio

pegar_senha_minio() {
    user_minio=$(grep -i "MINIO_ROOT_USER" /root/minio.yaml | head -1 | sed 's/#.*//' | sed 's/.*=//; s/^[[:space:]]*//; s/[[:space:]]*$//')
    senha_minio=$(grep -i "MINIO_ROOT_PASSWORD" /root/minio.yaml | head -1 | sed 's/#.*//' | sed 's/.*=//; s/^[[:space:]]*//; s/[[:space:]]*$//')
    url_minio=$(grep -i "MINIO_BROWSER_REDIRECT_URL" /root/minio.yaml | head -1 | sed 's/#.*//' | sed 's/.*=//; s/^[[:space:]]*//; s/[[:space:]]*$//' | sed 's|https://||')
    url_s3=$(grep -i "MINIO_SERVER_URL" /root/minio.yaml | head -1 | sed 's/#.*//' | sed 's/.*=//; s/^[[:space:]]*//; s/[[:space:]]*$//' | sed 's|https://||')
}

pegar_senha_mongodb() {
  user_mongo=$(grep "MONGO_INITDB_ROOT_USERNAME" /root/mongodb.yaml | awk -F '=' '{print $2}')
  pass_mongo=$(grep "MONGO_INITDB_ROOT_PASSWORD" /root/mongodb.yaml | awk -F '=' '{print $2}')

}

## Pegar link S3
pegar_link_s3() {
    url_s3=$(grep -i "MINIO_SERVER_URL" /root/minio.yaml | head -1 | sed 's/#.*//' | sed 's/.*=//; s/^[[:space:]]*//; s/[[:space:]]*$//' | sed 's|https://||')
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Criadores de banco de dados Postgres
criar_banco_postgres_da_stack() {
    while :; do
        if docker ps -q --filter "name=^postgres_postgres" | grep -q .; then
            CONTAINER_ID=$(docker ps -q --filter "name=^postgres_postgres")

            # Verificar se o banco de dados já existe
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "$1"

            if [ $? -eq 0 ]; then
                ## echo ""
                read -p "O banco de dados $1 já existe. Deseja apagar e criar um novo banco de dados? (Y/N): " resposta
                if [ "$resposta" == "Y" ] || [ "$resposta" == "y" ]; then
                    # Apagar o banco de dados
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS $1(force);" > /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                    echo "" ## Sucesso
                    else
                        echo "" ## Erro
                    fi
                    # Criar o banco de dados novamente
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE $1;" > /dev/null 2>&1
                else
                    echo ""
                fi
                break
            else
                # Criar o banco de dados
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE $1;" > /dev/null 2>&1
                
                # Verificar novamente se o banco de dados foi criado com sucesso
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "$1"

                if [ $? -eq 0 ]; then
                    nada="nada"
                    break
                else
                    echo "Erro ao criar o banco de dados. Tentando novamente..."
                    echo ""
                fi
            fi
        else
            sleep 5
        fi
    done
}

## Criar banco PgVector
criar_banco_pgvector_da_stack() {
    while :; do
        if docker ps -q --filter "name=^pgvector_pgvector" | grep -q .; then
            CONTAINER_PGVECTOR_ID=$(docker ps -q --filter "name=^pgvector_pgvector")

            # Verificar se o banco de dados já existe
            docker exec "$CONTAINER_PGVECTOR_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "$1"

            if [ $? -eq 0 ]; then
                echo ""
                read -p "O banco de dados $1 já existe. Deseja apagar e criar um novo banco de dados? (Y/N): " resposta
                if [ "$resposta" == "Y" ] || [ "$resposta" == "y" ]; then
                    # Apagar o banco de dados
                    docker exec "$CONTAINER_PGVECTOR_ID" psql -U postgres -c "DROP DATABASE IF EXISTS $1(force);" > /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                    echo "" ## Sucesso
                    else
                        echo "" ## Erro
                    fi
                    # Criar o banco de dados novamente
                    docker exec "$CONTAINER_PGVECTOR_ID" psql -U postgres -c "CREATE DATABASE $1;" > /dev/null 2>&1
                else
                    echo ""
                fi
                break
            else
                # Criar o banco de dados
                docker exec "$CONTAINER_PGVECTOR_ID" psql -U postgres -c "CREATE DATABASE $1;" > /dev/null 2>&1
                
                # Verificar novamente se o banco de dados foi criado com sucesso
                docker exec "$CONTAINER_PGVECTOR_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "$1"

                if [ $? -eq 0 ]; then
                    nada="nada"
                    break
                else
                    echo "Erro ao criar o banco de dados. Tentando novamente..."
                    echo ""
                fi
            fi
        else
            sleep 5
        fi
    done
}

## Criar banco MySQL
criar_banco_mysql_da_stack() {
    while :; do
        if docker ps -q --filter "name=^mysql_mysql" | grep -q .; then
            CONTAINER_ID=$(docker ps -q --filter "name=^mysql_mysql")

            # Verificar se o banco de dados já existe
            docker exec -e MYSQL_PWD="$senha_mysql" "$CONTAINER_ID" mysql -u root \
                -e "SHOW DATABASES LIKE '$1';" | grep -qw "$1"

            if [ $? -eq 0 ]; then
                echo ""
                read -p "O banco de dados $1 já existe. Deseja apagar e criar \
um novo banco de dados? (Y/N): " resposta
                if [ "$resposta" == "Y" ] || [ "$resposta" == "y" ]; then
                    # Apagar o banco de dados
                    docker exec -e MYSQL_PWD="$senha_mysql" "$CONTAINER_ID" mysql -u root \
                        -e "DROP DATABASE IF EXISTS $1;" > /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                        echo "" ## Sucesso
                    else
                        echo "" ## Erro
                    fi
                    # Criar o banco de dados novamente
                    docker exec -e MYSQL_PWD="$senha_mysql" "$CONTAINER_ID" mysql -u root \
                        -e "CREATE DATABASE $1;" > /dev/null 2>&1
                else
                    echo ""
                fi
                break
            else
                # Criar o banco de dados
                docker exec -e MYSQL_PWD="$senha_mysql" "$CONTAINER_ID" mysql -u root \
                    -e "CREATE DATABASE $1;" > /dev/null 2>&1

                # Verificar se o banco foi criado com sucesso
                docker exec -e MYSQL_PWD="$senha_mysql" "$CONTAINER_ID" mysql -u root \
                    -e "SHOW DATABASES LIKE '$1';" | grep -qw "$1"

                if [ $? -eq 0 ]; then
                    nada="nada"
                    break
                else
                    echo "Erro ao criar o banco de dados. Tentando novamente..."
                    echo ""
                fi
            fi
        else
            echo "Container MySQL não encontrado. Tentando novamente..."
            echo ""
            sleep 5
        fi
    done
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

validar_senha() { 
    senha=$1
    tamanho_minimo=$2
    tem_erro=0
    mensagem_erro=""

    # Verifica comprimento mínimo
    if [ ${#senha} -lt $tamanho_minimo ]; then
        mensagem_erro+="\n- Senha precisa ter no mínimo $tamanho_minimo caracteres"
        tem_erro=1
    fi

    # Verifica letra maiúscula
    if ! [[ $senha =~ [A-Z] ]]; then
        mensagem_erro+="\n- Falta pelo menos uma letra maiúscula"
        tem_erro=1
    fi

    # Verifica letra minúscula
    if ! [[ $senha =~ [a-z] ]]; then
        mensagem_erro+="\n- Falta pelo menos uma letra minúscula"
        tem_erro=1
    fi

    # Verifica número
    if ! [[ $senha =~ [0-9] ]]; then
        mensagem_erro+="\n- Falta pelo menos um número"
        tem_erro=1
    fi

    # Verifica caracteres especiais permitidos
    if ! [[ $senha =~ [@_] ]]; then
        mensagem_erro+="\n- Falta pelo menos um caractere especial (@ ou _)"
        tem_erro=1
    fi

    # Verifica caracteres não permitidos
    if [[ $senha =~ [^A-Za-z0-9@_] ]]; then
        mensagem_erro+="\n- Contém caracteres especiais não permitidos (use apenas @ ou _)"
        tem_erro=1
    fi

    # Se houver erro, mostra as mensagens
    if [ $tem_erro -eq 1 ]; then
        echo -e "Senha inválida! Corrija os seguintes problemas:$mensagem_erro"
        return 1
    fi

    return 0
}

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Instalação das Ferramentas

## ████████╗███████╗███████╗████████╗███████╗    ███████╗███╗   ███╗████████╗██████╗ 
## ╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██╔════╝    ██╔════╝████╗ ████║╚══██╔══╝██╔══██╗
##    ██║   █████╗  ███████╗   ██║   █████╗      ███████╗██╔████╔██║   ██║   ██████╔╝
##    ██║   ██╔══╝  ╚════██║   ██║   ██╔══╝      ╚════██║██║╚██╔╝██║   ██║   ██╔═══╝ 
##    ██║   ███████╗███████║   ██║   ███████╗    ███████║██║ ╚═╝ ██║   ██║   ██║     
##    ╚═╝   ╚══════╝╚══════╝   ╚═╝   ╚══════╝    ╚══════╝╚═╝     ╚═╝   ╚═╝   ╚═╝     
                                                                                  
ferramenta_testeemail() {
    clear
    dados
    nome_testeemail
    preencha_as_info

    while true; do
        echo -e "\e[97mPasso${amarelo} 1/5\e[0m"
        echo -en "\e[33mDigite o endereço de Email (ex: contato@oriondesign.art.br): \e[0m"
        read -r email_teste
        echo ""

        echo -e "\e[97mPasso${amarelo} 2/5\e[0m"
        echo -e "${amarelo}--> Caso não tiver um usuário do email, use o próprio email abaixo"
        echo -en "\e[33mDigite o usuário de Email (ex: oriondesign ou contato@oriondesign.art.br): \e[0m"
        read -r user_teste
        echo ""

        echo -e "\e[97mPasso${amarelo} 3/5\e[0m"
        echo -e "${amarelo}--> Sem caracteres especiais: !#$ | Se estiver usando Gmail, use a senha de app"
        echo -en "\e[33mDigite a Senha do email (ex: @Senha123_): \e[0m"
        read -r senha_teste
        echo ""

        echo -e "\e[97mPasso${amarelo} 4/5\e[0m"
        echo -en "\e[33mDigite o Host SMTP (ex: smtp.hostinger.com): \e[0m"
        read -r host_teste
        echo ""

        echo -e "\e[97mPasso${amarelo} 5/5\e[0m"
        echo -en "\e[33mDigite a Porta SMTP (ex: 465): \e[0m"
        read -r porta_teste
        echo ""

        clear
        nome_testeemail
        conferindo_as_info

        echo -e "\e[33mEmail SMTP: \e[97m$email_teste\e[0m"
        echo ""
        echo -e "\e[33mUsuário SMTP: \e[97m$user_teste\e[0m"
        echo ""
        echo -e "\e[33mSenha SMTP: \e[97m$senha_teste\e[0m"
        echo ""
        echo -e "\e[33mHost SMTP: \e[97m$host_teste\e[0m"
        echo ""
        echo -e "\e[33mPorta SMTP: \e[97m$porta_teste\e[0m"
        echo ""

        read -p "As respostas estão corretas? (Y/N): " confirmacao
        if [[ "$confirmacao" =~ ^[Yy]$ ]]; then
            clear
            nome_testando
            break
        else
            clear
            nome_testeemail
            preencha_as_info
        fi
    done

    # Mensagem de Início
    echo -e "\e[97m• INICIANDO VERIFICAÇÃO \e[33m[1/3]\e[0m"
    echo ""

    sudo apt-get update > /dev/null 2>&1
    sudo apt-get install swaks -y > /dev/null 2>&1

    msg="Se você está lendo isso, o seu SMTP está funcionando =D.
By: OrionDesign"

    if swaks --to "$email_teste" --from "$email_teste" \
             --server "$host_teste" --port "$porta_teste" \
             --auth LOGIN --auth-user "$user_teste" \
             --auth-password "$senha_teste" --tls \
             --header "Subject: ✅ Teste de SMTP - OrionDesign" \
             --header "Content-Type: text/plain; charset=UTF-8" \
             --body "$msg"; then

        sleep 2
        clear
        nome_testeemail
        echo -e "\e[32m[Resultado do Teste SMTP]\e[0m"
        echo ""
        echo -e "\e[33mOs dados informados \e[92mestão funcionando corretamente\e[33m.\e[0m"

    else
        sleep 2
        clear
        nome_testeemail
        echo -e "\e[32m[Resultado do Teste SMTP]\e[0m"
        echo ""
        echo -e "\e[33mOs dados informados \e[91mNÃO estão funcionando corretamente\e[33m. Por favor, verifique os dados e tente novamente.\e[0m"
    fi
        echo ""
        echo -e "\e[33mEmail SMTP: \e[97m$email_teste\e[0m"
        echo ""
        echo -e "\e[33mUsuário SMTP: \e[97m$user_teste\e[0m"
        echo ""
        echo -e "\e[33mSenha SMTP: \e[97m$senha_teste\e[0m"
        echo ""
        echo -e "\e[33mHost SMTP: \e[97m$host_teste\e[0m"
        echo ""
        echo -e "\e[33mPorta SMTP: \e[97m$porta_teste\e[0m"

    creditos_msg

    read -p "Deseja instalar outra aplicação? (Y/N): " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        return
    else
        cd || exit
        clear
        exit 1
    fi
}

##   ████████╗██████╗  █████╗ ███████╗███████╗██╗██╗  ██╗    ███████╗     
##   ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██║██║ ██╔╝    ██╔════╝     
##      ██║   ██████╔╝███████║█████╗  █████╗  ██║█████╔╝     █████╗       
##      ██║   ██╔══██╗██╔══██║██╔══╝  ██╔══╝  ██║██╔═██╗     ██╔══╝       
##      ██║   ██║  ██║██║  ██║███████╗██║     ██║██║  ██╗    ███████╗     
##      ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝    ╚══════╝     
##                                                                        
## ██████╗  ██████╗ ██████╗ ████████╗ █████╗ ██╗███╗   ██╗███████╗██████╗ 
## ██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██╔══██╗██║████╗  ██║██╔════╝██╔══██╗
## ██████╔╝██║   ██║██████╔╝   ██║   ███████║██║██╔██╗ ██║█████╗  ██████╔╝
## ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██╔══██║██║██║╚██╗██║██╔══╝  ██╔══██╗
## ██║     ╚██████╔╝██║  ██║   ██║   ██║  ██║██║██║ ╚████║███████╗██║  ██║
## ╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝

ferramenta_traefik_e_portainer() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Mostra o nome da aplicação
nome_traefik_e_portainer

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Portainer (ex: portainer.oriondesign.art.br): \e[0m" && read -r url_portainer
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite um usuario para o Portainer (ex: admin): \e[0m" && read -r user_portainer
    echo ""

    ##Pergunta o Dominio para aplicação
    while true; do
      echo -e "\e[97mPasso$amarelo 3/6\e[0m"
      echo -e "$amarelo--> Minimo 12 caracteres. Use Letras MAIUSCULAS e minusculas, numero e um caractere especial @ ou _"
      echo -e "$amarelo--> Evite os caracteres especiais como: \!#$"
      echo -en "\e[33mDigite uma senha para o Portainer (ex: @Senha123456_): \e[0m" && read -r pass_portainer
      echo ""

      if validar_senha "$pass_portainer" 12; then
          break
      fi
      echo ""
    done

    ## Pergunta o Nome do Servidor
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Não pode conter Espaços e/ou cartacteres especiais"
    echo -en "\e[33mEscolha um nome para o seu servidor (ex: OrionDesign): \e[0m" && read -r nome_servidor
    echo ""
    
    ## Pergunta o nome da Rede Interna
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -e "$amarelo--> Não pode conter Espaços e/ou cartacteres especiais."
    echo -en "\e[33mDigite um nome para sua rede interna (ex: OrionNet): \e[0m" && read -r nome_rede_interna
    echo ""
    
    ## Pergunta o Email para informações sobre o certificado
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite um endereço de Email válido (ex: contato@oriondesign.art.br): \e[0m" && read -r email_ssl
    echo ""

    ## Limpa o termianl
    clear

    ## Mostra o nome da aplicação
    nome_traefik_e_portainer

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mLink do Portainer:\e[97m $url_portainer\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUsuario do Portainer:\e[97m $user_portainer\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do Portainer:\e[97m $pass_portainer\e[0m"
    echo ""

    ## Informação sobre Nome do Servidor
    echo -e "\e[33mNome do Servidor:\e[97m $nome_servidor\e[0m"
    echo ""

    ## Informação sobre Nome da Rede interna
    echo -e "\e[33mRede interna:\e[97m $nome_rede_interna\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mEmail:\e[97m $email_ssl\e[0m"
    echo ""
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_traefik_e_portainer

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO TRAEFIK \e[33m[1/9]\e[0m"
echo ""
sleep 1

## Neste passo vamos estar salvando os dados preenchidos anteriormente para que o instalador possa usar posteriormente na instalação de qualquer ferramenta.

## Garante que o usuario esteja no /root/
cd
cd

## Verifica se já não existe uma pasta chamada "dados_vps", se existir ele ignora e se não existir ele cria uma
## Esta foi uma PR que veio do usuario Fabio => https://github.com/hipnologo

if [ ! -d "dados_vps" ]; then
    mkdir dados_vps
fi

## Fim da PR

## Abre a pasta dados_vps
cd dados_vps

## Cria um arquivo chamado "dados_vps" com: "nome do servidor", "nome da rede interna", "email", "link do portainer"
cat > dados_vps << EOL
[DADOS DA VPS]

Estes dados foram preenchidos na hora que você foi instalar o Traefik e Portainer e
serão utilizados para realizar as instalações no do SetupOrion v.2

Nome do Servidor: $nome_servidor

Rede interna: $nome_rede_interna

Email para SSL: $email_ssl

Link do Portainer: $url_portainer

Obrigado por utilizar nosso AutoInstalador.
Caso esse conteudo foi util, não deixe de apoiar nosso projeto.

pix@oriondesign.art.br

Bebam água!
EOL

## Volta para /root/
cd
cd

## Ativa a função dados para pegar os dados da vps
dados

## Mensagem de Passo
echo -e "\e[97m• ATUALIZANDO E CONFIGURANDO A VPS \e[33m[2/9]\e[0m"
echo ""
sleep 1

## Neste passo vamos estar Atualizando e configurando a vps para conseguir rodar nosso setup

## Todos os passo que estão com "> /dev/null 2>&1" São para não mostrar os logs.

## Fiz isso com o intuito de melhorar a visualização deixando o terminal apenas com os passos pré descritos

## Vou adicionar uma verificação com echo e o passo caso der algum problema para verificar.

sudo apt-get update > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/9 - [ OK ] - Update"
else
    echo "1/9 - [ OFF ] - Update"
fi
sudo apt upgrade -y > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "2/9 - [ OK ] - Upgrade"
else
    echo "2/9 - [ OFF ] - Upgrade"
fi
sudo timedatectl set-timezone America/Sao_Paulo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "3/9 - [ OK ] - Timezone"
else
    echo "3/9 - [ OFF ] - Timezone"
fi
sudo apt-get install -y apt-utils > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "4/9 - [ OK ] - Apt-Utils"
else
    echo "4/9 - [ OFF ] - Apt-Utils"
fi
sudo apt-get update > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "5/9 - [ OK ] - Update"
else
    echo "5/9 - [ OFF ] - Update"
fi
hostnamectl set-hostname $nome_servidor > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "6/9 - [ OK ] - Set Hostname"
else
    echo "6/9 - [ OFF ] - Set Hostname"
fi
sudo sed -i "s/127.0.0.1[[:space:]]localhost/127.0.0.1 $nome_servidor/g" /etc/hosts > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "7/9 - [ OK ] - Adicionando nome do servidor em etc/hosts"
else
    echo "7/9 - [ OFF ] - Adicionando nome do servidor em etc/hosts"
fi
sudo apt-get update > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "8/9 - [ OK ] - Update"
else
    echo "8/9 - [ OFF ] - Update"
fi
sudo apt-get install -y apparmor-utils > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "9/9 - [ OK ] - Apparmor-Utils"
else
    echo "9/9 - [ OFF ] - Apparmor-Utils"
fi
echo ""

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO DOCKER SWARM \e[33m[3/9]\e[0m"
echo ""
sleep 1

telemetria Docker iniciado

## Nesse passo vamos estar instalando docker no modo swarm


#ip=$(curl -s ifconfig.me)
read -r ip _ <<< "$(hostname -I | tr ' ' '\n' | grep -v '^127\.0\.0\.1' | grep -v '^10\.0\.0\.' | tr '\n' ' ')"
if [ $? -eq 0 ]; then
    echo "1/4 - [ OK ] - Pegando IP $ip"
else
    echo "1/4 - [ OFF ] - Pegando IP $ip"
fi

## Tentando instalar Docker com get.docker.com
curl -fsSL https://get.docker.com | bash > /dev/null 2>&1
systemctl enable docker > /dev/null 2>&1
systemctl start docker > /dev/null 2>&1

if docker --version > /dev/null 2>&1; then
    echo "2/4 - [ OK ] - Baixando e Instalando Docker"
else
    #echo "2/4 - [ OFF ] - Falha ao instalar Docker"
    #echo "Tentando instalação manual do Docker..."

    ## Instala dependências
    sudo apt-get install -y ca-certificates curl gnupg lsb-release > /dev/null 2>&1

    ## Adiciona chave GPG
    sudo install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo tee /etc/apt/keyrings/docker.asc > /dev/null
    sudo chmod a+r /etc/apt/keyrings/docker.asc

    ## Adiciona repositório do Docker
    echo \
      "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
      focal stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

    ## Atualiza pacotes
    sudo apt-get update > /dev/null 2>&1

    ## Instala Docker
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin > /dev/null 2>&1
    systemctl enable docker > /dev/null 2>&1
    systemctl start docker > /dev/null 2>&1

    if docker --version > /dev/null 2>&1; then
        echo "2/4 - [ OK ] - Baixando e Instalando Docker"
    else
        echo "2/4 - [ OFF ] - Falha ao instalar Docker"
        exit 1
    fi
fi

sleep 5

## Inicializando Docker Swarm
max_attempts=3
attempt=0

while [ $attempt -le $max_attempts ]; do
    docker swarm init --advertise-addr $ip > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "3/4 - [ OK ] - Iniciando Swarm"
        break
    else
        echo "3/4 - [ OFF ] - Iniciando Swarm"
        echo "Ops, não foi possível iniciar o Swarm, tentativa $attempt de $max_attempts"
        attempt=$((attempt + 1))
        sleep 5
    fi
done

if [ $attempt -gt $max_attempts ]; then
    echo "4/4 - [ FAIL ] - Não foi possível iniciar o Swarm após $max_attempts tentativas..."
    echo "Recomendo formatar a VPS e tentar novamente"
    echo "Lembre-se que o primeiro requisito é estar usando uma VPS Vazia."
    sleep 10
    exit 1
else
    echo "4/4 - [ OK ] - Docker e Swarm configurados com sucesso!"
fi

echo ""

docker.fix > /dev/null 2>&1

telemetria Docker finalizado

## Mensagem de Passo
echo -e "\e[97m• CRIANDO REDE INTERNA \e[33m[4/9]\e[0m"
echo ""
sleep 1

## Neste passo vamos criar a rede interna para utilizar nas demais aplicações

docker network create --driver=overlay $nome_rede_interna > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Rede Interna"
else
    echo "1/1 - [ OFF ] - Rede Interna"
fi
echo ""

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO TRAEFIK \e[33m[5/9]\e[0m"
echo ""
sleep 1

telemetria Traefik iniciado

## Neste passo vamos estar criando a Stack yaml do traefik na pasta /root/
## Isso possibilitará que o usuario consiga edita-lo posteriormente

## Depois vamos instalar o traefik e verificar se esta tudo certo.

## Criando a stack traefik.yaml
cat > traefik.yaml << EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  traefik:
    image: traefik:v3.5.3
    command:
      - "--api.dashboard=true"
      - "--providers.swarm=true"
      - "--providers.docker.endpoint=unix:///var/run/docker.sock"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=$nome_rede_interna" ## Nome da rede interna
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.web.http.redirections.entrypoint.permanent=true"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.transport.respondingTimeouts.idleTimeout=3600"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/etc/traefik/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencryptresolver.acme.email=$email_ssl" ## Email para receber as notificações
      - "--log.level=DEBUG"
      - "--log.format=common"
      - "--log.filePath=/var/log/traefik/traefik.log"
      - "--accesslog=true"
      - "--accesslog.filepath=/var/log/traefik/access-log"

    volumes:
      - "vol_certificates:/etc/traefik/letsencrypt"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host

    deploy:
      placement:
        constraints:
          - node.role == manager
      labels:
        - "traefik.enable=true"
        - "traefik.http.middlewares.redirect-https.redirectscheme.scheme=https"
        - "traefik.http.middlewares.redirect-https.redirectscheme.permanent=true"
        - "traefik.http.routers.http-catchall.rule=Host(\`{host:.+}\`)"
        - "traefik.http.routers.http-catchall.entrypoints=web"
        - "traefik.http.routers.http-catchall.middlewares=redirect-https@docker"
        - "traefik.http.routers.http-catchall.priority=1"

## --------------------------- ORION --------------------------- ##

volumes:
  vol_shared:
    external: true
    name: volume_swarm_shared
  vol_certificates:
    external: true
    name: volume_swarm_certificates

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    attachable: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/2 - [ OK ] - Criando Stack"
else
    echo "1/2 - [ OFF ] - Criando Stack"
    echo "Ops, não foi possivel criar a stack do Traefik"
fi

docker stack deploy --prune --resolve-image always -c traefik.yaml traefik > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "2/2 - [ OK ] - Deploy Stack"
else
    echo "2/2 - [ OFF ] - Deploy Stack"
    echo "Ops, não foi possivel subir o Traefik."
fi

echo ""
## Mensagem de Passo
echo -e "\e[97m• ESPERANDO O TRAEFIK ESTAR ONLINE \e[33m[6/9]\e[0m"
echo ""
sleep 1

## Em teste contra Rate Limit do Docker Hub
pull ghcr.io/traefik/traefik:v3.5.3

docker tag ghcr.io/traefik/traefik:v3.5.3 traefik/traefik:v3.5.3

## Usa o serviço wait_stack "traefik" para verificar se o serviço esta online
wait_stack "traefik"

telemetria Traefik finalizado
## Espera 30 segundos
wait_30_sec
echo ""
## Mensagem de Passo
echo -e "\e[97m• INSTALANDO PORTAINER \e[33m[7/9]\e[0m"
echo ""
sleep 1

telemetria Portainer iniciado

## Neste passo vamos estar criando a Stack yaml do Portainer na pasta /root/
## Isso possibilitará que o usuario consiga edita-lo posteriormente

## Depois vamos instalar o Portainer e verificar se esta tudo certo.

## Criando a stack portainer.yaml
cat > portainer.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  agent:
    image: portainer/agent:latest ## Versão Agent do Portainer

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/volumes:/var/lib/docker/volumes

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      mode: global
      placement:
        constraints: [node.platform.os == linux]

## --------------------------- ORION --------------------------- ##

  portainer:
    image: portainer/portainer-ce:latest ## Versão do Portainer
    command: -H tcp://tasks.agent:9001 --tlsskipverify

    volumes:
      - portainer_data:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints: [node.role == manager]
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.portainer.rule=Host(\`$url_portainer\`)" ## Dominio do Portainer
        - "traefik.http.services.portainer.loadbalancer.server.port=9000"
        - "traefik.http.routers.portainer.tls.certresolver=letsencryptresolver"
        - "traefik.http.routers.portainer.service=portainer"
        - "traefik.docker.network=$nome_rede_interna" ## Nome da rede interna
        - "traefik.http.routers.portainer.entrypoints=websecure"
        - "traefik.http.routers.portainer.priority=1"

## --------------------------- ORION --------------------------- ##

volumes:
  portainer_data:
    external: true
    name: portainer_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    attachable: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/2 - [ OK ] - Criando Stack"
else
    echo "1/2 - [ OFF ] - Criando Stack"
    echo "Ops, não foi possivel criar a stack do Portainer"
fi

docker stack deploy --prune --resolve-image always -c portainer.yaml portainer > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "2/2 - [ OK ] - Deploy Stack"
else
    echo "2/2 - [ OFF ] - Deploy Stack"
    echo "Ops, não foi possivel Subir a stack do Portainer"
fi

echo ""
## Mensagem de Passo
echo -e "\e[97m• ESPERANDO O PORTAINER ESTAR ONLINE \e[33m[8/9]\e[0m"
echo ""
sleep 1

pull portainer/agent:latest portainer/portainer-ce:latest

## Usa o serviço wait_portainer para verificar se o serviço esta online
wait_stack "portainer"

sleep 5

telemetria Portainer finalizado

echo ""
## Mensagem de Passo
echo -e "\e[97m• CRIANDO CONTA NO PORTAINER \e[33m[9/9]\e[0m"
echo ""
sleep 30

## Tenta criar usuário no Portainer até 4 vezes
MAX_RETRIES=4
DELAY=15  # Delay de 15 segundos entre as tentativas
CONTA_CRIADA=false

for i in $(seq 1 $MAX_RETRIES); do
  RESPONSE=$(curl -k -s -X POST "https://$url_portainer/api/users/admin/init" \
    -H "Content-Type: application/json" \
    -d "{\"Username\": \"$user_portainer\", \"Password\": \"$pass_portainer\"}")

  # Verificar se o campo "Username" existe na resposta
  if echo "$RESPONSE" | grep -q "\"Username\":\"$user_portainer\""; then
    echo "1/2 - [ OK ] - Conta de administrador criada com sucesso!"
    CONTA_CRIADA=true
    break
  else
    echo "Tentando criar conta no Portainer $i/4."
    # Se for a última tentativa, exibe mensagem de erro final
    if [ $i -eq $MAX_RETRIES ]; then
      echo "1/2 - [ OFF ] - Não foi possível criar a conta de administrador após $MAX_RETRIES tentativas."
      echo "Erro retornado: $RESPONSE"
      echo -e "\e[33mApós a conclusão da instalação, por favor, crie uma conta acessando o link do seu Portainer"
      CONTA_CRIADA=false
      sleep 10
    fi
    sleep $DELAY
  fi
done

# Só tenta criar o token se a conta foi criada com sucesso
if [ "$CONTA_CRIADA" = true ]; then
  sleep 5
  ## Cria primeiro token do Portainer
  token=$(curl -k -s -X POST "https://$url_portainer/api/auth" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$user_portainer\",\"password\":\"$pass_portainer\"}" | jq -r .jwt)
  
  # Verifica se o token foi gerado com sucesso
  if [ -n "$token" ] && [ "$token" != "null" ]; then
    echo "2/2 - [ OK ] - Gerando primeiro token"
  else
    echo "2/2 - [ OFF ] - Falha ao gerar o token"
    exit 1
  fi
fi

sleep 5
## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

if [ "$CONTA_CRIADA" = true ]; then
  cat > dados_portainer <<EOL
[ PORTAINER ]

Dominio do portainer: https://$url_portainer

Usuario: $user_portainer

Senha: $pass_portainer

Token: $token
EOL
else
  cat > dados_portainer <<EOL
[ PORTAINER ]

Dominio do portainer: https://$url_portainer

Usuario: Precisa criar dentro do portainer

Senha: Precisa criar dentro do portainer
EOL
fi

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PORTAINER ]\e[0m"
echo ""

echo -e "\e[97mDominio do portainer:\e[33m https://$url_portainer\e[0m"
echo ""

if [ "$CONTA_CRIADA" = true ]; then
  echo -e "\e[97mUsuario:\e[33m $user_portainer\e[0m"
  echo ""
  echo -e "\e[97mSenha:\e[33m $pass_portainer\e[0m"
else
  echo -e "\e[97mUsuario:\e[33m Precisa criar dentro do portainer\e[0m"
  echo ""
  echo -e "\e[97mSenha:\e[33m Precisa criar dentro do portainer\e[0m"
  echo ""
  echo -e "\e[97mObservação:\e[33m Você tem menos de 5 minutos para criar uma conta no Portainer, caso\e[0m"
  echo -e "\e[33mexceda esse tempo, você precisara de voltar no menu anterior (digitando: Y)\e[0m"
  echo -e "\e[33me no menu de ferramentas digitar: \e[97mportainer.restart\e[0m"
fi
#echo ""

#echo -e "\e[97mObservação:\e[33m Você tem menos de 5 minutos para criar uma conta no Portainer, caso\e[0m"
#echo -e "\e[33mexceda esse tempo, você precisara de voltar no menu anterior (digitando: Y)\e[0m"
#echo -e "\e[33me no menu de ferramentas digitar: \e[97mportainer.restart\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗ ███████╗████████╗ ██████╗ ██████╗ ███████╗███████╗
## ██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝██╔════╝ ██╔══██╗██╔════╝██╔════╝
## ██████╔╝██║   ██║███████╗   ██║   ██║  ███╗██████╔╝█████╗  ███████╗
## ██╔═══╝ ██║   ██║╚════██║   ██║   ██║   ██║██╔══██╗██╔══╝  ╚════██║
## ██║     ╚██████╔╝███████║   ██║   ╚██████╔╝██║  ██║███████╗███████║
## ╚═╝      ╚═════╝ ╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝

ferramenta_postgres() {

## Ativa a função dados para pegar os dados da vps
dados

telemetria Postgres iniciado

## Gerando uma senha aleatória para o Postgres
senha_postgres=$(openssl rand -hex 16)

## Criando a stack postgres.yaml
cat > postgres.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  postgres:
    image: postgres:14 ## Versão do postgres
    command: >
      postgres
      -c max_connections=500
      -c shared_buffers=512MB
      -c timezone=America/Sao_Paulo

    volumes:
      - postgres_data:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 5432:5432

    environment:
    ## 🔑 Senha do Postgres 
      - POSTGRES_PASSWORD=$senha_postgres

    ## 🌎 Timezone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  postgres_data:
    external: true
    name: postgres_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Postgres"
fi
STACK_NAME="postgres"
stack_editavel #> /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c postgres.yaml postgres > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do Postgres."
#fi

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_postgres <<EOL
[ POSTGRES ]

Host: postgres

Port: 5432

Usuario: postgres

Senha: $senha_postgres
EOL

cd
cd

## Espera 30 segundos
wait_stack "postgres_postgres"

telemetria Postgres finalizado
echo ""
}

## ██████╗  ██████╗ ███████╗████████╗ ██████╗ ██████╗ ███████╗███████╗
## ██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝██╔════╝ ██╔══██╗██╔════╝██╔════╝
## ██████╔╝██║   ██║███████╗   ██║   ██║  ███╗██████╔╝█████╗  ███████╗
## ██╔═══╝ ██║   ██║╚════██║   ██║   ██║   ██║██╔══██╗██╔══╝  ╚════██║
## ██║     ╚██████╔╝███████║   ██║   ╚██████╔╝██║  ██║███████╗███████║
## ╚═╝      ╚═════╝ ╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝
##
## ███████╗███████╗████████╗██╗   ██╗██████╗ 
## ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗
## ███████╗█████╗     ██║   ██║   ██║██████╔╝
## ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝ 
## ███████║███████╗   ██║   ╚██████╔╝██║     
## ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝     
                                          
ferramenta_postgres_setup() {

## Verifica os recursos
recursos 1 1 && continue || return

## Ativa a função dados para pegar os dados da vps
dados

## Limpar o terminal
clear
## Mostrar mensagem de Instalando
instalando_msg

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO POSTGRES \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Postgres iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO POSTGRES \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Gerando uma senha aleatória para o Postgres
senha_postgres=$(openssl rand -hex 16)

## Criando a stack postgres.yaml
cat > postgres${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  postgres${1:+_$1}:
    image: postgres:14 ## Versão do postgres
    command: >
      postgres
      -c max_connections=500
      -c shared_buffers=512MB
      -c timezone=America/Sao_Paulo

    volumes:
      - postgres${1:+_$1}_data:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 5432:5432

    environment:
    ## 🔑 Senha do Postgres 
      - POSTGRES_PASSWORD=$senha_postgres

    ## 🌎 Timezone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  postgres${1:+_$1}_data:
    external: true
    name: postgres${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Postgres"
fi
STACK_NAME="postgres${1:+_$1}"
stack_editavel #> /dev/null 2>&1

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

wait_stack "postgres${1:+_$1}_postgres${1:+_$1}"

telemetria Postgres finalizado

#docker stack deploy --prune --resolve-image always -c postgres.yaml postgres > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do Postgres."
#fi

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_postgres${1:+_$1} <<EOL
[ POSTGRES ]

Host: postgres${1:+_$1}

Port: 5432

Usuario: postgres

Senha: $senha_postgres
EOL

cd
cd

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ POSTGRES ]\e[0m"
echo ""

echo -e "\e[97mHost:\e[33m postgres${1:+_$1}\e[0m"
echo ""

echo -e "\e[97mPorta:\e[33m 5432\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m postgres\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m $senha_postgres\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗     ██╗   ██╗███████╗ ██████╗████████╗ ██████╗ ██████╗ 
## ██╔══██╗██╔════╝     ██║   ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗
## ██████╔╝██║  ███╗    ██║   ██║█████╗  ██║        ██║   ██║   ██║██████╔╝
## ██╔═══╝ ██║   ██║    ╚██╗ ██╔╝██╔══╝  ██║        ██║   ██║   ██║██╔══██╗
## ██║     ╚██████╔╝     ╚████╔╝ ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║
## ╚═╝      ╚═════╝       ╚═══╝  ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
                                                                        

ferramenta_pgvector() {

## Ativa a função dados para pegar os dados da vps
dados

telemetria PgVector iniciado

## Gerando uma senha aleatória para o Postgres
senha_pgvector=$(openssl rand -hex 16)

## Criando a stack pgvector.yaml
cat > pgvector.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  pgvector:
    image: pgvector/pgvector:pg16 ## Versão do PgVector
    command: >
      postgres
      -c max_connections=500
      -c shared_buffers=512MB
      -c timezone=America/Sao_Paulo

    volumes:
      - pgvector:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 5433:5432

    environment:
    ## 🔑 Senha do Postgres 
      - POSTGRES_PASSWORD=$senha_pgvector

    ## 🌎 Timezone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  pgvector:
    external: true
    name: pgvector

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do PgVector"
fi
STACK_NAME="pgvector"
stack_editavel #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do PgVector."
#fi
#docker stack deploy --prune --resolve-image always -c pgvector.yaml pgvector > /dev/null 2>&1

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_pgvector <<EOL
[ PGVECTOR ]

Host: pgvector

Port: 5432

Usuario: postgres

Senha: $senha_pgvector

EOL

cd
cd

## Espera 30 segundos
wait_stack "pgvector_pgvector"
sleep 20

telemetria PgVector finalizado
echo ""
}

## ██████╗  ██████╗     ██╗   ██╗███████╗ ██████╗████████╗ ██████╗ ██████╗ 
## ██╔══██╗██╔════╝     ██║   ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗
## ██████╔╝██║  ███╗    ██║   ██║█████╗  ██║        ██║   ██║   ██║██████╔╝
## ██╔═══╝ ██║   ██║    ╚██╗ ██╔╝██╔══╝  ██║        ██║   ██║   ██║██╔══██╗
## ██║     ╚██████╔╝     ╚████╔╝ ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║
## ╚═╝      ╚═════╝       ╚═══╝  ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
##
## ███████╗███████╗████████╗██╗   ██╗██████╗ 
## ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗
## ███████╗█████╗     ██║   ██║   ██║██████╔╝
## ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝ 
## ███████║███████╗   ██║   ╚██████╔╝██║     
## ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝     

ferramenta_pgvector_setup() {

## Verifica os recursos
recursos 1 1 && continue || return

## Ativa a função dados para pegar os dados da vps
dados

## Limpar o terminal
clear
## Mostrar mensagem de Instalando
instalando_msg

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PGVECTOR \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria PgVector iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO PGVECTOR \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Gerando uma senha aleatória para o Postgres
senha_pgvector=$(openssl rand -hex 16)

## Criando a stack do pgvector.yaml
cat > pgvector${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  pgvector${1:+_$1}:
    image: pgvector/pgvector:pg16 ## Versão do PgVector
    command: >
      postgres
      -c max_connections=500
      -c shared_buffers=512MB
      -c timezone=America/Sao_Paulo

    volumes:
      - pgvector${1:+_$1}:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 5433:5432

    environment:
    ## 🔑 Senha do Postgres 
      - POSTGRES_PASSWORD=$senha_pgvector

    ## 🌎 Timezone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  pgvector${1:+_$1}:
    external: true
    name: pgvector${1:+_$1}

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do PgVector"
fi
STACK_NAME="pgvector${1:+_$1}"
stack_editavel #> /dev/null 2>&1

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

wait_stack "pgvector${1:+_$1}_pgvector${1:+_$1}"

telemetria PgVector finalizado
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do PgVector."
#fi
#docker stack deploy --prune --resolve-image always -c pgvector.yaml pgvector > /dev/null 2>&1

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_pgvector${1:+_$1} <<EOL
[ PGVECTOR ]

Host: pgvector${1:+_$1}

Port: 5432

Usuario: postgres

Senha: $senha_pgvector
EOL

cd
cd

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PGVECTOR ]\e[0m"
echo ""

echo -e "\e[97mHost:\e[33m pgvector${1:+_$1}\e[0m"
echo ""

echo -e "\e[97mPorta:\e[33m 5432\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m postgres\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m $senha_pgvector\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

cd
cd

}

## ██████╗ ███████╗██████╗ ██╗███████╗
## ██╔══██╗██╔════╝██╔══██╗██║██╔════╝
## ██████╔╝█████╗  ██║  ██║██║███████╗
## ██╔══██╗██╔══╝  ██║  ██║██║╚════██║
## ██║  ██║███████╗██████╔╝██║███████║
## ╚═╝  ╚═╝╚══════╝╚═════╝ ╚═╝╚══════╝

ferramenta_redis() {

## Ativa a função dados para pegar os dados da vps
dados

telemetria Redis iniciado

## Criando a stack do redis.yaml
cat > redis.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - redis_data:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  redis_data:
    external: true
    name: redis_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Redis"
fi
STACK_NAME="redis"
stack_editavel #> /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c redis.yaml redis
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do Redis."
#fi

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_redis <<EOL
[ REDIS ]

Dominio do Redis: redis://redis:6379

Usuario: redis

Senha: Não tem
EOL

cd
cd

## Espera 30 segundos
wait_stack "redis_redis"

telemetria Redis finalizado
echo ""
}

## ██████╗ ███████╗██████╗ ██╗███████╗
## ██╔══██╗██╔════╝██╔══██╗██║██╔════╝
## ██████╔╝█████╗  ██║  ██║██║███████╗
## ██╔══██╗██╔══╝  ██║  ██║██║╚════██║
## ██║  ██║███████╗██████╔╝██║███████║
## ╚═╝  ╚═╝╚══════╝╚═════╝ ╚═╝╚══════╝
##
## ███████╗███████╗████████╗██╗   ██╗██████╗ 
## ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗
## ███████╗█████╗     ██║   ██║   ██║██████╔╝
## ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝ 
## ███████║███████╗   ██║   ╚██████╔╝██║     
## ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝     

ferramenta_redis_setup() {

## Verifica os recursos
recursos 1 2 && continue || return
## Ativa a função dados para pegar os dados da vps
dados

## Limpar o terminal
clear
## Mostrar mensagem de Instalando
instalando_msg

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO REDIS \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Redis iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO REDIS \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack do redis.yaml
cat > redis${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  redis${1:+_$1}:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - redis${1:+_$1}_data:/data

    ## Descomente as linhas abaixo para uso externo
    networks:
      - $nome_rede_interna ## Nome da rede interna
      
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  redis${1:+_$1}_data:
    external: true
    name: redis${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Ops, não foi criar a stack do Redis."
fi
sleep 1
STACK_NAME="redis${1:+_$1}"
stack_editavel

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

wait_stack "redis${1:+_$1}_redis${1:+_$1}"

telemetria Redis finalizado

#stack_editavel > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c redis.yaml redis
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do Redis."
#fi

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_redis${1:+_$1} <<EOL
[ REDIS ]

Host: redis${1:+_$1}

Porta: 6379

Senha: Não tem

Usuario: Não tem
EOL

cd
cd

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ REDIS ]\e[0m"
echo ""

echo -e "\e[97mHost:\e[33m redis${1:+_$1}\e[0m"
echo ""

echo -e "\e[97mPorta:\e[33m 6379\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m Não tem\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

cd
cd

}

## ███╗   ███╗██╗   ██╗███████╗ ██████╗ ██╗     
## ████╗ ████║╚██╗ ██╔╝██╔════╝██╔═══██╗██║     
## ██╔████╔██║ ╚████╔╝ ███████╗██║   ██║██║     
## ██║╚██╔╝██║  ╚██╔╝  ╚════██║██║▄▄ ██║██║     
## ██║ ╚═╝ ██║   ██║   ███████║╚██████╔╝███████╗
## ╚═╝     ╚═╝   ╚═╝   ╚══════╝ ╚══▀▀═╝ ╚══════╝

ferramenta_mysql() {

## Ativa a função dados para pegar os dados da vps
dados

telemetria MySQL iniciado

## Gerando uma senha aleatória para o Mysql
senha_mysql=$(openssl rand -hex 16)

## Criando a stack do mysql.yaml
cat > mysql.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  mysql:
    image: percona/percona-server:8.0 ## Versão do MySQL
    command:
      [
        "--character-set-server=utf8mb4",
        "--collation-server=utf8mb4_general_ci",
        "--sql-mode=",
        "--default-authentication-plugin=caching_sha2_password",
        "--max-allowed-packet=512MB",
      ]

    volumes:
      - mysql_data:/var/lib/mysql

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 3306:3306

    environment:
    ## 🔑 Senha do MYSQL
      - MYSQL_ROOT_PASSWORD=$senha_mysql

    ## 🌎 TimeZone
      - TZ=America/Sao_Paulo

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  mysql_data:
    external: true
    name: mysql_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do MySQL"
fi

STACK_NAME="mysql"
stack_editavel #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do Postgres."
#fi

wait_stack "mysql${1:+_$1}_mysql${1:+_$1}"

#docker stack deploy --prune --resolve-image always -c mysql.yaml mysql #> /dev/null 2>&1

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_mysql <<EOL
[ MYSQL ]

Dominio do mysql: mysql

Usuario: root

Senha: $senha_mysql
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

telemetria MySQL finalizado
echo ""
}

## ███╗   ███╗██╗   ██╗███████╗ ██████╗ ██╗     
## ████╗ ████║╚██╗ ██╔╝██╔════╝██╔═══██╗██║     
## ██╔████╔██║ ╚████╔╝ ███████╗██║   ██║██║     
## ██║╚██╔╝██║  ╚██╔╝  ╚════██║██║▄▄ ██║██║     
## ██║ ╚═╝ ██║   ██║   ███████║╚██████╔╝███████╗
## ╚═╝     ╚═╝   ╚═╝   ╚══════╝ ╚══▀▀═╝ ╚══════╝
##
## ███████╗███████╗████████╗██╗   ██╗██████╗ 
## ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗
## ███████╗█████╗     ██║   ██║   ██║██████╔╝
## ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝ 
## ███████║███████╗   ██║   ╚██████╔╝██║     
## ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝     
ferramenta_mysql_setup() {

## Verifica os recursos
recursos 1 1 && continue || return

## Ativa a função dados para pegar os dados da vps
dados

## Limpar o terminal
clear
## Mostrar mensagem de Instalando
instalando_msg

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MYSQL \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria MySQL iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO MYSQL \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Gerando uma senha aleatória para o Mysql
senha_mysql=$(openssl rand -hex 16)

## Criando a stack do mysql.yaml
cat > mysql${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  mysql${1:+_$1}:
    image: percona/percona-server:8.0 ## Versão do MySQL
    command:
      [
        "--character-set-server=utf8mb4",
        "--collation-server=utf8mb4_general_ci",
        "--sql-mode=",
        "--default-authentication-plugin=caching_sha2_password",
        "--max-allowed-packet=512MB",
      ]

    volumes:
      - mysql${1:+_$1}_data:/var/lib/mysql

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 3306:3306

    environment:
    ## 🔑 Senha do MYSQL
      - MYSQL_ROOT_PASSWORD=$senha_mysql

    ## 🌎 TimeZone
      - TZ=America/Sao_Paulo

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  mysql${1:+_$1}_data:
    external: true
    name: mysql${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Ops, não foi criar a stack do Mysql."
fi

STACK_NAME="mysql${1:+_$1}"

stack_editavel

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

wait_stack "mysql${1:+_$1}_mysql${1:+_$1}" > /dev/null 2>&1

telemetria MySQL finalizado
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Ops, não foi possivel subir a stack do Postgres."
#fi

#docker stack deploy --prune --resolve-image always -c mysql.yaml mysql #> /dev/null 2>&1

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_mysql${1:+_$1} <<EOL
[ MYSQL ]

Host: mysql${1:+_$1}

Porta: 3306

Usuario: root

Senha: $senha_mysql
EOL

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ MYSQL ]\e[0m"
echo ""

echo -e "\e[97mHost:\e[33m mysql${1:+_$1}\e[0m"
echo ""

echo -e "\e[97mPorta:\e[33m 3306\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m root\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m $senha_mysql\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗██╗  ██╗ █████╗ ████████╗██╗    ██╗ ██████╗  ██████╗ ████████╗
## ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██║    ██║██╔═══██╗██╔═══██╗╚══██╔══╝
## ██║     ███████║███████║   ██║   ██║ █╗ ██║██║   ██║██║   ██║   ██║   
## ██║     ██╔══██║██╔══██║   ██║   ██║███╗██║██║   ██║██║   ██║   ██║   
## ╚██████╗██║  ██║██║  ██║   ██║   ╚███╔███╔╝╚██████╔╝╚██████╔╝   ██║   
##  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚══╝╚══╝  ╚═════╝  ╚═════╝    ╚═╝   

ferramenta_chatwoot() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_chatwoot

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Chatwoot (ex: chatwoot.oriondesign.art.br): \e[0m" && read -r url_chatwoot
    echo ""
    
    ## Pega o nome do dominio para ser o nome da empresa
    nome_empresa_chatwoot="$nome_servidor"
    
    ## Pergunta o email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_admin_chatwoot
    echo ""

    ## Define o dominio SMTP com o dominio do email
    dominio_smtp_chatwoot=$(echo "$email_admin_chatwoot" | cut -d "@" -f 2)

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_chatwoot
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_chatwoot
    echo ""
    
    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_chatwoot
    echo ""
    
    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_chatwoot
    
    
    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_chatwoot" -eq 465 ]; then
     sobre_ssl=true
    else
     sobre_ssl=false
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_chatwoot
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Chatwoot:\e[97m $url_chatwoot\e[0m"
    echo ""

    ## Informação sobre Nome da Empresa
    echo -e "\e[33mNome da Empresa:\e[97m $nome_empresa_chatwoot\e[0m"
    echo ""

    ## Informação sobre Email de SMTP
    echo -e "\e[33mEmail do SMTP:\e[97m $email_admin_chatwoot\e[0m"
    echo ""

    ## Informação sobre Usuario do SMTP
    echo -e "\e[33mUser do SMTP:\e[97m $user_smtp_chatwoot\e[0m"
    echo ""

    ## Informação sobre Senha de SMTP
    echo -e "\e[33mSenha do SMTP:\e[97m $senha_email_chatwoot\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP:\e[97m $smtp_email_chatwoot\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_chatwoot\e[0m"
    echo ""
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_chatwoot

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO CHATWOOT \e[33m[1/6]\e[0m"
echo ""
sleep 1

telemetria Chatwoot iniciado

## Ativa a função dados para pegar os dados da vps
dados

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO PGVECTOR \e[33m[2/6]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - PgVector já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do PgVector"
    criar_banco_pgvector_da_stack "chatwoot${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "chatwoot${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO CHATWOOT \e[33m[3/6]\e[0m"
echo ""
sleep 1

## Neste passo vamos estar criando a Stack yaml do Chatwoot na pasta /root/
## Isso possibilitará que o usuario consiga edita-lo posteriormente

## Depois vamos instalar o Chatwoot e verificar se esta tudo certo.

## Criando key aleatória
encryption_key=$(openssl rand -hex 16)

## Criando a stack chatwoot.yaml
cat > chatwoot${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  chatwoot${1:+_$1}_app:
    image: chatwoot/chatwoot:latest ## Versão do Chatwoot
    command: >
     sh -c "echo 'Rails.application.config.active_storage.variant_processor = :mini_magick' > /app/config/initializers/active_storage.rb && bundle exec rails db:chatwoot_prepare && bundle exec rails s -p 3000 -b 0.0.0.0"
    entrypoint: docker/entrypoints/rails.sh    

    volumes:
      - chatwoot${1:+_$1}_storage:/app/storage ## Arquivos de conversa
      - chatwoot${1:+_$1}_public:/app/public ## Arquivos de logos
      - chatwoot${1:+_$1}_mailer:/app/app/views/devise/mailer ## Arquivos de email
      - chatwoot${1:+_$1}_mailers:/app/app/views/mailers ## Arquivos de emails

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🏢 Nome da Empresa
      - INSTALLATION_NAME=$nome_empresa_chatwoot

    ## 🔐 Secret key
      - SECRET_KEY_BASE=$encryption_key

    ## 💬 Url Chatwoot
      - FRONTEND_URL=https://$url_chatwoot
      #- CHATWOOT_HUB_URL=https://$url_chatwoot
      - FORCE_SSL=true

    ## 🌍 Idioma/Localização padrão
      - DEFAULT_LOCALE=pt_BR
      - TZ=America/Sao_Paulo

    ## ☁️ Google Cloud - Modifique de acordo com os seus dados
      #- GOOGLE_OAUTH_CLIENT_ID=369777777777-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com
      #- GOOGLE_OAUTH_CLIENT_SECRET=ABCDEF-GHijklmnoPqrstuvwX-yz1234567
      #- GOOGLE_OAUTH_CALLBACK_URL=https://<your-server-domain>/omniauth/google_oauth2/callback

    ## 🔐 Facebook e Instagram
      #- IG_VERIFY_TOKEN=
      #- FB_VERIFY_TOKEN=
      #- FB_APP_SECRET=
      #- FB_APP_ID=

    ## 🧑‍💻 Dados do Redis
      - REDIS_URL=redis://chatwoot${1:+_$1}_redis:6379

    ## 🗄️ Dados do Postgres
      - POSTGRES_HOST=pgvector
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$senha_pgvector ## Senha do postgres
      - POSTGRES_DATABASE=chatwoot${1:+_$1}

    ## 🏠 Armazenamento
      - ACTIVE_STORAGE_SERVICE=local ## use s3_compatible para MinIO
      #- STORAGE_BUCKET_NAME=chatwoot${1:+_$1}
      #- STORAGE_ACCESS_KEY_ID=ACCESS_KEY_MINIO
      #- STORAGE_SECRET_ACCESS_KEY=SECRET_KEY_MINIO
      #- STORAGE_REGION=eu-south
      #- STORAGE_ENDPOINT=https://s3.DOMINIO.COM
      #- STORAGE_FORCE_PATH_STYLE=true

    ## 📧 Dados do SMTP
      - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot> ## Email SMTP
      - SMTP_DOMAIN=$dominio_smtp_chatwoot ## Dominio do email
      - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP
      - SMTP_PORT=$porta_smtp_chatwoot ## Porta SMTP
      - SMTP_SSL=$sobre_ssl ## Se a porta for 465 = true | Se a porta for 587 = false
      - SMTP_USERNAME=$user_smtp_chatwoot ## Usuario SMTP
      - SMTP_PASSWORD=$senha_email_chatwoot ## Senha do SMTP
      - SMTP_AUTHENTICATION=login
      - SMTP_ENABLE_STARTTLS_AUTO=true
      - SMTP_OPENSSL_VERIFY_MODE=peer
      - MAILER_INBOUND_EMAIL_DOMAIN=$email_admin_chatwoot ## Email SMTP

    ## ⚙️ Melhorias
      - SIDEKIQ_CONCURRENCY=10
      - RACK_TIMEOUT_SERVICE_TIMEOUT=0
      - RAILS_MAX_THREADS=5
      - WEB_CONCURRENCY=2
      - ENABLE_RACK_ATTACK=false

    ## ⚡ Outras configurações
      - NODE_ENV=production
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
      - RAILS_LOG_TO_STDOUT=true
      - USE_INBOX_AVATAR_FOR_BOT=true
      - ENABLE_ACCOUNT_SIGNUP=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.chatwoot${1:+_$1}_app.rule=Host(\`$url_chatwoot\`)
        - traefik.http.routers.chatwoot${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.chatwoot${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.chatwoot${1:+_$1}_app.priority=1
        - traefik.http.routers.chatwoot${1:+_$1}_app.service=chatwoot${1:+_$1}_app
        - traefik.http.services.chatwoot${1:+_$1}_app.loadbalancer.server.port=3000
        - traefik.http.services.chatwoot${1:+_$1}_app.loadbalancer.passHostHeader=true
        - traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.routers.chatwoot${1:+_$1}_app.middlewares=sslheader

## --------------------------- ORION --------------------------- ##

  chatwoot${1:+_$1}_sidekiq:
    image: chatwoot/chatwoot:latest ## Versão do Chatwoot
    command: bundle exec sidekiq -C config/sidekiq.yml

    volumes:
      - chatwoot${1:+_$1}_storage:/app/storage ## Arquivos de conversa
      - chatwoot${1:+_$1}_public:/app/public ## Arquivos de logos
      - chatwoot${1:+_$1}_mailer:/app/app/views/devise/mailer ## Arquivos de email
      - chatwoot${1:+_$1}_mailers:/app/app/views/mailers ## Arquivos de emails

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🏢 Nome da Empresa
      - INSTALLATION_NAME=$nome_empresa_chatwoot

    ## 🔐 Secret key
      - SECRET_KEY_BASE=$encryption_key

    ## 💬 Url Chatwoot
      - FRONTEND_URL=https://$url_chatwoot
      #- CHATWOOT_HUB_URL=https://$url_chatwoot
      - FORCE_SSL=true

    ## 🌍 Idioma/Localização padrão
      - DEFAULT_LOCALE=pt_BR
      - TZ=America/Sao_Paulo

    ## ☁️ Google Cloud - Modifique de acordo com os seus dados
      #- GOOGLE_OAUTH_CLIENT_ID=369777777777-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com
      #- GOOGLE_OAUTH_CLIENT_SECRET=ABCDEF-GHijklmnoPqrstuvwX-yz1234567
      #- GOOGLE_OAUTH_CALLBACK_URL=https://<your-server-domain>/omniauth/google_oauth2/callback

    ## 🔐 Facebook e Instagram
      #- IG_VERIFY_TOKEN=
      #- FB_VERIFY_TOKEN=
      #- FB_APP_SECRET=
      #- FB_APP_ID=

    ## 🧑‍💻 Dados do Redis
      - REDIS_URL=redis://chatwoot${1:+_$1}_redis:6379

    ## 🗄️ Dados do Postgres
      - POSTGRES_HOST=pgvector
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$senha_pgvector ## Senha do postgres
      - POSTGRES_DATABASE=chatwoot${1:+_$1}

    ## 🏠 Armazenamento
      - ACTIVE_STORAGE_SERVICE=local ## use s3_compatible para MinIO
      #- STORAGE_BUCKET_NAME=chatwoot${1:+_$1}
      #- STORAGE_ACCESS_KEY_ID=ACCESS_KEY_MINIO
      #- STORAGE_SECRET_ACCESS_KEY=SECRET_KEY_MINIO
      #- STORAGE_REGION=eu-south
      #- STORAGE_ENDPOINT=https://s3.DOMINIO.COM
      #- STORAGE_FORCE_PATH_STYLE=true

    ## 📧 Dados do SMTP
      - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot> ## Email SMTP
      - SMTP_DOMAIN=$dominio_smtp_chatwoot ## Dominio do email
      - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP
      - SMTP_PORT=$porta_smtp_chatwoot ## Porta SMTP
      - SMTP_SSL=$sobre_ssl ## Se a porta for 465 = true | Se a porta for 587 = false
      - SMTP_USERNAME=$user_smtp_chatwoot ## Usuario SMTP
      - SMTP_PASSWORD=$senha_email_chatwoot ## Senha do SMTP
      - SMTP_AUTHENTICATION=login
      - SMTP_ENABLE_STARTTLS_AUTO=true
      - SMTP_OPENSSL_VERIFY_MODE=peer
      - MAILER_INBOUND_EMAIL_DOMAIN=$email_admin_chatwoot ## Email SMTP

    ## ⚙️ Melhorias
      - SIDEKIQ_CONCURRENCY=10
      - RACK_TIMEOUT_SERVICE_TIMEOUT=0
      - RAILS_MAX_THREADS=5
      - WEB_CONCURRENCY=2
      - ENABLE_RACK_ATTACK=false

    ## ⚡ Outras configurações
      - NODE_ENV=production
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
      - RAILS_LOG_TO_STDOUT=true
      - USE_INBOX_AVATAR_FOR_BOT=true
      - ENABLE_ACCOUNT_SIGNUP=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  chatwoot${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - chatwoot${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  chatwoot${1:+_$1}_storage:
    external: true
    name: chatwoot${1:+_$1}_storage
  chatwoot${1:+_$1}_public:
    external: true
    name: chatwoot${1:+_$1}_public
  chatwoot${1:+_$1}_mailer:
    external: true
    name: chatwoot${1:+_$1}_mailer
  chatwoot${1:+_$1}_mailers:
    external: true
    name: chatwoot${1:+_$1}_mailers
  chatwoot${1:+_$1}_redis:
    external: true
    name: chatwoot${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Chatwoot"
fi
STACK_NAME="chatwoot${1:+_$1}"
stack_editavel #> /dev/null 2>&1

#docker stack deploy --prune --resolve-image always -c chatwoot.yaml chatwoot > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Chatwoot"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/6]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest chatwoot/chatwoot:latest

## Usa o serviço wait_chatwoot para verificar se o serviço esta online
wait_stack chatwoot${1:+_$1}_chatwoot${1:+_$1}_redis chatwoot${1:+_$1}_chatwoot${1:+_$1}_app chatwoot${1:+_$1}_chatwoot${1:+_$1}_sidekiq

sleep 30
echo ""
## Mensagem de Passo
echo -e "\e[97m• MIGRANDO BANCO DE DADOS \e[33m[5/6]\e[0m"
echo ""
sleep 7

## Aqui vamos estar migrando o banco de dados usando o comando "bundle exec rails db:chatwoot_prepare"

## Basicamente voce poderia entrar no banco de dados do chatwoot e executar o comando por lá tambem

container_name="chatwoot${1:+_$1}_chatwoot${1:+_$1}_app"

max_wait_time=1200

wait_interval=60

elapsed_time=0

while [ $elapsed_time -lt $max_wait_time ]; do
  CONTAINER_ID=$(docker ps -q --filter "name=$container_name")
  if [ -n "$CONTAINER_ID" ]; then
    break
  fi
  sleep $wait_interval
  elapsed_time=$((elapsed_time + wait_interval))
done

if [ -z "$CONTAINER_ID" ]; then
  echo "O contêiner não foi encontrado após $max_wait_time segundos."
  exit 1
fi

docker exec -it "$CONTAINER_ID" bundle exec rails db:chatwoot_prepare > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/2 - [ OK ] - Executando no container: bundle exec rails db:chatwoot_prepare"
else
    echo "1/2 - [ OFF ] - Executando no container: bundle exec rails db:chatwoot_prepare"
    echo "Não foi possivel migrar o banco de dados"
fi

# Nome base do container (pode variar, por isso usamos grep para achar)
pg_container_name="pgvector_pgvector"

# Tempo máximo de espera (em segundos)
max_wait_time=1200
wait_interval=60
elapsed_time=0

# Aguarda até o container aparecer
while [ $elapsed_time -lt $max_wait_time ]; do
  PG_CONTAINER_ID=$(docker ps -q --filter "name=$pg_container_name")
  if [ -n "$PG_CONTAINER_ID" ]; then
    break
  fi
  sleep $wait_interval
  elapsed_time=$((elapsed_time + wait_interval))
done

if [ -z "$PG_CONTAINER_ID" ]; then
  echo "O contêiner do PostgreSQL não foi encontrado após $max_wait_time segundos."
  exit 1
fi

# Executa os comandos SQL dentro do container
docker exec -i "$PG_CONTAINER_ID" psql -U postgres <<'SQL' > /dev/null 2>&1
ALTER SYSTEM SET timezone = 'UTC';
SET timezone = 'UTC';
ALTER DATABASE chatwoot${1:+_$1} SET timezone TO 'UTC';
SHOW timezone;
SQL

if [ $? -eq 0 ]; then
    echo "2/2 - [ OK ] - Executando no container: timezone configurado para UTC"
else
    echo "2/2 - [ OFF ] - Falha ao configurar timezone no PostgreSQL"
    echo "Verifique se o banco de dados e o usuário 'postgres' estão acessíveis."
fi

echo ""
## Mensagem de Passo
echo -e "\e[97m• ATIVANDO FUNÇÕES DO SUPER ADMIN \e[33m[6/6]\e[0m"
echo ""
sleep 1

##  Aqui vamos alterar um dado no postgres para liberar algumas funções ocultas no painel de super admin
wait_for_pgvector

docker exec -i $CONTAINER_ID psql -U postgres <<EOF > /dev/null 2>&1
\c chatwoot${1:+_$1};
update installation_configs set locked = false;
\q
EOF
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Desbloqueando tabela installation_configs no pgvector"
else
    echo "1/1 - [ OFF ] - Desbloqueando tabela installation_configs no pgvector"
    echo "Não foi possivel liberar as funções do super_admin"
fi

echo ""

telemetria Chatwoot finalizado

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_chatwoot${1:+_$1} <<EOL
[ CHATWOOT ]

Dominio do Chatwoot: https://$url_chatwoot

Usuario: Precisa criar dentro do Chatwoot

Senha: Precisa criar dentro do Chatwoot
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ CHATWOOT ]\e[0m"
echo ""

echo -e "\e[97mDominio:\e[33m https://$url_chatwoot\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m Precisa criar dentro do Chatwoot\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m Precisa criar dentro do Chatwoot\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗     █████╗ ██████╗ ██╗
## ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██║
## █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ███████║██████╔╝██║
## ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ██╔══██║██╔═══╝ ██║
## ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║    ██║  ██║██║     ██║
## ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝     ╚═╝

ferramenta_evolution() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_evolution

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para a Evolution API (ex: api.oriondesign.art.br): \e[0m" && read -r url_evolution
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_evolution
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio da Evolution API:\e[97m $url_evolution\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_evolution

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA EVOLUTION API \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria "Evolution API" "iniciado"

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "evolution${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "evolution${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A EVOLUTION API \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação da Evolution API

## Criando uma Global Key Aleatória
apikeyglobal=$(openssl rand -hex 16)

## Criando a stack evolution.yaml
cat > evolution${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  evolution${1:+_$1}_api:
    image: evoapicloud/evolution-api:latest ## Versão da Evolution API

    volumes:
      - evolution${1:+_$1}_instances:/evolution/instances

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações Gerais
      - SERVER_URL=https://$url_evolution
      - AUTHENTICATION_API_KEY=$apikeyglobal
      - AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true
      - DEL_INSTANCE=false
      - QRCODE_LIMIT=1902
      - LANGUAGE=pt-BR

    ## 📱 Configuração do Cliente
    ## Pegue a versão em: https://web.whatsapp.com/sw.js
      #- CONFIG_SESSION_PHONE_VERSION=2.3000.1028978088
      - CONFIG_SESSION_PHONE_CLIENT=SetupOrion
      - CONFIG_SESSION_PHONE_NAME=Chrome
      
    ## 🗄️ Configuração do Banco de Dados
      - DATABASE_ENABLED=true
      - DATABASE_PROVIDER=postgresql
      - DATABASE_CONNECTION_URI=postgresql://postgres:$senha_postgres@postgres:5432/evolution${1:+_$1}
      - DATABASE_CONNECTION_CLIENT_NAME=evolution${1:+_$1}
      - DATABASE_SAVE_DATA_INSTANCE=true
      - DATABASE_SAVE_DATA_NEW_MESSAGE=true
      - DATABASE_SAVE_MESSAGE_UPDATE=true
      - DATABASE_SAVE_DATA_CONTACTS=true
      - DATABASE_SAVE_DATA_CHATS=true
      - DATABASE_SAVE_DATA_LABELS=true
      - DATABASE_SAVE_DATA_HISTORIC=true

    ## 🤖 Integração com N8N
      - N8N_ENABLED=true

    ## 🤖 Integração com EvoAI
      - EVOAI_ENABLED=true
      
    ## 🤖 Integração com OpenAI
      - OPENAI_ENABLED=true
      
    ## 🌐 Integração com Dify
      - DIFY_ENABLED=true
      
    ## 💬 Integração com Typebot
      - TYPEBOT_ENABLED=true
      - TYPEBOT_API_VERSION=latest
      
    ## 🗣️ Integração com Chatwoot
      - CHATWOOT_ENABLED=true
      - CHATWOOT_MESSAGE_READ=true
      - CHATWOOT_MESSAGE_DELETE=true
      - CHATWOOT_IMPORT_DATABASE_CONNECTION_URI=postgresql://postgres:SENHA_DO_PGVECTOR@pgvector:5432/chatwoot?sslmode=disable
      - CHATWOOT_IMPORT_PLACEHOLDER_MEDIA_MESSAGE=false
      
    ## 🧊 Configuração do Cache
      - CACHE_REDIS_ENABLED=true
      - CACHE_REDIS_URI=redis://evolution${1:+_$1}_redis:6379/1
      - CACHE_REDIS_PREFIX_KEY=evolution
      - CACHE_REDIS_SAVE_INSTANCES=false
      - CACHE_LOCAL_ENABLED=false
      
    ## ☁️ Configuração do S3
      - S3_ENABLED=false
      - S3_ACCESS_KEY=
      - S3_SECRET_KEY=
      - S3_BUCKET=evolution
      - S3_PORT=443
      - S3_ENDPOINT=
      - S3_USE_SSL=true
      #- S3_REGION=eu-south

    ## 💼 Configuração do WhatsApp Business
      - WA_BUSINESS_TOKEN_WEBHOOK=evolution${1:+_$1}
      - WA_BUSINESS_URL=https://graph.facebook.com
      - WA_BUSINESS_VERSION=v23.0
      - WA_BUSINESS_LANGUAGE=pt_BR

    ## 📊 Telemetria
      - TELEMETRY=false
      - TELEMETRY_URL=

    ## 🌐 Configuração do WebSocket
      - WEBSOCKET_ENABLED=false
      - WEBSOCKET_GLOBAL_EVENTS=false

    ## 📨 Configuração do SQS
      - SQS_ENABLED=false
      - SQS_ACCESS_KEY_ID=
      - SQS_SECRET_ACCESS_KEY=
      - SQS_ACCOUNT_ID=
      - SQS_REGION=

    ## 🐇 Configuração do RabbitMQ
      - RABBITMQ_ENABLED=false
      - RABBITMQ_FRAME_MAX=8192
      - RABBITMQ_URI=amqp://USER:PASS@rabbitmq:5672/evolution${1:+_$1}
      - RABBITMQ_EXCHANGE_NAME=evolution
      - RABBITMQ_GLOBAL_ENABLED=false
      - RABBITMQ_EVENTS_APPLICATION_STARTUP=false
      - RABBITMQ_EVENTS_INSTANCE_CREATE=false
      - RABBITMQ_EVENTS_INSTANCE_DELETE=false
      - RABBITMQ_EVENTS_QRCODE_UPDATED=false
      - RABBITMQ_EVENTS_SEND_MESSAGE_UPDATE=false
      - RABBITMQ_EVENTS_MESSAGES_SET=false
      - RABBITMQ_EVENTS_MESSAGES_UPSERT=true
      - RABBITMQ_EVENTS_MESSAGES_EDITED=false
      - RABBITMQ_EVENTS_MESSAGES_UPDATE=false
      - RABBITMQ_EVENTS_MESSAGES_DELETE=false
      - RABBITMQ_EVENTS_SEND_MESSAGE=false
      - RABBITMQ_EVENTS_CONTACTS_SET=false
      - RABBITMQ_EVENTS_CONTACTS_UPSERT=false
      - RABBITMQ_EVENTS_CONTACTS_UPDATE=false
      - RABBITMQ_EVENTS_PRESENCE_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_SET=false
      - RABBITMQ_EVENTS_CHATS_UPSERT=false
      - RABBITMQ_EVENTS_CHATS_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_DELETE=false
      - RABBITMQ_EVENTS_GROUPS_UPSERT=false
      - RABBITMQ_EVENTS_GROUP_UPDATE=false
      - RABBITMQ_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - RABBITMQ_EVENTS_CONNECTION_UPDATE=true
      - RABBITMQ_EVENTS_CALL=false
      - RABBITMQ_EVENTS_TYPEBOT_START=false
      - RABBITMQ_EVENTS_TYPEBOT_CHANGE_STATUS=false

    ## 🌐 Configuração do Webhook
      - WEBHOOK_GLOBAL_ENABLED=false
      - WEBHOOK_GLOBAL_URL=
      - WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS=false
      - WEBHOOK_EVENTS_APPLICATION_STARTUP=false
      - WEBHOOK_EVENTS_QRCODE_UPDATED=false
      - WEBHOOK_EVENTS_MESSAGES_SET=false
      - WEBHOOK_EVENTS_SEND_MESSAGE_UPDATE=false
      - WEBHOOK_EVENTS_MESSAGES_UPSERT=false
      - WEBHOOK_EVENTS_MESSAGES_EDITED=false
      - WEBHOOK_EVENTS_MESSAGES_UPDATE=false
      - WEBHOOK_EVENTS_MESSAGES_DELETE=false
      - WEBHOOK_EVENTS_SEND_MESSAGE=false
      - WEBHOOK_EVENTS_CONTACTS_SET=false
      - WEBHOOK_EVENTS_CONTACTS_UPSERT=false
      - WEBHOOK_EVENTS_CONTACTS_UPDATE=false
      - WEBHOOK_EVENTS_PRESENCE_UPDATE=false
      - WEBHOOK_EVENTS_CHATS_SET=false
      - WEBHOOK_EVENTS_CHATS_UPSERT=false
      - WEBHOOK_EVENTS_CHATS_UPDATE=false
      - WEBHOOK_EVENTS_CHATS_DELETE=false
      - WEBHOOK_EVENTS_GROUPS_UPSERT=false
      - WEBHOOK_EVENTS_GROUPS_UPDATE=false
      - WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - WEBHOOK_EVENTS_CONNECTION_UPDATE=false
      - WEBHOOK_EVENTS_LABELS_EDIT=false
      - WEBHOOK_EVENTS_LABELS_ASSOCIATION=false
      - WEBHOOK_EVENTS_CALL=false
      - WEBHOOK_EVENTS_TYPEBOT_START=false
      - WEBHOOK_EVENTS_TYPEBOT_CHANGE_STATUS=false
      - WEBHOOK_EVENTS_ERRORS=false
      - WEBHOOK_EVENTS_ERRORS_WEBHOOK=
      - WEBHOOK_REQUEST_TIMEOUT_MS=60000
      - WEBHOOK_RETRY_MAX_ATTEMPTS=10
      - WEBHOOK_RETRY_INITIAL_DELAY_SECONDS=5
      - WEBHOOK_RETRY_USE_EXPONENTIAL_BACKOFF=true
      - WEBHOOK_RETRY_MAX_DELAY_SECONDS=300
      - WEBHOOK_RETRY_JITTER_FACTOR=0.2
      - WEBHOOK_RETRY_NON_RETRYABLE_STATUS_CODES=400,401,403,404,422

    ## 🔌 Configuração do Provider
      - PROVIDER_ENABLED=false
      - PROVIDER_HOST=127.0.0.1
      - PROVIDER_PORT=5656
      - PROVIDER_PREFIX=evolution${1:+_$1}

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.evolution${1:+_$1}.rule=Host(\`$url_evolution\`) ## Url da Evolution API
        - traefik.http.routers.evolution${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.evolution${1:+_$1}.priority=1
        - traefik.http.routers.evolution${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evolution${1:+_$1}.service=evolution${1:+_$1}
        - traefik.http.services.evolution${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.services.evolution${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  evolution${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - evolution${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  evolution${1:+_$1}_instances:
    external: true
    name: evolution${1:+_$1}_instances
  evolution${1:+_$1}_redis:
    external: true
    name: evolution${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Evolution API"
fi
STACK_NAME="evolution${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c evolution.yaml evolution > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Evolution API"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest evoapicloud/evolution-api:latest

## Usa o serviço wait_evolution para verificar se o serviço esta online
wait_stack evolution${1:+_$1}_evolution${1:+_$1}_redis evolution${1:+_$1}_evolution${1:+_$1}_api

telemetria "Evolution API" "finalizado"

cd dados_vps

cat > dados_evolution${1:+_$1} <<EOL
[ EVOLUTION API ]

Manager Evolution: https://$url_evolution/manager

BaseUrl: https://$url_evolution

Global API Key: $apikeyglobal
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ EVOLUTION API ]\e[0m"
echo ""

echo -e "\e[97mManager da Evolution:\e[33m https://$url_evolution/manager\e[0m"
echo ""

echo -e "\e[97mBaseUrl:\e[33m https://$url_evolution\e[0m"
echo ""

echo -e "\e[97mGlobal API Key:\e[33m $apikeyglobal\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗     █████╗ ██████╗ ██╗
## ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██╔══██╗██╔══██╗██║
## █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ███████║██████╔╝██║
## ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ██╔══██║██╔═══╝ ██║
## ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║    ██║  ██║██║     ██║
## ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝     ╚═╝
##                                                                                                  
## ██╗     ██╗████████╗███████╗                                                                     
## ██║     ██║╚══██╔══╝██╔════╝                                                                     
## ██║     ██║   ██║   █████╗                                                                       
## ██║     ██║   ██║   ██╔══╝                                                                       
## ███████╗██║   ██║   ███████╗                                                                     
## ╚══════╝╚═╝   ╚═╝   ╚══════╝                                                                     
                                                                                                 
ferramenta_evolution_lite() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_evolution_lite

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para a Evolution API Lite (ex: api.oriondesign.art.br): \e[0m" && read -r url_evolution
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_evolution_lite
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio da Evolution API:\e[97m $url_evolution\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_evolution_lite

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA EVOLUTION API LITE \e[33m[1/4\e[0m"
echo ""
sleep 1

telemetria "Evolution API" "iniciado"

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "evolution${1:+_$1}_lite"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "evolution${1:+_$1}_lite"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A EVOLUTION API \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação da Evolution API

## Criando uma Global Key Aleatória
apikeyglobal=$(openssl rand -hex 16)

## Criando a stack evolution.yaml
cat > evolution${1:+_$1}_lite.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  evolution${1:+_$1}_lite:
    image: atendai/evolution-api-lite:latest ## Versão da Evolution API
    entrypoint: ["/bin/bash", "-c", ". ./Docker/scripts/deploy_database.sh && npm run start:prod" ]

    volumes:
      - evolution${1:+_$1}_lite_instances:/evolution/instances

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações Gerais
      - SERVER_URL=https://$url_evolution
      - AUTHENTICATION_API_KEY=$apikeyglobal
      - AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true
      - DEL_INSTANCE=false
      - QRCODE_LIMIT=1902
      - LANGUAGE=pt-BR
      
    ## 📱 Configuração do Cliente
    ## Pegue a versão em: https://web.whatsapp.com/sw.js
      - CONFIG_SESSION_PHONE_VERSION=2.3000.1025815458
      - CONFIG_SESSION_PHONE_CLIENT=OrionDesign
      - CONFIG_SESSION_PHONE_NAME=Chrome
      
    ## 🗄️ Configuração do Banco de Dados
      - DATABASE_ENABLED=true
      - DATABASE_PROVIDER=postgresql
      - DATABASE_CONNECTION_URI=postgresql://postgres:$senha_postgres@postgres:5432/evolution${1:+_$1}_lite
      - DATABASE_CONNECTION_CLIENT_NAME=evolution${1:+_$1}_lite
      - DATABASE_SAVE_DATA_INSTANCE=true
      - DATABASE_SAVE_DATA_NEW_MESSAGE=true
      - DATABASE_SAVE_MESSAGE_UPDATE=true
      - DATABASE_SAVE_DATA_CONTACTS=true
      - DATABASE_SAVE_DATA_CHATS=true
      - DATABASE_SAVE_DATA_LABELS=true
      - DATABASE_SAVE_DATA_HISTORIC=true
      
    ## 🧊 Configuração do Cache
      - CACHE_REDIS_ENABLED=true
      - CACHE_REDIS_URI=redis://evolution${1:+_$1}_lite_redis:6379/8
      - CACHE_REDIS_PREFIX_KEY=evolution
      - CACHE_REDIS_SAVE_INSTANCES=false
      - CACHE_LOCAL_ENABLED=false
      
    ## ☁️ Configuração do S3
      - S3_ENABLED=false
      - S3_ACCESS_KEY=
      - S3_SECRET_KEY=
      - S3_BUCKET=evolution
      - S3_PORT=443
      - S3_ENDPOINT=
      - S3_USE_SSL=true
      #- S3_REGION=eu-south

    ## 💼 Configuração do WhatsApp Business
      - WA_BUSINESS_TOKEN_WEBHOOK=evolution
      - WA_BUSINESS_URL=https://graph.facebook.com
      - WA_BUSINESS_VERSION=v20.0
      - WA_BUSINESS_LANGUAGE=pt_BR

    ## 📊 Telemetria
      - TELEMETRY=false
      - TELEMETRY_URL=

    ## 🌐 Configuração do WebSocket
      - WEBSOCKET_ENABLED=false
      - WEBSOCKET_GLOBAL_EVENTS=false

    ## 📨 Configuração do SQS
      - SQS_ENABLED=false
      - SQS_ACCESS_KEY_ID=
      - SQS_SECRET_ACCESS_KEY=
      - SQS_ACCOUNT_ID=
      - SQS_REGION=

    ## 🐇 Configuração do RabbitMQ
      - RABBITMQ_ENABLED=false
      - RABBITMQ_URI=amqp://USER:PASS@rabbitmq:5672/evolution${1:+_$1}
      - RABBITMQ_EXCHANGE_NAME=evolution
      - RABBITMQ_GLOBAL_ENABLED=false
      - RABBITMQ_EVENTS_APPLICATION_STARTUP=false
      - RABBITMQ_EVENTS_INSTANCE_CREATE=false
      - RABBITMQ_EVENTS_INSTANCE_DELETE=false
      - RABBITMQ_EVENTS_QRCODE_UPDATED=false
      - RABBITMQ_EVENTS_MESSAGES_SET=false
      - RABBITMQ_EVENTS_MESSAGES_UPSERT=true
      - RABBITMQ_EVENTS_MESSAGES_EDITED=false
      - RABBITMQ_EVENTS_MESSAGES_UPDATE=false
      - RABBITMQ_EVENTS_MESSAGES_DELETE=false
      - RABBITMQ_EVENTS_SEND_MESSAGE=false
      - RABBITMQ_EVENTS_CONTACTS_SET=false
      - RABBITMQ_EVENTS_CONTACTS_UPSERT=false
      - RABBITMQ_EVENTS_CONTACTS_UPDATE=false
      - RABBITMQ_EVENTS_PRESENCE_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_SET=false
      - RABBITMQ_EVENTS_CHATS_UPSERT=false
      - RABBITMQ_EVENTS_CHATS_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_DELETE=false
      - RABBITMQ_EVENTS_GROUPS_UPSERT=false
      - RABBITMQ_EVENTS_GROUP_UPDATE=false
      - RABBITMQ_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - RABBITMQ_EVENTS_CONNECTION_UPDATE=true
      - RABBITMQ_EVENTS_CALL=false
      - RABBITMQ_EVENTS_TYPEBOT_START=false
      - RABBITMQ_EVENTS_TYPEBOT_CHANGE_STATUS=false

    ## 🌐 Configuração do Webhook
      - WEBHOOK_GLOBAL_ENABLED=false
      - WEBHOOK_GLOBAL_URL=
      - WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS=false
      - WEBHOOK_EVENTS_APPLICATION_STARTUP=false
      - WEBHOOK_EVENTS_QRCODE_UPDATED=false
      - WEBHOOK_EVENTS_MESSAGES_SET=false
      - WEBHOOK_EVENTS_MESSAGES_UPSERT=false
      - WEBHOOK_EVENTS_MESSAGES_EDITED=false
      - WEBHOOK_EVENTS_MESSAGES_UPDATE=false
      - WEBHOOK_EVENTS_MESSAGES_DELETE=false
      - WEBHOOK_EVENTS_SEND_MESSAGE=false
      - WEBHOOK_EVENTS_CONTACTS_SET=false
      - WEBHOOK_EVENTS_CONTACTS_UPSERT=false
      - WEBHOOK_EVENTS_CONTACTS_UPDATE=false
      - WEBHOOK_EVENTS_PRESENCE_UPDATE=false
      - WEBHOOK_EVENTS_CHATS_SET=false
      - WEBHOOK_EVENTS_CHATS_UPSERT=false
      - WEBHOOK_EVENTS_CHATS_UPDATE=false
      - WEBHOOK_EVENTS_CHATS_DELETE=false
      - WEBHOOK_EVENTS_GROUPS_UPSERT=false
      - WEBHOOK_EVENTS_GROUPS_UPDATE=false
      - WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - WEBHOOK_EVENTS_CONNECTION_UPDATE=false
      - WEBHOOK_EVENTS_LABELS_EDIT=false
      - WEBHOOK_EVENTS_LABELS_ASSOCIATION=false
      - WEBHOOK_EVENTS_CALL=false
      - WEBHOOK_EVENTS_TYPEBOT_START=false
      - WEBHOOK_EVENTS_TYPEBOT_CHANGE_STATUS=false
      - WEBHOOK_EVENTS_ERRORS=false
      - WEBHOOK_EVENTS_ERRORS_WEBHOOK=

    ## 🔌 Configuração do Provider
      - PROVIDER_ENABLED=false
      - PROVIDER_HOST=127.0.0.1
      - PROVIDER_PORT=5656
      - PROVIDER_PREFIX=evolution${1:+_$1}
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.evolution${1:+_$1}_lite.rule=Host(\`$url_evolution\`) ## Url da Evolution API
        - traefik.http.routers.evolution${1:+_$1}_lite.entrypoints=websecure
        - traefik.http.routers.evolution${1:+_$1}_lite.priority=1
        - traefik.http.routers.evolution${1:+_$1}_lite.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evolution${1:+_$1}_lite.service=evolution${1:+_$1}_lite
        - traefik.http.services.evolution${1:+_$1}_lite.loadbalancer.server.port=8080
        - traefik.http.services.evolution${1:+_$1}_lite.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  evolution${1:+_$1}_lite_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - evolution${1:+_$1}_lite_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  evolution${1:+_$1}_lite_instances:
    external: true
    name: evolution${1:+_$1}_lite_instances
  evolution${1:+_$1}_lite_redis:
    external: true
    name: evolution${1:+_$1}_lite_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Evolution API"
fi
STACK_NAME="evolution${1:+_$1}_lite"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c evolution.yaml evolution > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Evolution API"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest atendai/evolution-api-lite:latest

## Usa o serviço wait_evolution para verificar se o serviço esta online
wait_stack "evolution${1:+_$1}_lite_evolution${1:+_$1}_lite"

telemetria "Evolution API" "finalizado"

cd dados_vps

cat > dados_evolution${1:+_$1}_lite <<EOL
[ EVOLUTION API LITE ]

Manager Evolution: https://$url_evolution/manager

URL: https://$url_evolution

Global API Key: $apikeyglobal
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ EVOLUTION API LITE ]\e[0m"
echo ""

echo -e "\e[97mAPI URL:\e[33m https://$url_evolution\e[0m"
echo ""

echo -e "\e[97mGLOBAL API KEY:\e[33m $apikeyglobal\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}


## ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗    ██╗   ██╗ ██╗
## ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██║   ██║███║
## █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ██║   ██║╚██║
## ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ╚██╗ ██╔╝ ██║
## ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║     ╚████╔╝  ██║
## ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝      ╚═══╝   ╚═╝

ferramenta_evolution_v1() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_evolution

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para a Evolution API (ex: api.oriondesign.art.br): \e[0m" && read -r url_evolution
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_evolution
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio da Evolution API:\e[97m $url_evolution\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_evolution

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA EVOLUTION API \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria "Evolution API (v1)" "iniciado"

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A EVOLUTION API \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Verifica se existe postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    pegar_senha_postgres > /dev/null 2>&1
    senha_do_postgres=$senha_postgres
else
    senha_do_postgres=SENHA_DO_POSTGRES_AQUI
fi

## Aqui de fato vamos iniciar a instalação da Evolution API

## Criando uma Global Key Aleatória
apikeyglobal=$(openssl rand -hex 16)

## Criando a stack
cat > evolution_v1${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  evolution_oriondesign${1:+_$1}:
    image: evoapicloud/evolution-api:v1.8.5 ## Versão da Evolution API
    command: ["node", "./dist/src/main.js"]

    volumes:
      - evolution_oriondesign${1:+_$1}_instances:/evolution/instances
      - evolution_oriondesign${1:+_$1}_store:/evolution/store
      - evolution_oriondesign${1:+_$1}_views:/evolution/views

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Url da Evolution API
      - SERVER_URL=https://$url_evolution ## Url da aplicação

    ## 🔐 Dados de Autenticação
      - AUTHENTICATION_TYPE=apikey
      - AUTHENTICATION_API_KEY=$apikeyglobal ## GLOBAL API KEY
      - AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true

    ## ⚙️ Configurações
      - CONFIG_SESSION_PHONE_CLIENT=OrionDesign ## Nome que aparece no celular
      - CONFIG_SESSION_PHONE_NAME=chrome

    ## 📱 Definir versão do Whatsapp Web
    ## pegue a versão em: https://web.whatsapp.com/check-update?version=0&platform=web
      - CONFIG_SESSION_PHONE_VERSION=2,3000,1015901307

    ## 🖼️ Sobre os QR-Codes
      - QRCODE_LIMIT=1902
      - QRCODE_COLOR=#000000

    ## 🐰 Ativar o RabbitMQ
      - RABBITMQ_ENABLED=false ## Colocar true se quiser usar | Recomendado | Necessário instalar RabbitMQ antes
      - RABBITMQ_URI=amqp://USER:PASS@rabbitmq:5672

    ## 🗄️ Ativar Banco de Dados MongoDB
      - DATABASE_ENABLED=false ## Colocar true se quiser usar | Necessário instalar MongoDB antes
      - DATABASE_CONNECTION_URI=mongodb://USUARIO:SENHA@IP_VPS:27017/?authSource=admin&readPreference=primary&ssl=false&directConnection=true ## Colocar a URL do MongoDB
      - DATABASE_CONNECTION_DB_PREFIX_NAME=evolution${1:+_$1}
      - DATABASE_SAVE_DATA_INSTANCE=true
      - DATABASE_SAVE_DATA_NEW_MESSAGE=true
      - DATABASE_SAVE_MESSAGE_UPDATE=true
      - DATABASE_SAVE_DATA_CONTACTS=true
      - DATABASE_SAVE_DATA_CHATS=true

    ## 🧑‍💻 Ativar o Redis
      - REDIS_ENABLED=false ## Colocar true se quiser usar | Não recomendado
      - REDIS_URI=redis://redis:6379

    ## 💾 Ativar o Cache Redis (Em testes)
      - CACHE_REDIS_ENABLED=false
      - CACHE_REDIS_URI=redis://redis:6379
      - CACHE_REDIS_PREFIX_KEY=evolution${1:+_$1}
      - CACHE_REDIS_TTL=604800
      - CACHE_REDIS_SAVE_INSTANCES=false
      - CACHE_LOCAL_ENABLED=false
      - CACHE_LOCAL_TTL=604800

    ## 🤖 Novas variáveis para o Typebot
      - TYPEBOT_KEEP_OPEN=true
      - TYPEBOT_API_VERSION=latest

    ## 💬 Novas variáveis para o Chatwoot
      - CHATWOOT_MESSAGE_DELETE=true
      - CHATWOOT_MESSAGE_READ=true

    ## 📨 Importar mensagens para o Chatwoot | Descomente para usar
    ## Se estiver usando Chatwoot do Nestor mude o a parte "chatwoot" para "chatwoot_nestor"
      #- CHATWOOT_IMPORT_DATABASE_CONNECTION_URI=postgresql://postgres:$senha_do_postgres@postgres:5432/chatwoot?sslmode=disable
      #- CHATWOOT_IMPORT_DATABASE_PLACEHOLDER_MEDIA_MESSAGE=false ## true = Importar mídia | false = Não importar mídia 

    ## 🔔 Informações do Webhook
      - WEBHOOK_GLOBAL_ENABLED=false
      - WEBHOOK_GLOBAL_URL=
      - WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS=false
      - WEBHOOK_EVENTS_APPLICATION_STARTUP=false
      - WEBHOOK_EVENTS_QRCODE_UPDATED=true
      - WEBHOOK_EVENTS_MESSAGES_SET=false
      - WEBHOOK_EVENTS_MESSAGES_UPSERT=true
      - WEBHOOK_EVENTS_MESSAGES_UPDATE=true
      - WEBHOOK_EVENTS_CONTACTS_SET=true
      - WEBHOOK_EVENTS_CONTACTS_UPSERT=true
      - WEBHOOK_EVENTS_CONTACTS_UPDATE=true
      - WEBHOOK_EVENTS_PRESENCE_UPDATE=true
      - WEBHOOK_EVENTS_CHATS_SET=true
      - WEBHOOK_EVENTS_CHATS_UPSERT=true
      - WEBHOOK_EVENTS_CHATS_UPDATE=true
      - WEBHOOK_EVENTS_CHATS_DELETE=true
      - WEBHOOK_EVENTS_GROUPS_UPSERT=true
      - WEBHOOK_EVENTS_GROUPS_UPDATE=true
      - WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE=true
      - WEBHOOK_EVENTS_CONNECTION_UPDATE=true

    ## ⚙️ Sobre as instâncias
      - DEL_INSTANCE=false
      - DEL_TEMP_INSTANCES=false
      - STORE_MESSAGES=true
      - STORE_MESSAGE_UP=true
      - STORE_CONTACTS=true
      - STORE_CHATS=true
      - CLEAN_STORE_CLEANING_INTERVAL=7200 # seconds === 2h
      - CLEAN_STORE_MESSAGES=true
      - CLEAN_STORE_MESSAGE_UP=true
      - CLEAN_STORE_CONTACTS=true
      - CLEAN_STORE_CHATS=true

    ## 🗃️ Outros dados
      - DOCKER_ENV=true
      - LOG_LEVEL=ERROR

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.evolution_oriondesign${1:+_$1}.rule=Host(\`$url_evolution\`) ## Url da Evolution API
        - traefik.http.routers.evolution_oriondesign${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.evolution_oriondesign${1:+_$1}.priority=1
        - traefik.http.routers.evolution_oriondesign${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evolution_oriondesign${1:+_$1}.service=evolution_oriondesign${1:+_$1}
        - traefik.http.services.evolution_oriondesign${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.services.evolution_oriondesign${1:+_$1}.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

volumes:
  evolution_oriondesign${1:+_$1}_instances:
    external: true
    name: evolution_oriondesign${1:+_$1}_instances
  evolution_oriondesign${1:+_$1}_store:
    external: true
    name: evolution_oriondesign${1:+_$1}_store
  evolution_oriondesign${1:+_$1}_views:
    external: true
    name: evolution_oriondesign${1:+_$1}_views
networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Evolution API"
fi
STACK_NAME="evolution_v1${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c evolution_v1.yaml evolution > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Evolution API"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

pull evoapicloud/evolution-api:v1.8.5

## Usa o serviço wait_evolution para verificar se o serviço esta online
wait_stack "evolution_v1${1:+_$1}_evolution_oriondesign${1:+_$1}"

telemetria "Evolution API (v1)" "finalizado"

cd dados_vps

cat > dados_evolution_v1${1:+_$1} <<EOL
[ EVOLUTION API ]

Manager Evolution: https://$url_evolution/manager

URL: https://$url_evolution

Global API Key: $apikeyglobal
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ Evolution API ]\e[0m"
echo ""

echo -e "\e[97mLink do Manager:\e[33m https://$url_evolution/manager\e[0m"
echo ""

echo -e "\e[97mAPI URL:\e[33m https://$url_evolution\e[0m"
echo ""

echo -e "\e[97mGLOBAL API KEY:\e[33m $apikeyglobal\e[0m"
echo ""

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗    ██╗   ██╗██████╗ 
## ██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║    ██║   ██║╚════██╗
## █████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║    ██║   ██║ █████╔╝
## ██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║    ╚██╗ ██╔╝██╔═══╝ 
## ███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║     ╚████╔╝ ███████╗
## ╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝      ╚═══╝  ╚══════╝

ferramenta_evolution_v2() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_evolution

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para a Evolution API (ex: api.oriondesign.art.br): \e[0m" && read -r url_evolution
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_evolution
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio da Evolution API:\e[97m $url_evolution\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_evolution

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA EVOLUTION API \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria "Evolution API" "iniciado"

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "evolution${1:+_$1}_v2"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "evolution${1:+_$1}_v2"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A EVOLUTION API \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação da Evolution API

## Criando uma Global Key Aleatória
apikeyglobal=$(openssl rand -hex 16)

## Criando a stack
cat > evolution_v2${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  evolution${1:+_$1}:
    image: atendai/evolution-api:v2.1.2 ## Versão da Evolution API

    volumes:
      - evolution${1:+_$1}_instances:/evolution/instances

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações Gerais
      - SERVER_URL=https://$url_evolution
      - AUTHENTICATION_API_KEY=$apikeyglobal
      - AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true
      - DEL_INSTANCE=false
      - QRCODE_LIMIT=1902
      - LANGUAGE=pt-BR
      
    ## 📱 Configuração do Cliente
    ## Pegue a versão em: https://web.whatsapp.com/sw.js
      #- CONFIG_SESSION_PHONE_VERSION=2.3000.1029193574
      - CONFIG_SESSION_PHONE_CLIENT=OrionDesign
      - CONFIG_SESSION_PHONE_NAME=Chrome
      
    ## 🗄️ Configuração do Banco de Dados
      - DATABASE_ENABLED=true
      - DATABASE_PROVIDER=postgresql
      - DATABASE_CONNECTION_URI=postgresql://postgres:$senha_postgres@postgres:5432/evolution${1:+_$1}_v2
      - DATABASE_CONNECTION_CLIENT_NAME=evolution${1:+_$1}_v2
      - DATABASE_SAVE_DATA_INSTANCE=true
      - DATABASE_SAVE_DATA_NEW_MESSAGE=true
      - DATABASE_SAVE_MESSAGE_UPDATE=true
      - DATABASE_SAVE_DATA_CONTACTS=true
      - DATABASE_SAVE_DATA_CHATS=true
      - DATABASE_SAVE_DATA_LABELS=true
      - DATABASE_SAVE_DATA_HISTORIC=true

    ## 🤖 Integração com N8N
      - N8N_ENABLED=true

    ## 🤖 Integração com EvoAI
      - EVOAI_ENABLED=true
      
    ## 🤖 Integração com OpenAI
      - OPENAI_ENABLED=true
      
    ## 🌐 Integração com Dify
      - DIFY_ENABLED=true
      
    ## 💬 Integração com Typebot
      - TYPEBOT_ENABLED=true
      - TYPEBOT_API_VERSION=latest
      
    ## 🗣️ Integração com Chatwoot
      - CHATWOOT_ENABLED=true
      - CHATWOOT_MESSAGE_READ=true
      - CHATWOOT_MESSAGE_DELETE=true
      - CHATWOOT_IMPORT_DATABASE_CONNECTION_URI=postgresql://postgres:SENHA_DO_PGVECTOR@pgvector:5432/chatwoot?sslmode=disable
      - CHATWOOT_IMPORT_PLACEHOLDER_MEDIA_MESSAGE=false
      
    ## 🧊 Configuração do Cache
      - CACHE_REDIS_ENABLED=true
      - CACHE_REDIS_URI=redis://evolution${1:+_$1}_v2_redis:6379/1
      - CACHE_REDIS_PREFIX_KEY=evolution
      - CACHE_REDIS_SAVE_INSTANCES=false
      - CACHE_LOCAL_ENABLED=false
      
    ## ☁️ Configuração do S3
      - S3_ENABLED=false
      - S3_ACCESS_KEY=
      - S3_SECRET_KEY=
      - S3_BUCKET=evolution
      - S3_PORT=443
      - S3_ENDPOINT=
      - S3_USE_SSL=true
      #- S3_REGION=eu-south

    ## 💼 Configuração do WhatsApp Business
      - WA_BUSINESS_TOKEN_WEBHOOK=evolution${1:+_$1}
      - WA_BUSINESS_URL=https://graph.facebook.com
      - WA_BUSINESS_VERSION=v23.0
      - WA_BUSINESS_LANGUAGE=pt_BR

    ## 📊 Telemetria
      - TELEMETRY=false
      - TELEMETRY_URL=

    ## 🌐 Configuração do WebSocket
      - WEBSOCKET_ENABLED=false
      - WEBSOCKET_GLOBAL_EVENTS=false

    ## 📨 Configuração do SQS
      - SQS_ENABLED=false
      - SQS_ACCESS_KEY_ID=
      - SQS_SECRET_ACCESS_KEY=
      - SQS_ACCOUNT_ID=
      - SQS_REGION=

    ## 🐇 Configuração do RabbitMQ
      - RABBITMQ_ENABLED=false
      - RABBITMQ_FRAME_MAX=8192
      - RABBITMQ_URI=amqp://USER:PASS@rabbitmq:5672/evolution${1:+_$1}
      - RABBITMQ_EXCHANGE_NAME=evolution
      - RABBITMQ_GLOBAL_ENABLED=false
      - RABBITMQ_EVENTS_APPLICATION_STARTUP=false
      - RABBITMQ_EVENTS_INSTANCE_CREATE=false
      - RABBITMQ_EVENTS_INSTANCE_DELETE=false
      - RABBITMQ_EVENTS_QRCODE_UPDATED=false
      - RABBITMQ_EVENTS_SEND_MESSAGE_UPDATE=false
      - RABBITMQ_EVENTS_MESSAGES_SET=false
      - RABBITMQ_EVENTS_MESSAGES_UPSERT=true
      - RABBITMQ_EVENTS_MESSAGES_EDITED=false
      - RABBITMQ_EVENTS_MESSAGES_UPDATE=false
      - RABBITMQ_EVENTS_MESSAGES_DELETE=false
      - RABBITMQ_EVENTS_SEND_MESSAGE=false
      - RABBITMQ_EVENTS_CONTACTS_SET=false
      - RABBITMQ_EVENTS_CONTACTS_UPSERT=false
      - RABBITMQ_EVENTS_CONTACTS_UPDATE=false
      - RABBITMQ_EVENTS_PRESENCE_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_SET=false
      - RABBITMQ_EVENTS_CHATS_UPSERT=false
      - RABBITMQ_EVENTS_CHATS_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_DELETE=false
      - RABBITMQ_EVENTS_GROUPS_UPSERT=false
      - RABBITMQ_EVENTS_GROUP_UPDATE=false
      - RABBITMQ_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - RABBITMQ_EVENTS_CONNECTION_UPDATE=true
      - RABBITMQ_EVENTS_CALL=false
      - RABBITMQ_EVENTS_TYPEBOT_START=false
      - RABBITMQ_EVENTS_TYPEBOT_CHANGE_STATUS=false

    ## 🌐 Configuração do Webhook
      - WEBHOOK_GLOBAL_ENABLED=false
      - WEBHOOK_GLOBAL_URL=
      - WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS=false
      - WEBHOOK_EVENTS_APPLICATION_STARTUP=false
      - WEBHOOK_EVENTS_QRCODE_UPDATED=false
      - WEBHOOK_EVENTS_MESSAGES_SET=false
      - WEBHOOK_EVENTS_SEND_MESSAGE_UPDATE=false
      - WEBHOOK_EVENTS_MESSAGES_UPSERT=false
      - WEBHOOK_EVENTS_MESSAGES_EDITED=false
      - WEBHOOK_EVENTS_MESSAGES_UPDATE=false
      - WEBHOOK_EVENTS_MESSAGES_DELETE=false
      - WEBHOOK_EVENTS_SEND_MESSAGE=false
      - WEBHOOK_EVENTS_CONTACTS_SET=false
      - WEBHOOK_EVENTS_CONTACTS_UPSERT=false
      - WEBHOOK_EVENTS_CONTACTS_UPDATE=false
      - WEBHOOK_EVENTS_PRESENCE_UPDATE=false
      - WEBHOOK_EVENTS_CHATS_SET=false
      - WEBHOOK_EVENTS_CHATS_UPSERT=false
      - WEBHOOK_EVENTS_CHATS_UPDATE=false
      - WEBHOOK_EVENTS_CHATS_DELETE=false
      - WEBHOOK_EVENTS_GROUPS_UPSERT=false
      - WEBHOOK_EVENTS_GROUPS_UPDATE=false
      - WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - WEBHOOK_EVENTS_CONNECTION_UPDATE=false
      - WEBHOOK_EVENTS_LABELS_EDIT=false
      - WEBHOOK_EVENTS_LABELS_ASSOCIATION=false
      - WEBHOOK_EVENTS_CALL=false
      - WEBHOOK_EVENTS_TYPEBOT_START=false
      - WEBHOOK_EVENTS_TYPEBOT_CHANGE_STATUS=false
      - WEBHOOK_EVENTS_ERRORS=false
      - WEBHOOK_EVENTS_ERRORS_WEBHOOK=
      - WEBHOOK_REQUEST_TIMEOUT_MS=60000
      - WEBHOOK_RETRY_MAX_ATTEMPTS=10
      - WEBHOOK_RETRY_INITIAL_DELAY_SECONDS=5
      - WEBHOOK_RETRY_USE_EXPONENTIAL_BACKOFF=true
      - WEBHOOK_RETRY_MAX_DELAY_SECONDS=300
      - WEBHOOK_RETRY_JITTER_FACTOR=0.2
      - WEBHOOK_RETRY_NON_RETRYABLE_STATUS_CODES=400,401,403,404,422

    ## 🔌 Configuração do Provider
      - PROVIDER_ENABLED=false
      - PROVIDER_HOST=127.0.0.1
      - PROVIDER_PORT=5656
      - PROVIDER_PREFIX=evolution${1:+_$1}
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.evolution_v2${1:+_$1}.rule=Host(\`$url_evolution\`) ## Url da Evolution API
        - traefik.http.routers.evolution_v2${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.evolution_v2${1:+_$1}.priority=1
        - traefik.http.routers.evolution_v2${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evolution_v2${1:+_$1}.service=evolution_v2${1:+_$1}
        - traefik.http.services.evolution_v2${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.services.evolution_v2${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  evolution${1:+_$1}_v2_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - evolution${1:+_$1}_v2_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  evolution${1:+_$1}_instances:
    external: true
    name: evolution${1:+_$1}_instances
  evolution${1:+_$1}_v2_redis:
    external: true
    name: evolution${1:+_$1}_v2_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Evolution API"
fi
STACK_NAME="evolution_v2${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c evolution_v2.yaml evolution > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Evolution API"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Usa o serviço wait_evolution para verificar se o serviço esta online
wait_stack "evolution_v2${1:+_$1}"

telemetria "Evolution API" "finalizado"

cd dados_vps

cat > dados_evolution_v2${1:+_$1} <<EOL
[ EVOLUTION API ]

Manager Evolution: https://$url_evolution/manager

BaseUrl: https://$url_evolution

Global API Key: $apikeyglobal
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ EVOLUTION API ]\e[0m"
echo ""

echo -e "\e[97mLink do Manager:\e[33m https://$url_evolution/manager\e[0m"
echo ""

echo -e "\e[97mBaseUrl:\e[33m https://$url_evolution\e[0m"
echo ""

echo -e "\e[97mGlobal API Key:\e[33m $apikeyglobal\e[0m"
echo ""

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ███╗██╗███╗   ██╗██╗ ██████╗ 
## ████╗ ████║██║████╗  ██║██║██╔═══██╗
## ██╔████╔██║██║██╔██╗ ██║██║██║   ██║
## ██║╚██╔╝██║██║██║╚██╗██║██║██║   ██║
## ██║ ╚═╝ ██║██║██║ ╚████║██║╚██████╔╝
## ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝ ╚═════╝ 

ferramenta_minio() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_minio

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do
    
    ##Pergunta o Dominio do Minio
    echo -e "\e[97mPasso$amarelo 1/5\e[0m"
    echo -en "\e[33mDigite o Dominio para o Painel do MinIO (ex: minio.oriondesign.art.br): \e[0m" && read -r url_minio
    echo ""
    
    ##Pergunta o Dominio para o S3 do Minio
    echo -e "\e[97mPasso$amarelo 2/5\e[0m"
    echo -en "\e[33mDigite o Dominio para a API S3 do Minio(ex: s3.oriondesign.art.br): \e[0m" && read -r url_s3
    echo ""
    
    ##Pergunta o Usuario para o Minio
    echo -e "\e[97mPasso$amarelo 3/5\e[0m"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$ e/ou espaço"
    echo -en "\e[33mDigite um usuario para o MinIO (ex: OrionDesign): \e[0m" && read -r user_minio
    echo ""
    
    ##Pergunta a Senha para o Minio
    echo -e "\e[97mPasso$amarelo 4/5\e[0m"
    echo -e "$amarelo--> Minimo 8 caracteres. Use Letras MAIUSCULAS e minusculas, numero e um caractere especial @ ou _"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma senha para o MinIO (ex: @Senha123_): \e[0m" && read -r senha_minio
    echo ""

    ##Pergunta a Senha para o Minio
    echo -e "\e[97mPasso$amarelo 5/5\e[0m"
    echo -e "$amarelo--> 1 = Ultima Versão"
    echo -e "$amarelo--> 2 = Versão Antiga"
    echo -en "\e[33mDigite o numero da versão que deseja instalar (1 ou 2): \e[0m" && read -r minio_version_op
    echo ""
    if [ "$minio_version_op" = "1" ]; then
        minio_version="latest"
    elif [ "$minio_version_op" = "2" ]; then
        minio_version="RELEASE.2024-01-13T07-53-03Z-cpuv1"
    else
        echo -e "\e[31mOpção inválida. Usando versão 'latest' por padrão.\e[0m"
        minio_version="latest"
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_minio
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Minio 
    echo -e "\e[33mDominio do Painel do MinIO:\e[97m $url_minio\e[0m"
    echo ""
    
    ## Informação sobre URL para o S# do Minio 
    echo -e "\e[33mDominio da API S3:\e[97m $url_s3\e[0m"
    echo ""
    
    ## Informação sobre Usuario do Minio
    echo -e "\e[33mUsuario do MinIO:\e[97m $user_minio\e[0m"
    echo ""    
    
    ## Informação sobre Senha do Minio
    echo -e "\e[33mSenha do MinIO:\e[97m $senha_minio\e[0m"
    echo ""

    ## Informação sobre Senha do Minio
    echo -e "\e[33mVersão do MinIO:\e[97m $minio_version\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MINIO \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria MinIO iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO MINIO \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack minio.yaml
cat > minio${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  minio${1:+_$1}:
    image: quay.io/minio/minio:$minio_version ## Versão do MinIO
    command: server /data --console-address ":9001"

    volumes:
      - minio${1:+_$1}_data:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔑 Dados de acesso
      - MINIO_ROOT_USER=$user_minio
      - MINIO_ROOT_PASSWORD=$senha_minio

    ## 🌐 URL do MinIO
      - MINIO_BROWSER_REDIRECT_URL=https://$url_minio ## Url do minio
      - MINIO_SERVER_URL=https://$url_s3 ## Url do s3 | Comente esta linha caso tiver erro ao fazer login

    ## 📍 Região
      - MINIO_REGION_NAME=eu-south

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        ## Console
        - traefik.http.routers.minio_public${1:+_$1}.rule=Host(\`$url_s3\`) ## Url do s3
        - traefik.http.routers.minio_public${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.minio_public${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.minio_public${1:+_$1}.loadbalancer.server.port=9000
        - traefik.http.services.minio_public${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.routers.minio_public${1:+_$1}.service=minio_public${1:+_$1}
        ## API S3
        - traefik.http.routers.minio_console${1:+_$1}.rule=Host(\`$url_minio\`) ## Url do minio
        - traefik.http.routers.minio_console${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.minio_console${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.minio_console${1:+_$1}.loadbalancer.server.port=9001
        - traefik.http.services.minio_console${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.routers.minio_console${1:+_$1}.service=minio_console${1:+_$1}

## --------------------------- ORION --------------------------- ##

volumes:
  minio${1:+_$1}_data:
    external: true
    name: minio${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do MinIO"
fi
sleep 1
STACK_NAME="minio${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c minio.yaml minio

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Minio"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull quay.io/minio/minio:$minio_version

## Usa o serviço wait_minio para verificar se o serviço esta online
wait_stack minio${1:+_$1}_minio${1:+_$1}

telemetria MinIO finalizado

cd dados_vps

cat > dados_minio${1:+_$1} <<EOL
[ MINIO ]

Dominio do painel do Minio: https://$url_minio

Dominio da API S3: https://$url_s3

Usuario: $user_minio

Senha: $senha_minio

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ MINIO ]\e[0m"
echo ""

echo -e "\e[33mDominio do Painel do MinIO:\e[97m https://$url_minio\e[0m"
echo ""

echo -e "\e[33mDominio da API S3:\e[97m https://$url_s3\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_minio\e[0m"
echo ""  

echo -e "\e[33mSenha:\e[97m $senha_minio\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}


## ████████╗██╗   ██╗██████╗ ███████╗██████╗  ██████╗ ████████╗
## ╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗╚══██╔══╝
##    ██║    ╚████╔╝ ██████╔╝█████╗  ██████╔╝██║   ██║   ██║   
##    ██║     ╚██╔╝  ██╔═══╝ ██╔══╝  ██╔══██╗██║   ██║   ██║   
##    ██║      ██║   ██║     ███████╗██████╔╝╚██████╔╝   ██║   
##    ╚═╝      ╚═╝   ╚═╝     ╚══════╝╚═════╝  ╚═════╝    ╚═╝   

ferramenta_typebot() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_typebot

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do Builder
    echo -e "\e[97mPasso$amarelo 1/7\e[0m"
    echo -en "\e[33mDigite o Dominio para o Builder do Typebot (ex: typebot.oriondesign.art.br): \e[0m" && read -r url_typebot
    echo ""

    ##Pergunta o Dominio do Viewer
    echo -e "\e[97mPasso$amarelo 2/7\e[0m"
    echo -en "\e[33mDigite o Dominio para o Viewer do Typebot (ex: viewer.oriondesign.art.br): \e[0m" && read -r url_viewer
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 3/7\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_typebot
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 4/7\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_email_typebot
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 5/7\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_typebot
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 6/7\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_typebot
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 7/7\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_typebot
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_typebot" -eq 465 ]; then
    smtp_secure_typebot=true
    else
    smtp_secure_typebot=false
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_typebot
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Builder
    echo -e "\e[33mDominio do Typebot Builder:\e[97m $url_typebot\e[0m"
    echo ""

    ## Informação sobre URL do Viewer
    echo -e "\e[33mDominio do Typebot Viewer:\e[97m $url_viewer\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mEmail do SMTP:\e[97m $email_typebot\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mUsuário do SMTP:\e[97m $usuario_email_typebot\e[0m"
    echo ""

    ## Informação sobre Senha do Email
    echo -e "\e[33mSenha do Email:\e[97m $senha_email_typebot\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP do Email:\e[97m $smtp_email_typebot\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_typebot\e[0m"
    echo ""

    ## Informação sobre Secure SMTP
    echo -e "\e[33mSecure SMTP do Email:\e[97m $smtp_secure_typebot\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_typebot

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO TYPEBOT \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria Typebot iniciado

## Nada nada nada.. só para aparecer a mensagem de passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/5]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "typebot${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "typebot${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[3/5]\e[0m"
echo ""
sleep 1

pegar_senha_minio
minio.bucket typebot${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
    echo ""
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO TYPEBOT \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
key_typebot=$(openssl rand -hex 16)

## Criando a stack typebot.yaml
cat > typebot${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  typebot${1:+_$1}_builder:
    image: baptistearno/typebot-builder:latest ## Versão do Builder do Typebot

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Dados do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/typebot${1:+_$1}

    ## 🔐 Encryption key
      - ENCRYPTION_SECRET=$key_typebot
      - AUTH_TRUST_HOST=https://$url_typebot

    ## 📦 Plano Padrão (das novas contas)
      - DEFAULT_WORKSPACE_PLAN=UNLIMITED ## FREE, STARTER, PRO, LIFETIME ou UNLIMITED

    ## 🌐 Urls do typebot
      - NEXTAUTH_URL=https://$url_typebot ## URL Builder
      - NEXT_PUBLIC_VIEWER_URL=https://$url_viewer ## URL Viewer
      - NEXTAUTH_URL_INTERNAL=http://localhost:3000

    ## 🚫 Desativar/ativar novos cadastros
      - DISABLE_SIGNUP=false

    ## 📧 Dados do SMTP
      - ADMIN_EMAIL=$email_typebot ## Email SMTP
      - NEXT_PUBLIC_SMTP_FROM='Suporte' <$email_typebot>
      - SMTP_AUTH_DISABLED=false
      - SMTP_USERNAME=$usuario_email_typebot
      - SMTP_PASSWORD=$senha_email_typebot
      - SMTP_HOST=$smtp_email_typebot
      - SMTP_PORT=$porta_smtp_typebot
      - SMTP_SECURE=$smtp_secure_typebot

    ## ☁️ Dados Google Cloud
      #- GOOGLE_AUTH_CLIENT_ID=
      #- GOOGLE_SHEETS_CLIENT_ID=
      #- GOOGLE_AUTH_CLIENT_SECRET=
      #- GOOGLE_SHEETS_CLIENT_SECRET=
      #- NEXT_PUBLIC_GOOGLE_SHEETS_API_KEY=

    ## 🗃️ Dados do Minio/S3
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_BUCKET=typebot${1:+-$1}
      - S3_ENDPOINT=$url_s3
      - S3_REGION=eu-south
      - NEXT_PUBLIC_BOT_FILE_UPLOAD_MAX_SIZE=250

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - io.portainer.accesscontrol.users=admin
        - traefik.enable=true
        - traefik.http.routers.typebot${1:+_$1}_builder.rule=Host(\`$url_typebot\`) ## Url do Builder do Typebot
        - traefik.http.routers.typebot${1:+_$1}_builder.entrypoints=websecure
        - traefik.http.routers.typebot${1:+_$1}_builder.tls.certresolver=letsencryptresolver
        - traefik.http.services.typebot${1:+_$1}_builder.loadbalancer.server.port=3000
        - traefik.http.services.typebot${1:+_$1}_builder.loadbalancer.passHostHeader=true
        - traefik.http.routers.typebot${1:+_$1}_builder.service=typebot${1:+_$1}_builder

## --------------------------- ORION --------------------------- ##

  typebot${1:+_$1}_viewer:
    image: baptistearno/typebot-viewer:latest ## Versão do Viewer do Typebot

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Dados do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/typebot${1:+_$1}

    ## 🔐 Encryption key
      - ENCRYPTION_SECRET=$key_typebot
      - AUTH_TRUST_HOST=https://$url_typebot

    ## 📦 Plano Padrão (das novas contas)
      - DEFAULT_WORKSPACE_PLAN=UNLIMITED ## FREE, STARTER, PRO, LIFETIME ou UNLIMITED

    ## 🌐 Urls do typebot
      - NEXTAUTH_URL=https://$url_typebot ## URL Builder
      - NEXT_PUBLIC_VIEWER_URL=https://$url_viewer ## URL Viewer
      - NEXTAUTH_URL_INTERNAL=http://localhost:3000

    ## 🚫 Desativar/ativar novos cadastros
      - DISABLE_SIGNUP=false

    ## 📧 Dados do SMTP
      - ADMIN_EMAIL=$email_typebot ## Email SMTP
      - NEXT_PUBLIC_SMTP_FROM='Suporte' <$email_typebot>
      - SMTP_AUTH_DISABLED=false
      - SMTP_USERNAME=$usuario_email_typebot
      - SMTP_PASSWORD=$senha_email_typebot
      - SMTP_HOST=$smtp_email_typebot
      - SMTP_PORT=$porta_smtp_typebot
      - SMTP_SECURE=$smtp_secure_typebot

    ## ☁️ Dados Google Cloud
      #- GOOGLE_AUTH_CLIENT_ID=
      #- GOOGLE_SHEETS_CLIENT_ID=
      #- GOOGLE_AUTH_CLIENT_SECRET=
      #- GOOGLE_SHEETS_CLIENT_SECRET=
      #- NEXT_PUBLIC_GOOGLE_SHEETS_API_KEY=

    ## 🗃️ Dados do Minio/S3
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_BUCKET=typebot${1:+-$1}
      - S3_ENDPOINT=$url_s3
      - S3_REGION=eu-south
      - NEXT_PUBLIC_BOT_FILE_UPLOAD_MAX_SIZE=250

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - io.portainer.accesscontrol.users=admin
        - traefik.enable=true
        - traefik.http.routers.typebot${1:+_$1}_viewer.rule=Host(\`$url_viewer\`) ## Url do Viewer do Typebot
        - traefik.http.routers.typebot${1:+_$1}_viewer.entrypoints=websecure
        - traefik.http.routers.typebot${1:+_$1}_viewer.tls.certresolver=letsencryptresolver
        - traefik.http.services.typebot${1:+_$1}_viewer.loadbalancer.server.port=3000
        - traefik.http.services.typebot${1:+_$1}_viewer.loadbalancer.passHostHeader=true
        - traefik.http.routers.typebot${1:+_$1}_viewer.service=typebot${1:+_$1}_viewer

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Typebot"
fi
STACK_NAME="typebot${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c typebot.yaml typebot > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Typebot"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull baptistearno/typebot-builder:latest baptistearno/typebot-viewer:latest

## Usa o serviço wait_typebot para verificar se o serviço esta online
wait_stack typebot${1:+_$1}_typebot${1:+_$1}_builder typebot${1:+_$1}_typebot${1:+_$1}_viewer

telemetria Typebot finalizado

cd dados_vps

cat > dados_typebot${1:+_$1} <<EOL
[ TYPEBOT ]

Dominio do Typebot: https://$url_typebot

Email: Qualquer um (cada email é um workspace)

Senha: Não tem senha, chega no seu email o link magico de acesso
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ TYPEBOT ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_typebot\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Qualquer um (não precisa ser o mesmo que usou na instalação)\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Não tem senha, chega no seu email um link magico de acesso.\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗ █████╗ ███╗   ██╗
## ████╗  ██║██╔══██╗████╗  ██║
## ██╔██╗ ██║╚█████╔╝██╔██╗ ██║
## ██║╚██╗██║██╔══██╗██║╚██╗██║
## ██║ ╚████║╚█████╔╝██║ ╚████║
## ╚═╝  ╚═══╝ ╚════╝ ╚═╝  ╚═══╝

ferramenta_n8n() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_n8n

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do N8N
    echo -e "\e[97mPasso$amarelo 1/7\e[0m"
    echo -en "\e[33mDigite o dominio para o N8N (ex: n8n.oriondesign.art.br): \e[0m" && read -r url_editorn8n
    echo ""
    
    ##Pergunta o Dominio do Webhook
    echo -e "\e[97mPasso$amarelo 2/7\e[0m"
    echo -en "\e[33mDigite o dominio para o Webhook do N8N (ex: webhook.oriondesign.art.br): \e[0m" && read -r url_webhookn8n
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 3/7\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_n8n
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 4/7\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_smtp_n8n
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 5/7\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_smtp_n8n
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 6/7\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_n8n
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 7/7\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_n8n
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ -z "$porta_smtp_n8n" ]; then
      smtp_secure_smtp_n8n=false
    else
      case "$porta_smtp_n8n" in
        465)
          smtp_secure_smtp_n8n=true
          ;;
        25|2525|587)
          smtp_secure_smtp_n8n=false
          ;;
        *)
          smtp_secure_smtp_n8n=false
          ;;
      esac
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_n8n
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do N8N
    echo -e "\e[33mDominio do N8N:\e[97m $url_editorn8n\e[0m"
    echo ""
    
    ## Informação sobre URL do Webhook
    echo -e "\e[33mDominio para o Webhook:\e[97m $url_webhookn8n\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mEmail do SMTP:\e[97m $email_smtp_n8n\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mUsuário do SMTP:\e[97m $usuario_smtp_n8n\e[0m"
    echo ""

    ## Informação sobre Senha do Email
    echo -e "\e[33mSenha do Email:\e[97m $senha_smtp_n8n\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP do Email:\e[97m $host_smtp_n8n\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_n8n\e[0m"
    echo ""

    ## Informação sobre Secure SMTP
    echo -e "\e[33mSecure SMTP do Email:\e[97m $smtp_secure_smtp_n8n\e[0m"
    echo ""
    
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_n8n

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO N8N \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria N8N iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Verifica se tem postgres, se sim pega a senha e cria um banco nele, se não instala, pega a senha e cria o banco
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "n8n_queue${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "n8n_queue${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO N8N \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
encryption_key=$(openssl rand -hex 16)

## Criando a stack n8n.yaml
cat > n8n${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  n8n${1:+_$1}_editor:
    image: n8nio/n8n:latest ## Versão do N8N
    command: start

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Banco de Dados (PostgreSQL)
      - N8N_FIX_MIGRATIONS=true 
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres

    ## 🔐 Criptografia
      - N8N_ENCRYPTION_KEY=$encryption_key

      ## 🌐 URLs e Configurações de Acesso
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https
      - N8N_PROXY_HOPS=1
      - N8N_ONBOARDING_FLOW_DISABLED=true
      - N8N_BLOCK_ENV_ACCESS_IN_NODE=false
      - N8N_SKIP_AUTH_ON_OAUTH_CALLBACK=false

    ## ⚙️ Ambiente de Execução
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_RESTRICT_FILE_ACCESS_TO="~/.n8n-files"
      - NODES_EXCLUDE="[]"

    ## 📦 Pacotes e Nós Comunitários
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true

    ## 📧 SMTP (Envio de E-mails)
      - N8N_SMTP_SENDER=$email_smtp_n8n
      - N8N_SMTP_USER=$usuario_smtp_n8n
      - N8N_SMTP_PASS=$senha_smtp_n8n
      - N8N_SMTP_HOST=$host_smtp_n8n
      - N8N_SMTP_PORT=$porta_smtp_n8n
      - N8N_SMTP_SSL=$smtp_secure_smtp_n8n

    ## 🔁 Redis (Fila de Execução)
      - QUEUE_BULL_REDIS_HOST=n8n${1:+_$1}_redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=1

    ## 📊 Métricas
      - N8N_METRICS=true

    ## ⏱️ Execuções e Limpeza
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

    ## 🧠 Recursos de IA
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=

    ## 🧰 Permissões em Funções Personalizadas
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash

    ## 🕒 Fuso Horário
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
      #- N8N_DEFAULT_LOCALE=pt-BR

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.n8n${1:+_$1}_editor.rule=Host(\`$url_editorn8n\`) ## Url do Editor do N8N
        - traefik.http.routers.n8n${1:+_$1}_editor.entrypoints=websecure
        - traefik.http.routers.n8n${1:+_$1}_editor.priority=10
        - traefik.http.routers.n8n${1:+_$1}_editor.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n${1:+_$1}_editor.service=n8n${1:+_$1}_editor
        - traefik.http.services.n8n${1:+_$1}_editor.loadbalancer.server.port=5678
        - traefik.http.services.n8n${1:+_$1}_editor.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

  n8n${1:+_$1}_webhook:
    image: n8nio/n8n:latest ## Versão do N8N
    command: webhook

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Banco de Dados (PostgreSQL)
      - N8N_FIX_MIGRATIONS=true 
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres

    ## 🔐 Criptografia
      - N8N_ENCRYPTION_KEY=$encryption_key

      ## 🌐 URLs e Configurações de Acesso
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https
      - N8N_PROXY_HOPS=1
      - N8N_ONBOARDING_FLOW_DISABLED=true
      - N8N_BLOCK_ENV_ACCESS_IN_NODE=false
      - N8N_SKIP_AUTH_ON_OAUTH_CALLBACK=false

    ## ⚙️ Ambiente de Execução
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_RESTRICT_FILE_ACCESS_TO="~/.n8n-files"
      - NODES_EXCLUDE="[]"

    ## 📦 Pacotes e Nós Comunitários
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true

    ## 📧 SMTP (Envio de E-mails)
      - N8N_SMTP_SENDER=$email_smtp_n8n
      - N8N_SMTP_USER=$usuario_smtp_n8n
      - N8N_SMTP_PASS=$senha_smtp_n8n
      - N8N_SMTP_HOST=$host_smtp_n8n
      - N8N_SMTP_PORT=$porta_smtp_n8n
      - N8N_SMTP_SSL=$smtp_secure_smtp_n8n

    ## 🔁 Redis (Fila de Execução)
      - QUEUE_BULL_REDIS_HOST=n8n${1:+_$1}_redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=1

    ## 📊 Métricas
      - N8N_METRICS=true

    ## ⏱️ Execuções e Limpeza
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

    ## 🧠 Recursos de IA
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=

    ## 🧰 Permissões em Funções Personalizadas
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash

    ## 🕒 Fuso Horário
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
      #- N8N_DEFAULT_LOCALE=pt-BR
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.n8n${1:+_$1}_webhook.rule=Host(\`$url_webhookn8n\`) ## Url do Webhook do N8N
        - traefik.http.routers.n8n${1:+_$1}_webhook.entrypoints=websecure
        - traefik.http.routers.n8n${1:+_$1}_webhook.priority=5
        - traefik.http.routers.n8n${1:+_$1}_webhook.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n${1:+_$1}_webhook.service=n8n${1:+_$1}_webhook
        - traefik.http.services.n8n${1:+_$1}_webhook.loadbalancer.server.port=5678
        - traefik.http.services.n8n${1:+_$1}_webhook.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

  n8n${1:+_$1}_worker:
    image: n8nio/n8n:latest ## Versão do N8N
    command: worker --concurrency=10

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Banco de Dados (PostgreSQL)
      - N8N_FIX_MIGRATIONS=true 
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres

    ## 🔐 Criptografia
      - N8N_ENCRYPTION_KEY=$encryption_key

      ## 🌐 URLs e Configurações de Acesso
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https
      - N8N_PROXY_HOPS=1
      - N8N_ONBOARDING_FLOW_DISABLED=true
      - N8N_BLOCK_ENV_ACCESS_IN_NODE=false
      - N8N_SKIP_AUTH_ON_OAUTH_CALLBACK=false

    ## ⚙️ Ambiente de Execução
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_RESTRICT_FILE_ACCESS_TO="~/.n8n-files"
      - NODES_EXCLUDE="[]"

    ## 📦 Pacotes e Nós Comunitários
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true

    ## 📧 SMTP (Envio de E-mails)
      - N8N_SMTP_SENDER=$email_smtp_n8n
      - N8N_SMTP_USER=$usuario_smtp_n8n
      - N8N_SMTP_PASS=$senha_smtp_n8n
      - N8N_SMTP_HOST=$host_smtp_n8n
      - N8N_SMTP_PORT=$porta_smtp_n8n
      - N8N_SMTP_SSL=$smtp_secure_smtp_n8n

    ## 🔁 Redis (Fila de Execução)
      - QUEUE_BULL_REDIS_HOST=n8n${1:+_$1}_redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=1

    ## 📊 Métricas
      - N8N_METRICS=true

    ## ⏱️ Execuções e Limpeza
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

    ## 🧠 Recursos de IA
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=

    ## 🧰 Permissões em Funções Personalizadas
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash

    ## 🕒 Fuso Horário
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
      #- N8N_DEFAULT_LOCALE=pt-BR
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  n8n${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - n8n${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  n8n${1:+_$1}_redis:
    external: true
    name: n8n${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do N8N"
fi
STACK_NAME="n8n${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c n8n.yaml n8n > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do N8N"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest n8nio/n8n:latest

## Usa o serviço wait_n8n para verificar se o serviço esta online
wait_stack n8n${1:+_$1}_n8n${1:+_$1}_redis n8n${1:+_$1}_n8n${1:+_$1}_editor n8n${1:+_$1}_n8n${1:+_$1}_webhook n8n${1:+_$1}_n8n${1:+_$1}_worker

telemetria N8N finalizado

cd dados_vps

cat > dados_n8n${1:+_$1} <<EOL
[ N8N ]

Dominio do N8N: https://$url_editorn8n

Dominio do Webhook do N8N: https://$url_webhookn8n

Email: Precisa criar no primeiro acesso do N8N

Senha: Precisa criar no primeiro acesso do N8N

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ N8N ]\e[0m"
echo ""

echo -e "\e[33mDominio Editor:\e[97m https://$url_editorn8n\e[0m"
echo ""

echo -e "\e[33mDominio Webhook:\e[97m https://$url_webhookn8n\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa criar no primeiro acesso do N8N\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do N8N\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗      ██████╗ ██╗    ██╗██╗███████╗███████╗
## ██╔════╝██║     ██╔═══██╗██║    ██║██║██╔════╝██╔════╝
## █████╗  ██║     ██║   ██║██║ █╗ ██║██║███████╗█████╗  
## ██╔══╝  ██║     ██║   ██║██║███╗██║██║╚════██║██╔══╝  
## ██║     ███████╗╚██████╔╝╚███╔███╔╝██║███████║███████╗
## ╚═╝     ╚══════╝ ╚═════╝  ╚══╝╚══╝ ╚═╝╚══════╝╚══════╝

ferramenta_flowise() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_flowise

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Flowise (ex: flowise.oriondesign.art.br): \e[0m" && read -r url_flowise
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_flowise
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Flowise
    echo -e "\e[33mDominio do Flowise\e[97m $url_flowise\e[0m"
    echo ""
  
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_flowise

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO FLOWISE \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Flowise iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Já sabe né ksk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "flowise${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "flowise${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO FLOWISE \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando uma Encryption Key Aleatória
encryption_key=$(openssl rand -hex 16)

## Criando a stack flowise.yaml
cat > flowise${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  flowise${1:+_$1}:
    image: flowiseai/flowise:latest ## Versão do Flowise

    volumes:
     - flowise${1:+_$1}_data:/root/.flowise

    networks:
     - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🐘 Dados do Postgres
      - DATABASE_TYPE=postgres
      - DATABASE_HOST=postgres
      - DATABASE_PORT=5432
      - DATABASE_USER=postgres
      - DATABASE_PASSWORD=$senha_postgres
      - DATABASE_NAME=flowise${1:+_$1}

    ## 💾 Configuração de Armazenamento
      - STORAGE_TYPE=local ## local ou s3
      #- S3_ENDPOINT_URL=
      #- S3_STORAGE_BUCKET_NAME=flowise${1:+-$1}
      #- S3_STORAGE_ACCESS_KEY_ID=
      #- S3_STORAGE_SECRET_ACCESS_KEY=
      #- S3_STORAGE_REGION=eu-south
      #- S3_FORCE_PATH_STYLE=true

     ## 📧 Dados do SMTP
      #- SENDER_EMAIL=email@dominio.com
      #- SMTP_USER=email@dominio.com
      #- SMTP_PASSWORD=@Senha123_
      #- SMTP_HOST=smtp.dominio.com
      #- SMTP_PORT=587
      #- SMTP_SECURE=false
      #- ALLOW_UNAUTHORIZED_CERTS=false
      
    ## ⚙️ Configuração da Aplicação
      - NUMBER_OF_PROXIES=1
      - SHOW_COMMUNITY_NODES=true
      - DISABLE_FLOWISE_TELEMETRY=true
    
    ## 🔐 Encryption Key
      - FLOWISE_SECRETKEY_OVERWRITE=$encryption_key

    ## 🗝️ Diretório das API Keys
      - APIKEY_PATH=/root/.flowise
      - SECRETKEY_PATH=/root/.flowise

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.flowise${1:+_$1}.rule=Host(\`$url_flowise\`) ## Url da aplicação
        - traefik.http.services.flowise${1:+_$1}.loadBalancer.server.port=3000
        - traefik.http.routers.flowise${1:+_$1}.service=flowise${1:+_$1}
        - traefik.http.routers.flowise${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.flowise${1:+_$1}.tls.certresolver=letsencryptresolver

## --------------------------- ORION --------------------------- ##

volumes:
  flowise${1:+_$1}_data:
    external: true

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Flowise"
fi
STACK_NAME="flowise${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c flowise.yaml flowise  > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Flowise"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull flowiseai/flowise:latest

## Usa o serviço wait_flowise para verificar se o serviço esta online
wait_stack flowise${1:+_$1}_flowise${1:+_$1}

telemetria Flowise finalizado

cd dados_vps

cat > dados_flowise${1:+_$1} <<EOL
[ FLOWISE ]

Dominio do Flowise: https://$url_flowise

Email: Precisa de criar no primeiro acesso do Flowise

Senha: Precisa de criar no primeiro acesso do Flowise
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ FLOWISE ]\e[0m"
echo ""
echo -e "\e[33mDominio:\e[97m https://$url_flowise\e[0m"
echo ""
echo -e "\e[33mUEmail:\e[97m Precisa de criar no primeiro acesso do Flowise\e[0m"
echo ""
echo -e "\e[33mSenha:\e[97m Precisa de criar no primeiro acesso do Flowise\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗      █████╗ ██████╗ ███╗   ███╗██╗███╗   ██╗    ██╗  ██╗
## ██╔══██╗██╔════╝     ██╔══██╗██╔══██╗████╗ ████║██║████╗  ██║    ██║  ██║
## ██████╔╝██║  ███╗    ███████║██║  ██║██╔████╔██║██║██╔██╗ ██║    ███████║
## ██╔═══╝ ██║   ██║    ██╔══██║██║  ██║██║╚██╔╝██║██║██║╚██╗██║    ╚════██║
## ██║     ╚██████╔╝    ██║  ██║██████╔╝██║ ╚═╝ ██║██║██║ ╚████║         ██║
## ╚═╝      ╚═════╝     ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝         ╚═╝

ferramenta_pgAdmin_4() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_pgAdmin_4

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o PgAdmin 4 (ex: pgadmin.oriondesign.art.br): \e[0m" && read -r url_PgAdmin_4
    echo ""
    
    ##Pergunta o Email para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite um email para o PgAdmin 4 (ex: contato@oriondesign.art.br): \e[0m" && read -r user_PgAdmin_4
    echo ""
    
    ##Pergunta a Senha para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Minimo 8 caracteres. Use Letras MAIUSCULAS e minusculas, numero e um caractere especial @ ou _"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma senha para o usuario (ex: @Senha123_): \e[0m" && read -r pass_PgAdmin_4
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_pgAdmin_4
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do PgAdmin
    echo -e "\e[33mDominio do PgAdmin 4\e[97m $url_PgAdmin_4\e[0m"
    echo ""
    
    ## Informação sobre email do PgAdmin
    echo -e "\e[33mEmail:\e[97m $user_PgAdmin_4\e[0m"
    echo ""
    
    ## Informação sobre a senha do PgAdmin
    echo -e "\e[33mSenha:\e[97m $pass_PgAdmin_4\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PGADMIN 4 \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria "PgAdmin 4" "iniciado"

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO PGADMIN 4 \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack pgadmin.yaml 
cat > pgadmin${1:+_$1}.yaml <<EOL
version: "3.7"
services:  

## --------------------------- ORION --------------------------- ##

  pgadmin${1:+_$1}:
    image: dpage/pgadmin4:latest ## Versão do PgAdmin 4

    volumes:
      - pgadmin${1:+_$1}_data:/var/lib/pgadmin

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔑 Dados de Acesso
      - PGADMIN_DEFAULT_EMAIL=$user_PgAdmin_4
      - PGADMIN_DEFAULT_PASSWORD=$pass_PgAdmin_4

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '1'
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.pgadmin${1:+_$1}.rule=Host(\`$url_PgAdmin_4\`) ## Url da Ferramenta
        - traefik.http.services.pgadmin${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.pgadmin${1:+_$1}.service=pgadmin${1:+_$1}
        - traefik.http.routers.pgadmin${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.pgadmin${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.pgadmin${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  pgadmin${1:+_$1}_data:
    external: true
    
networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do PgAdmin 4"
fi
STACK_NAME="pgadmin${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c pgadmin.yaml pgadmin  > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do PgAdmin 4"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull dpage/pgadmin4:latest

## Usa o serviço wait_pgadmin_4 para verificar se o serviço esta online
wait_stack pgadmin${1:+_$1}_pgadmin${1:+_$1}

telemetria "PgAdmin 4" "finalizado"

cd dados_vps

cat > dados_pgadmin${1:+_$1} <<EOL
[ PGADMIN 4 ]

Dominio do pgadmin: https://$url_PgAdmin_4

Usuario: $user_PgAdmin_4

Senha: $pass_PgAdmin_4
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PGADMIN 4 ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_PgAdmin_4\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m $user_PgAdmin_4\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_PgAdmin_4\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗ ██████╗  ██████╗ ██████╗ ██████╗  █████╗ ███████╗███████╗
## ████╗  ██║██╔═══██╗██╔════╝██╔═══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝
## ██╔██╗ ██║██║   ██║██║     ██║   ██║██████╔╝███████║███████╗█████╗  
## ██║╚██╗██║██║   ██║██║     ██║   ██║██╔══██╗██╔══██║╚════██║██╔══╝  
## ██║ ╚████║╚██████╔╝╚██████╗╚██████╔╝██████╔╝██║  ██║███████║███████╗
## ╚═╝  ╚═══╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝

ferramenta_nocobase() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_nocobase
## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/4\e[0m"
    echo -en "\e[33mDigite o dominio para o Nocobase (ex: nocobase.oriondesign.art.br): \e[0m" && read -r url_nocobase
    echo ""
    
    ##Pergunta o Email para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/4\e[0m"
    echo -en "\e[33mDigite um email para o Nocobase (ex: contato@oriondesign.art.br): \e[0m" && read -r mail_nocobase
    echo ""
    
    ##Pergunta um Usuario para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/4\e[0m"
    echo -en "\e[33mDigite um nome de usuario para o Nocobase (ex: OrionDesign): \e[0m" && read -r user_nocobase
    echo ""
    
    ##Pergunta a Senha para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    echo -e "$amarelo--> Minimo 8 caracteres. Use Letras MAIUSCULAS e minusculas, numero e um caractere especial @ ou _"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma senha para o usuario (ex: @Senha123_): \e[0m" && read -r pass_nocobase
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_nocobase
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Nocobase
    echo -e "\e[33mDominio do Nocobase:\e[97m $url_nocobase\e[0m"
    echo ""
    
    ## Informação sobre Email do Nocobase
    echo -e "\e[33mEmail:\e[97m $mail_nocobase\e[0m"
    echo ""
    
    ## Informação sobre Usuario do Nocobase
    echo -e "\e[33mUsuario:\e[97m $user_nocobase\e[0m"
    echo ""
    
    ## Informação sobre Senha do Nocobase
    echo -e "\e[33mSenha:\e[97m $pass_nocobase\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO NOCOBASE \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Nocobase iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "nocobase${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "nocobase${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO NOCOBASE \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando uma Encryption Key Aleatória
nocobase_key=$(openssl rand -hex 16)
nocobase_encryption=$(openssl rand -hex 16)

## Criando a stack nocobase.yaml
cat > nocobase${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  nocobase${1:+_$1}:
    image: nocobase/nocobase:latest ## Versão do Nocobase

    volumes:
      - nocobase${1:+_$1}_storage:/app/nocobase/storage

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 👤 Configuração da Conta
      - INIT_ROOT_EMAIL=$mail_nocobase
      - INIT_ROOT_PASSWORD=$pass_nocobase
      - INIT_ROOT_NICKNAME=$user_nocobase
      - INIT_ROOT_USERNAME=$user_nocobase
      - INIT_LANG=pt-BR

    ## 🐘 Dados do Postgres
      - DB_DIALECT=postgres
      - DB_HOST=postgres
      - DB_DATABASE=nocobase${1:+_$1}
      - DB_USER=postgres
      - DB_PASSWORD=$senha_postgres

    ## 🌐 Paths de URL
      - LOCAL_STORAGE_BASE_URL=/storage/uploads
      - API_BASE_PATH=/api/

    ## 🔐 Encryption Key
      - APP_KEY=$nocobase_key
      - ENCRYPTION_FIELD_KEY=$nocobase_encryption

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.nocobase${1:+_$1}.rule=Host(\`$url_nocobase\`) ## Url da aplicação
        - traefik.http.services.nocobase${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.nocobase${1:+_$1}.service=nocobase${1:+_$1}
        - traefik.http.routers.nocobase${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.nocobase${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.nocobase${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  nocobase${1:+_$1}_storage:
    external: true

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Nocobase"
fi
STACK_NAME="nocobase${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c nocobase.yaml nocobase > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Nocobase"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull nocobase/nocobase:latest

## Usa o serviço wait_stack "nocobase" para verificar se o serviço esta online
wait_stack nocobase${1:+_$1}_nocobase${1:+_$1}

telemetria Nocobase finalizado

cd dados_vps

cat > dados_nocobase<<EOL
[ NOCOBASE ]

Dominio do Nocobase: https://$url_nocobase

Email: $mail_nocobase

Usuario: $user_nocobase

Senha: $pass_nocobase
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ NOCOBASE ]\e[0m"
echo ""
echo -e "\e[33mDominio:\e[97m https://$url_nocobase\e[0m"
echo ""
echo -e "\e[33mEmail:\e[97m $mail_nocobase\e[0m"
echo ""
echo -e "\e[33mUsuario:\e[97m $user_nocobase\e[0m"
echo ""
echo -e "\e[33mSenha:\e[97m $pass_nocobase\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗ ████████╗██████╗ ██████╗ ███████╗███████╗███████╗
## ██╔══██╗██╔═══██╗╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██╔════╝
## ██████╔╝██║   ██║   ██║   ██████╔╝██████╔╝█████╗  ███████╗███████╗
## ██╔══██╗██║   ██║   ██║   ██╔═══╝ ██╔══██╗██╔══╝  ╚════██║╚════██║
## ██████╔╝╚██████╔╝   ██║   ██║     ██║  ██║███████╗███████║███████║
## ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝
                                                                  
ferramenta_botpress() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_botpress

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Botpress (ex: botpress.oriondesign.art.br): \e[0m" && read -r url_botpress
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_botpress
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Botpress
    echo -e "\e[33mDominio do Botpress:\e[97m $url_botpress\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_botpress

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO BOTPRESS \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria Botpress iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/5]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "botpress${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "botpress${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO BOTPRESS \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando a stack botpress.yaml
cat > botpress${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  botpress${1:+_$1}_app:
    image: botpress/server:latest

    volumes:
      - botpress${1:+_$1}_data:/botpress/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🤖 Url Botpress
      - EXTERNAL_URL=https://$url_botpress

    ## ⚙️ Modo
      - BP_PRODUCTION=true

    ## 🐘 Dados Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/botpress${1:+_$1}

    ## 🚀 Dados Redis
      - REDIS_URL=redis://redis:6379

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.botpress${1:+_$1}.rule=Host(\`$url_botpress\`)
        - traefik.http.services.botpress${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.botpress${1:+_$1}.service=botpress${1:+_$1}
        - traefik.http.routers.botpress${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.botpress${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.botpress${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  botpress${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - botpress${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  botpress${1:+_$1}_data:
    external: true
    name: botpress${1:+_$1}_data
  botpress${1:+_$1}_redis:
    external: true
    name: botpress${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Botpress"
fi
STACK_NAME="botpress${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c botpress.yaml botpress > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Botpress"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest botpress/server:latest

## Usa o serviço wait_botpress para verificar se o serviço esta online
wait_stack botpress${1:+_$1}_botpress${1:+_$1}_redis botpress${1:+_$1}_botpress${1:+_$1}_app

telemetria Botpress finalizado

cd dados_vps

cat > dados_botpress${1:+_$1} <<EOL
[ BOTPRESS ]

Dominio do Botpress: https://$url_botpress

Usuario: Precisa criar no primeiro acesso do Botpress

Senha: Precisa criar no primeiro acesso do Botpress

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ BOTPRESS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_botpress\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Botpress\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Botpress\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}


## ██╗    ██╗ ██████╗ ██████╗ ██████╗ ██████╗ ██████╗ ███████╗███████╗███████╗
## ██║    ██║██╔═══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝██╔════╝
## ██║ █╗ ██║██║   ██║██████╔╝██║  ██║██████╔╝██████╔╝█████╗  ███████╗███████╗
## ██║███╗██║██║   ██║██╔══██╗██║  ██║██╔═══╝ ██╔══██╗██╔══╝  ╚════██║╚════██║
## ╚███╔███╔╝╚██████╔╝██║  ██║██████╔╝██║     ██║  ██║███████╗███████║███████║
##  ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝

ferramenta_wordpress() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_wordpress

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o Wordpress (ex: oriondesign.art.br ou loja.oriondesign.art.br): \e[0m" && read -r url_wordpress
    echo ""
    
    ## Pergunta o nome do site
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -e "$amarelo--> Use apenas letras minusculas, sem espaço ou caracteres especiais"
    echo -en "\e[33mDigite o nome do Site (ex: lojaorion): \e[0m" && read -r nome_site_wordpress
    echo ""  

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_wordpress
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Wordpress
    echo -e "\e[33mDominio do Wordpress:\e[97m $url_wordpress\e[0m"
    echo ""
    
    ## Informação sobre Nome do site
    echo -e "\e[33mNome do Site:\e[97m $nome_site_wordpress\e[0m"
    echo ""
    

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WORDPRESS \e[33m[1/6]\e[0m"
echo ""
sleep 1

telemetria Wordpress iniciado

## Ativa a função dados para pegar os dados da vps
dados

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/6]\e[0m"
echo ""
sleep 1

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "$nome_site_wordpress"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "$nome_site_wordpress"
    fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO WORDPRESS \e[33m[3/6]\e[0m"
echo ""
sleep 1

## Criando a stack wordpress.yaml
cat > wordpress_$nome_site_wordpress.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  wordpress_$nome_site_wordpress:
    image: wordpress:latest ## Versão do Wordpress

    volumes:
      - wordpress_$nome_site_wordpress:/var/www/html
      - wordpress_${nome_site_wordpress}_php:/usr/local/etc/php

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🐬 Dados do MySQL
      - WORDPRESS_DB_NAME=$nome_site_wordpress
      - WORDPRESS_DB_HOST=mysql
      - WORDPRESS_DB_PORT=3306
      - WORDPRESS_DB_USER=root
      - WORDPRESS_DB_PASSWORD=$senha_mysql

    ## 🚀 Redis
      - WP_REDIS_HOST=wordpress_${nome_site_wordpress}_redis
      - WP_REDIS_PORT=6379
      - WP_REDIS_DATABASE=1

    ## 🌐 URL do WordPress
      - VIRTUAL_HOST=$url_wordpress

    ## 📍 Localização
      - WP_LOCALE=pt_BR

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.wordpress_$nome_site_wordpress.rule=Host(\`$url_wordpress\`)
        - traefik.http.routers.wordpress_$nome_site_wordpress.entrypoints=websecure
        - traefik.http.routers.wordpress_$nome_site_wordpress.tls.certresolver=letsencryptresolver
        - traefik.http.routers.wordpress_$nome_site_wordpress.service=wordpress_$nome_site_wordpress
        - traefik.http.services.wordpress_$nome_site_wordpress.loadbalancer.server.port=80
        - traefik.http.services.wordpress_$nome_site_wordpress.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  wordpress_${nome_site_wordpress}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - wordpress_${nome_site_wordpress}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  wordpress_$nome_site_wordpress:
    external: true
    name: wordpress_$nome_site_wordpress
  wordpress_${nome_site_wordpress}_php:
    external: true
    name: wordpress_${nome_site_wordpress}_php
  wordpress_${nome_site_wordpress}_redis:
    external: true
    name: wordpress_${nome_site_wordpress}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Wordpress"
fi
STACK_NAME="wordpress_$nome_site_wordpress"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c $nome_da_stack_wordpress $nome_da_stack_wordpress_subir #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Wordpress"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/6]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest wordpress:latest

## Usa o serviço wait_wordpress para verificar se o serviço esta online
wait_stack "wordpress_$nome_site_wordpress"

## Mensagem de Passo
echo ""
echo -e "\e[97m• EDITANDO PHP.INI \e[33m[5/6]\e[0m"
echo ""
sleep 1

## Validação de variáveis obrigatórias
if [ -z "$nome_site_wordpress" ]; then
    echo "ERRO: Variável 'nome_site_wordpress' não está definida!"
    exit 1
fi

## Função para verificar e exibir status de comandos
verificar_comando() {
    local passo=$1
    local descricao=$2
    local status=$3
    
    if [ $status -eq 0 ]; then
        echo "$passo - [ OK ] - $descricao"
        return 0
    else
        echo "$passo - [ ERRO ] - $descricao"
        return 1
    fi
}

## Definindo caminhos
caminho_php_ini="/var/lib/docker/volumes/wordpress_${nome_site_wordpress}_php/_data/php.ini"
caminho_php_ini_prod="/var/lib/docker/volumes/wordpress_${nome_site_wordpress}_php/_data/php.ini-production"
caminho_wp_config="/var/lib/docker/volumes/wordpress_${nome_site_wordpress}/_data/wp-config.php"

## Verificando se os diretórios existem
if [ ! -d "$(dirname "$caminho_php_ini")" ]; then
    echo "ERRO: Diretório do volume PHP não encontrado: $(dirname "$caminho_php_ini")"
    exit 1
fi

if [ ! -d "$(dirname "$caminho_wp_config")" ]; then
    echo "ERRO: Diretório do volume WordPress não encontrado: $(dirname "$caminho_wp_config")"
    exit 1
fi

## Copiando arquivo php.ini-production para php.ini
if [ ! -f "$caminho_php_ini_prod" ]; then
    echo "AVISO: Arquivo php.ini-production não encontrado. Tentando criar php.ini do zero..."
    touch "$caminho_php_ini"
else
    cp "$caminho_php_ini_prod" "$caminho_php_ini"
fi
verificar_comando "1/8" "Copiando arquivo php.ini" $? || exit 1

## Modificando configurações do PHP.INI
sed -i "s/^upload_max_filesize =.*/upload_max_filesize = 1024M/" "$caminho_php_ini" 2>/dev/null
if [ $? -ne 0 ]; then
    # Se a linha não existir, adiciona ao final do arquivo
    echo "upload_max_filesize = 1024M" >> "$caminho_php_ini"
fi
verificar_comando "2/8" "Modificando upload_max_filesize para 1024M" $?

sed -i "s/^post_max_size =.*/post_max_size = 1024M/" "$caminho_php_ini" 2>/dev/null
if [ $? -ne 0 ]; then
    # Se a linha não existir, adiciona ao final do arquivo
    echo "post_max_size = 1024M" >> "$caminho_php_ini"
fi
verificar_comando "3/8" "Modificando post_max_size para 1024M" $?

sed -i "s/^max_execution_time =.*/max_execution_time = 450/" "$caminho_php_ini" 2>/dev/null
if [ $? -ne 0 ]; then
    echo "max_execution_time = 450" >> "$caminho_php_ini"
fi
verificar_comando "4/8" "Modificando max_execution_time para 450" $?

sed -i "s/^memory_limit =.*/memory_limit = 1024M/" "$caminho_php_ini" 2>/dev/null
if [ $? -ne 0 ]; then
    echo "memory_limit = 1024M" >> "$caminho_php_ini"
fi
verificar_comando "5/8" "Modificando memory_limit para 1024M" $?

## Verificando se wp-config.php existe
if [ ! -f "$caminho_wp_config" ]; then
    echo "ERRO: Arquivo wp-config.php não encontrado: $caminho_wp_config"
    exit 1
fi
verificar_comando "6/8" "Verificando arquivo wp-config.php" 0

## Adicionando configurações do Redis no wp-config.php
sed -i "/\/\* Add any custom values between this line and the \"stop editing\" line. \*\//i\\
define( 'WP_REDIS_HOST', 'wordpress_${nome_site_wordpress}_redis' );\n\
define( 'WP_REDIS_PORT', 6379 );\n" "$caminho_wp_config" 2>/dev/null

# Verificando se a inserção foi bem-sucedida
if grep -q "WP_REDIS_HOST" "$caminho_wp_config" 2>/dev/null; then
    verificar_comando "7/8" "Adicionando configurações do Redis no wp-config.php" 0
else
    verificar_comando "7/8" "Adicionando configurações do Redis no wp-config.php" 1
fi

## Aplicando atualização no serviço Docker
docker service update --force "wordpress_${nome_site_wordpress}_wordpress_${nome_site_wordpress}" > /dev/null 2>&1
verificar_comando "8/8" "Aplicando atualização no php.ini" $?

echo ""

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[6/6]\e[0m"
echo ""
sleep 1

## Usa o serviço wait_wordpress para verificar se o serviço esta online
wait_stack "wordpress_$nome_site_wordpress"

docker container prune -f > /dev/null 2>&1

telemetria Wordpress finalizado

cd dados_vps

cat > wordpress_$nome_do_servico_wordpress <<EOL
[ WORDPRESS ]

Dominio do Wordpress: https://$url_wordpress

Arquivos do site: /var/lib/docker/volumes/wordpress_$nome_site_wordpress/_data

Arquivos do php: /var/lib/docker/volumes/wordpress_${nome_site_wordpress}_php/_data
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WORDPRESS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_wordpress\e[0m"
echo ""

echo -e "\e[33mArquivos do site:\e[97m /var/lib/docker/volumes/wordpress_$nome_site_wordpress/_data\e[0m"
echo ""

echo -e "\e[33mArquivos do php:\e[97m /var/lib/docker/volumes/wordpress_${nome_site_wordpress}_php/_data\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  █████╗ ███████╗███████╗██████╗  ██████╗ ██╗    ██╗
## ██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔═══██╗██║    ██║
## ██████╔╝███████║███████╗█████╗  ██████╔╝██║   ██║██║ █╗ ██║
## ██╔══██╗██╔══██║╚════██║██╔══╝  ██╔══██╗██║   ██║██║███╗██║
## ██████╔╝██║  ██║███████║███████╗██║  ██║╚██████╔╝╚███╔███╔╝
## ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝ 
                                                           
ferramenta_baserow() {

## Verifica os recursos
recursos 2 4 && continue || return

## Verifica os recursos
recursos 1 1 && continue || return
## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_baserow

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o dominio para o Baserow (ex: baserow.oriondesign.art.br): \e[0m" && read -r url_baserow
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r mail_baserow
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_baserow
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r pass_baserow
    echo ""


    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r host_baserow
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a Porta SMTP do Email (ex: 465): \e[0m" && read -r porta_baserow
    echo ""


    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_baserow" -eq 465 ]; then
    ssl_baserow_environment="- EMAIL_SMTP_USE_SSL=true"
    else
    ssl_baserow_environment="- EMAIL_SMTP_USE_TLS=true"
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_baserow
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o Baserow:\e[97m $url_baserow\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mEmail do SMTP:\e[97m $mail_baserow\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mUsuário do SMTP:\e[97m $user_baserow\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mSenha do SMTP:\e[97m $pass_baserow\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mHost do SMTP:\e[97m $host_baserow\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mPorta do SMTP:\e[97m $porta_baserow\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_baserow

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO BASEROW \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Baserow iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO BASEROW \e[33m[2/3]\e[0m"
echo ""
sleep 1

secret_key_baserow=$(openssl rand -hex 16)
jwt_key_baserow=$(openssl rand -hex 16)

## Criando a stack baserow.yaml
cat > baserow${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  baserow${1:+_$1}_app:
    image: baserow/baserow:latest

    volumes:
      - baserow${1:+_$1}_data:/baserow/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 URL do Baserow
      - BASEROW_PUBLIC_URL=https://$url_baserow
      
    ## 🛡️ Configurações de Segurança
      - SECRET_KEY=$secret_key_baserow
      - BASEROW_JWT_SIGNING_KEY=$jwt_key_baserow
      
    ## 📧 Configurações de Email SMTP
      - EMAIL_SMTP=true
      - FROM_EMAIL=$mail_baserow ## Email
      - EMAIL_SMTP=$mail_baserow ## Email
      - EMAIL_SMTP_USER=$user_baserow ## Email (ou usuario)
      - EMAIL_SMTP_PASSWORD=$pass_baserow ## Senha do SMTP
      - EMAIL_SMTP_HOST=$host_baserow ## Host SMTP
      - EMAIL_SMTP_PORT=$porta_baserow ## Porta SMTP
      $ssl_baserow_environment

    ## 🧩 Configurações de Migração e Templates
      - MIGRATE_ON_STARTUP=true
      - SYNC_TEMPLATES_ON_STARTUP=false

    ## 🚀 Configurações do Redis
      - REDIS_HOST=baserow${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      - REDIS_URL=redis://baserow${1:+_$1}_redis:6379/1
      
    ## 🐘 Configurações do Banco de Dados
      #- DATABASE_HOST=pgvector
      #- DATABASE_PORT=5432
      #- DATABASE_USER=postgres
      #- DATABASE_NAME=baserow${1:+_$1}
      #- DATABASE_PASSWORD=SENHA_DO_PGVECTOR
      #- DATABASE_URL=postgresql://postgres:SENHA_DO_PGVECTOR@baserow_db:5432/baserow${1:+_$1}?sslmode=disable

    ## ☁️ Configurações AWS S3 (descomente para usar)
      #- AWS_ACCESS_KEY_ID=
      #- AWS_SECRET_ACCESS_KEY=
      #- AWS_STORAGE_BUCKET_NAME=baserow${1:+-$1}
      #- AWS_S3_REGION_NAME=eu-south
      #- AWS_S3_ENDPOINT_URL=https://s3.dominio.com

    ## 🔍 Log Level
      #- BASEROW_BACKEND_LOG_LEVEL=INFO

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.baserow${1:+_$1}.rule=Host(\`$url_baserow\`)
        - traefik.http.services.baserow${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.baserow${1:+_$1}.service=baserow${1:+_$1}
        - traefik.http.routers.baserow${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.baserow${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.baserow${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  baserow${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - baserow${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  baserow${1:+_$1}_data:
    external: true
    name: baserow${1:+_$1}_data
  baserow${1:+_$1}_redis:
    external: true
    name: baserow${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Baserow"
fi

STACK_NAME="baserow${1:+_$1}"
stack_editavel # > /dev/null 2>&1

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest baserow/baserow:latest

## Usa o serviço wait_baserow para verificar se o serviço esta online
wait_stack baserow${1:+_$1}_baserow${1:+_$1}_redis baserow${1:+_$1}_baserow${1:+_$1}_app

telemetria Baserow finalizado

cd
cd dados_vps

cat > dados_baserow${1:+_$1} <<EOL
[ BASEROW ]

Dominio do Baserow: https://$url_baserow

Usuario: Precisa criar no primeiro acesso do Baserow

Senha: Precisa criar no primeiro acesso do Baserow

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ BASEROW ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_baserow\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Baserow\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Baserow\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ███╗ ██████╗ ███╗   ██╗ ██████╗  ██████╗ ██████╗ ██████╗ 
## ████╗ ████║██╔═══██╗████╗  ██║██╔════╝ ██╔═══██╗██╔══██╗██╔══██╗
## ██╔████╔██║██║   ██║██╔██╗ ██║██║  ███╗██║   ██║██║  ██║██████╔╝
## ██║╚██╔╝██║██║   ██║██║╚██╗██║██║   ██║██║   ██║██║  ██║██╔══██╗
## ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║╚██████╔╝╚██████╔╝██████╔╝██████╔╝
## ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚═════╝ 
                                                                
ferramenta_mongodb() {

## Verifica os recursos
recursos 1 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_mongodb

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o nome de usuario
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -e "$amarelo--> Evite os caracteres especiais: @\!#$ e/ou espaço"
    echo -en "\e[33mDigite o nome de usuario (ex: oriondesign): \e[0m" && read -r user_mongo
    echo ""
    
    ## Gera a senha aleatória
    pass_mongo=$(openssl rand -hex 16)
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_mongodb
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação do Usuario
    echo -e "\e[33mUsuario:\e[97m $user_mongo\e[0m"
    echo ""
    
    ## Informação da Senha gerada
    echo -e "\e[33mSenha gerada:\e[97m $pass_mongo\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_mongodb

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MONGO DB \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria MongoDB iniciado

## NADA NADA NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO MONGO DB \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack mongodb.yaml
cat > mongodb${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  mongodb${1:+_$1}:
    image: mongo:latest
    command: mongod --port 27017

    volumes:
      - mongodb${1:+_$1}_data:/data/db
      - mongodb${1:+_$1}_dump:/dump
      - mongodb${1:+_$1}_configdb_data:/data/configdb

    networks:
      - $nome_rede_interna
    #ports:
    #  - 27017:27017

    environment:
    ## 🔑 Dados de acesso
      - MONGO_INITDB_ROOT_USERNAME=$user_mongo
      - MONGO_INITDB_ROOT_PASSWORD=$pass_mongo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '1'
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  mongodb${1:+_$1}_data:
    external: true
    name: mongodb${1:+_$1}_data
  mongodb${1:+_$1}_dump:
    external: true
    name: mongodb${1:+_$1}_dump
  mongodb${1:+_$1}_configdb_data:
    external: true
    name: mongodb${1:+_$1}_configdb_data

networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do MongoDB"
fi
STACK_NAME="mongodb${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c mongodb.yaml mongodb > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do MongoDB"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull mongo:latest

## Usa o serviço wait_stack "mongodb" para verificar se o serviço esta online
wait_stack mongodb${1:+_$1}_mongodb${1:+_$1}

telemetria MongoDB finalizado

cd dados_vps

read -r ip _ <<<$(hostname -I)
ip_vps=$ip

cat > dados_mongodb${1:+_$1} <<EOL
[ MONGODB ]

Dominio do MongoDB: MongoDB://$user_mongo:$pass_mongo@$ip_vps:27017/?authSource=admin&readPreference=primary&ssl=false&directConnection=true

Usuario: $user_mongo

Senha: $pass_mongo

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ MONGODB ]\e[0m"
echo ""
echo -e "\e[33mUsuario:\e[97m $user_mongo\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_mongo\e[0m"
echo ""

echo -e "\e[33mUrl Database:\e[97m mongodb://$user_mongo:$pass_mongo@$ip_vps:27017/?authSource=admin&readPreference=primary&ssl=false&directConnection=true\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  █████╗ ██████╗ ██████╗ ██╗████████╗███╗   ███╗ ██████╗ 
## ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██║╚══██╔══╝████╗ ████║██╔═══██╗
## ██████╔╝███████║██████╔╝██████╔╝██║   ██║   ██╔████╔██║██║   ██║
## ██╔══██╗██╔══██║██╔══██╗██╔══██╗██║   ██║   ██║╚██╔╝██║██║▄▄ ██║
## ██║  ██║██║  ██║██████╔╝██████╔╝██║   ██║   ██║ ╚═╝ ██║╚██████╔╝
## ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚═════╝ ╚═╝   ╚═╝   ╚═╝     ╚═╝ ╚══▀▀═╝ 
                                                                
ferramenta_rabbitmq() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_rabbitmq

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio do RabbitMq
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o RabbitMQ (ex: rabbitmq.oriondesign.art.br): \e[0m" && read -r url_rabbitmq
    echo ""
    
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -e "$amarelo--> Evite os caracteres especiais: @\!#$ e/ou espaço"
    echo -en "\e[33mDigite o nome de usuario (ex: OrionDesign): \e[0m" && read -r user_rabbitmq
    echo ""
    
    ## Gera a senha aleatória
    pass_rabbitmq=$(openssl rand -hex 16)
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_rabbitmq
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação do Dominio do RabbitMQ
    echo -e "\e[33mDominio do RabbitMQ:\e[97m $url_rabbitmq\e[0m"
    echo ""
    
    ## Informação do Usuario do RabbitMQ
    echo -e "\e[33mUsario:\e[97m $user_rabbitmq\e[0m"
    echo ""
    
    ## Informação da Senha do RabbitMQ
    echo -e "\e[33mSenha:\e[97m $pass_rabbitmq\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_rabbitmq

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done
## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO RABBITMQ \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria RabbitMQ iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO RABBITMQ \e[33m[2/3]\e[0m"
echo ""
sleep 1

#Key aleatória cookie
key_cookie=$(openssl rand -hex 16)

## Criando a stack rabbitmq.yaml
cat > rabbitmq${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  rabbitmq${1:+_$1}:
    image: rabbitmq:management
    command: rabbitmq-server

    hostname: rabbitmq

    volumes:
      - rabbitmq${1:+_$1}_data:/var/lib/rabbitmq

    networks:
      - $nome_rede_interna
    #ports:
    #  - 5672:5672
    #  - 15672:15672

    environment:
    ## 🔑 Dados de acesso
      RABBITMQ_DEFAULT_USER: $user_rabbitmq
      RABBITMQ_DEFAULT_PASS: $pass_rabbitmq

    ## 🔐 Key para os Cookies
      RABBITMQ_ERLANG_COOKIE: $key_cookie
      
    ## 📦 VHost padrão
      RABBITMQ_DEFAULT_VHOST: "/"

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.rabbitmq${1:+_$1}.rule=Host(\`$url_rabbitmq\`)
        - traefik.http.routers.rabbitmq${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.rabbitmq${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.rabbitmq${1:+_$1}.service=rabbitmq${1:+_$1}
        - traefik.http.services.rabbitmq${1:+_$1}.loadbalancer.server.port=15672

## --------------------------- ORION --------------------------- ##

volumes:
  rabbitmq${1:+_$1}_data:
    external: true

networks:
  $nome_rede_interna:
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do RabbitMQ"
fi
STACK_NAME="rabbitmq${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c rabbitmq.yaml rabbitmq > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do RabbitMQ"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull rabbitmq:management

## Usa o serviço wait_stack "pgadmin_4" para verificar se o serviço esta online
wait_stack rabbitmq${1:+_$1}_rabbitmq${1:+_$1}

telemetria RabbitMQ finalizado

cd dados_vps

ip_vps=$(curl -s ifconfig.me)

cat > dados_rabbitmq${1:+_$1} <<EOL
[ RABBITMQ ]

Dominio do RabbitMq: $url_rabbitmq

Usuario: $user_rabbitmq

Senha: $pass_rabbitmq

URL: amqp://$user_rabbitmq:$pass_rabbitmq@rabbitmq:5672
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ RABBITMQ ]\e[0m"
echo ""
echo -e "\e[33mDominio:\e[97m https://$url_rabbitmq\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_rabbitmq\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_rabbitmq\e[0m"
echo ""

echo -e "\e[33mURL:\e[97m amqp://$user_rabbitmq:$pass_rabbitmq@rabbitmq:5672\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗   ██╗██████╗ ████████╗██╗███╗   ███╗███████╗    ██╗  ██╗██╗   ██╗███╗   ███╗ █████╗ 
## ██║   ██║██╔══██╗╚══██╔══╝██║████╗ ████║██╔════╝    ██║ ██╔╝██║   ██║████╗ ████║██╔══██╗
## ██║   ██║██████╔╝   ██║   ██║██╔████╔██║█████╗      █████╔╝ ██║   ██║██╔████╔██║███████║
## ██║   ██║██╔═══╝    ██║   ██║██║╚██╔╝██║██╔══╝      ██╔═██╗ ██║   ██║██║╚██╔╝██║██╔══██║
## ╚██████╔╝██║        ██║   ██║██║ ╚═╝ ██║███████╗    ██║  ██╗╚██████╔╝██║ ╚═╝ ██║██║  ██║
##  ╚═════╝ ╚═╝        ╚═╝   ╚═╝╚═╝     ╚═╝╚══════╝    ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝
                                                                                        
ferramenta_uptimekuma() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_uptimekuma

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio do uptime kuma
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Uptime Kuma (ex: uptimekuma.oriondesign.art.br): \e[0m" && read -r url_uptimekuma
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_uptimekuma
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação do Dominio do uptimekuma
    echo -e "\e[33mDominio do Uptime Kuma:\e[97m $url_uptimekuma\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_mongodb

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO UPTIME KUMA \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria "Uptime Kuma" "iniciado"

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO UPTIME KUMA \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack uptimekuma.yaml
cat > uptimekuma${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  uptimekuma${1:+_$1}:
    image: louislam/uptime-kuma:latest

    volumes:
      - uptimekuma${1:+_$1}:/app/data

    networks:
      - $nome_rede_interna
    
    environment:
    ## 🌐 Configuração de Timezone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.uptimekuma${1:+_$1}.rule=Host(\`$url_uptimekuma\`)
        - traefik.http.routers.uptimekuma${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.uptimekuma${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.uptimekuma${1:+_$1}.loadBalancer.server.port=3001
        - traefik.http.routers.uptimekuma${1:+_$1}.service=uptimekuma${1:+_$1}

## --------------------------- ORION --------------------------- ##

volumes:
  uptimekuma${1:+_$1}:
    external: true
    name: uptimekuma${1:+_$1}

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Uptime Kuma"
fi
STACK_NAME="uptimekuma${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c uptimekuma.yaml uptimekuma #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Uptime Kuma"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull louislam/uptime-kuma:latest

## Usa o serviço wait_stack "uptimekuma" para verificar se o serviço esta online
wait_stack uptimekuma${1:+_$1}_uptimekuma${1:+_$1}

telemetria "Uptime Kuma" "finalizado"

cd dados_vps

ip_vps=$(curl -s ifconfig.me)

cat > dados_uptimekuma${1:+_$1} <<EOL
[ UPTIME KUMA ]

Dominio do Uptime Kuma: $url_uptimekuma

Usuario: Precisa criar dentro do Uptime Kuma

Senha: Precisa criar dentro do Uptime Kuma

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ UPTIME KUMA ] \e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_uptimekuma\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar dentro do Uptime Kuma\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar dentro do Uptime Kuma\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ █████╗ ██╗      ██████╗ ██████╗ ███╗   ███╗
## ██╔════╝██╔══██╗██║     ██╔════╝██╔═══██╗████╗ ████║
## ██║     ███████║██║     ██║     ██║   ██║██╔████╔██║
## ██║     ██╔══██║██║     ██║     ██║   ██║██║╚██╔╝██║
## ╚██████╗██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚═╝ ██║
##  ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝
                                                    
ferramenta_calcom() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_calcom

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o dominio para o Cal (ex: calcom.oriondesign.art.br): \e[0m" && read -r url_calcom
    echo ""
    
    ## Pergunta o email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_calcom
    echo ""

    ## Pergunta o Ususario SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuario para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_calcom
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_calcom
    echo ""
    
    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_calcom
    echo ""
    
    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_calcom
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_calcom
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Cal.com\e[97m $url_calcom\e[0m"
    echo ""
    
    ## Informação sobre Email SMTP
    echo -e "\e[33mEmail SMTP:\e[97m $email_calcom\e[0m"
    echo ""

    ## Informação sobre Email SMTP
    echo -e "\e[33mUser SMTP:\e[97m $user_calcom\e[0m"
    echo ""    
    
    ## Informação sobre Senha SMTP
    echo -e "\e[33mSenha SMTP:\e[97m $senha_email_calcom\e[0m"
    echo ""
    
    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP:\e[97m $smtp_email_calcom\e[0m"
    echo ""
    
    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_calcom\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_calcom

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO CALCOM \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Calcom iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "calcom${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "calcom${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO CAL.COM \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando key aleatória
secret=$(openssl rand -hex 16)
secret2=$(openssl rand -hex 16)

## Criando a stack calcom.yaml
cat > calcom${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  calcom${1:+_$1}_app:
    image: calcom/cal.com:latest

    networks:
      - $nome_rede_interna

    environment:
    ## 🔧 Configuração da aplicação
      - NODE_ENV=production
      - NEXT_PUBLIC_DISABLE_SIGNUP=false ## false = novas inscrições permitidas | true = novas incrições fechadas
      - NEXT_PUBLIC_APP_NAME=Cal.com
      - NEXT_PUBLIC_COMPANY_NAME=Cal.com, Inc.
      - NEXT_PUBLIC_SINGLE_ORG_SLUG=Calcom TEST
      - CALCOM_TELEMETRY_DISABLED=1
      - TASKER_ENABLE_WEBHOOKS=0
      - TASKER_ENABLE_EMAILS=0
      - TZ=America/Sao_Paulo

    ## 🌐 Configuração de URLs
      - NEXT_PUBLIC_WEBAPP_URL=https://$url_calcom
      - NEXTAUTH_URL=https://$url_calcom
      - NEXT_PUBLIC_CONSOLE_URL=https://$url_calcom
      - NEXT_PUBLIC_WEBSITE_URL=https://$url_calcom

    ## 🗄️ Configuração do Postgres
      - DATABASE_HOST=postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/calcom${1:+_$1}
      - DATABASE_DIRECT_URL=postgresql://postgres:$senha_postgres@postgres:5432/calcom${1:+_$1}

    ## 📧 Configurações de Email e SMTP
      - NEXT_PUBLIC_SUPPORT_MAIL_ADDRESS=$email_calcom
      - EMAIL_FROM=$email_calcom
      - EMAIL_SERVER_HOST=$smtp_email_calcom
      - EMAIL_SERVER_PORT=$porta_smtp_calcom
      - EMAIL_SERVER_USER=$user_calcom
      - EMAIL_SERVER_PASSWORD=$senha_email_calcom

    ## 🔐 Encrypition
      - NEXTAUTH_SECRET=$secret 
      - CALENDSO_ENCRYPTION_KEY=$secret2
  
    ## 🔗 Integração com Google (Calendario & Meet)
      #-GOOGLE_LOGIN_ENABLED=false
      #-GOOGLE_API_CREDENTIALS=

    ## 🔗 Integração com FromBricks
      #-NEXT_PUBLIC_FORMBRICKS_HOST_URL=https://app.formbricks.com
      #-NEXT_PUBLIC_FORMBRICKS_ENVIRONMENT_ID=
      #-FORMBRICKS_FEEDBACK_SURVEY_ID=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.calcom${1:+_$1}_app.rule=Host(\`$url_calcom\`) && PathPrefix(\`/\`)
        - traefik.http.routers.calcom${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.calcom${1:+_$1}_app.priority=1
        - traefik.http.routers.calcom${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.calcom${1:+_$1}_app.service=calcom${1:+_$1}_app
        - traefik.http.services.calcom${1:+_$1}_app.loadbalancer.server.port=3000
        - traefik.http.services.calcom${1:+_$1}_app.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do CalCom"
fi
STACK_NAME="calcom${1:+_$1}"
stack_editavel # > /dev/null 2>&1

telemetria Calcom finalizado
#docker stack deploy --prune --resolve-image always -c calcom.yaml calcom  > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do CalCom"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull calcom/cal.com:v4.7.8

## Usa o serviço wait_stack "calcom" para verificar se o serviço esta online
wait_stack calcom${1:+_$1}_calcom${1:+_$1}

cd dados_vps

cat > dados_calcom${1:+_$1} <<EOL
[ CAL.COM ]

Dominio do CalCom: $url_calcom

Usuario: Precisa criar dentro do Calcom

Senha: Precisa criar dentro do Calcom

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ CAL.COM ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_calcom\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar dentro do Calcom\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar dentro do Calcom\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ███╗ █████╗ ██╗   ██╗████████╗██╗ ██████╗
## ████╗ ████║██╔══██╗██║   ██║╚══██╔══╝██║██╔════╝
## ██╔████╔██║███████║██║   ██║   ██║   ██║██║     
## ██║╚██╔╝██║██╔══██║██║   ██║   ██║   ██║██║     
## ██║ ╚═╝ ██║██║  ██║╚██████╔╝   ██║   ██║╚██████╗
## ╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝
                                                
ferramenta_mautic() {

## Verifica os recursos
recursos 2 2 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_mautic

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o Mautic (ex: mautic.oriondesign.art.br): \e[0m" && read -r url_mautic
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_mautic
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Mautic:\e[97m $url_mautic\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_mautic

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MAUTIC \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Mautic iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/4]\e[0m"
echo ""
sleep 1

dados

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "mautic${1:+_$1}"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "mautic${1:+_$1}"
    fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO MAUTIC \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack mautic.yaml
cat > mautic${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  mautic_web${1:+_$1}:
    image: mautic/mautic:5.2.8-apache ## Versão do Mautic

    volumes:
      - mautic${1:+_$1}_config:/var/www/html/config
      - mautic${1:+_$1}_docroot:/var/www/html/docroot
      - mautic${1:+_$1}_media:/var/www/html/docroot/media
      - mautic${1:+_$1}_logs:/var/www/html/var/logs
      - mautic${1:+_$1}_cron:/opt/mautic/cron

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Url de acesso
      - MAUTIC_URL=https://$url_mautic

    ## 🗄️ Dados MySQL
      - MAUTIC_DB_NAME=mautic${1:+_$1}
      - MAUTIC_DB_HOST=mysql
      - MAUTIC_DB_PORT=3306
      - MAUTIC_DB_USER=root
      - MAUTIC_DB_PASSWORD=$senha_mysql

    ## 🔧 Configurações
      - MAUTIC_TRUSTED_PROXIES=["0.0.0.0/0"]
      - DOCKER_MAUTIC_ROLE=mautic_web
      - DOCKER_MAUTIC_WORKERS_CONSUME_EMAIL=2
      - DOCKER_MAUTIC_WORKERS_CONSUME_HIT=2
      - DOCKER_MAUTIC_WORKERS_CONSUME_FAILED=2

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 2048M
      labels:
        - traefik.enable=true
        - traefik.http.routers.mautic${1:+_$1}.rule=Host(\`$url_mautic\`) # substitua SeuDominio.com.br pelo seu domínio
        - traefik.http.services.mautic${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.mautic${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.mautic${1:+_$1}.service=mautic${1:+_$1}
        - traefik.http.routers.mautic${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.mautic${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  mautic_worker${1:+_$1}:
    image: mautic/mautic:5.2.8-apache ## Versão do Mautic

    volumes:
      - mautic${1:+_$1}_config:/var/www/html/config
      - mautic${1:+_$1}_docroot:/var/www/html/docroot
      - mautic${1:+_$1}_media:/var/www/html/docroot/media
      - mautic${1:+_$1}_logs:/var/www/html/var/logs
      - mautic${1:+_$1}_cron:/opt/mautic/cron

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Url de acesso
      - MAUTIC_URL=https://$url_mautic

    ## 🗄️ Dados MySQL
      - MAUTIC_DB_NAME=mautic${1:+_$1}
      - MAUTIC_DB_HOST=mysql
      - MAUTIC_DB_PORT=3306
      - MAUTIC_DB_USER=root
      - MAUTIC_DB_PASSWORD=$senha_mysql

    ## 🔧 Configurações
      - MAUTIC_TRUSTED_PROXIES=["0.0.0.0/0"]
      - DOCKER_MAUTIC_ROLE=mautic_web
      - DOCKER_MAUTIC_WORKERS_CONSUME_EMAIL=2
      - DOCKER_MAUTIC_WORKERS_CONSUME_HIT=2
      - DOCKER_MAUTIC_WORKERS_CONSUME_FAILED=2

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

  mautic_cron${1:+_$1}:
    image: mautic/mautic:5.2.8-apache ## Versão do Mautic

    volumes:
      - mautic${1:+_$1}_config:/var/www/html/config
      - mautic${1:+_$1}_docroot:/var/www/html/docroot
      - mautic${1:+_$1}_media:/var/www/html/docroot/media
      - mautic${1:+_$1}_logs:/var/www/html/var/logs
      - mautic${1:+_$1}_cron:/opt/mautic/cron

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Url de acesso
      - MAUTIC_URL=https://$url_mautic

    ## 🗄️ Dados MySQL
      - MAUTIC_DB_NAME=mautic${1:+_$1}
      - MAUTIC_DB_HOST=mysql
      - MAUTIC_DB_PORT=3306
      - MAUTIC_DB_USER=root
      - MAUTIC_DB_PASSWORD=$senha_mysql

    ## 🔧 Configurações
      - MAUTIC_TRUSTED_PROXIES=["0.0.0.0/0"]
      - DOCKER_MAUTIC_ROLE=mautic_web
      - DOCKER_MAUTIC_WORKERS_CONSUME_EMAIL=2
      - DOCKER_MAUTIC_WORKERS_CONSUME_HIT=2
      - DOCKER_MAUTIC_WORKERS_CONSUME_FAILED=2

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

## --------------------------- ORION --------------------------- ##

volumes:
  mautic${1:+_$1}_config:
    external: true
    name: mautic${1:+_$1}_config
  mautic${1:+_$1}_docroot:
    external: true
    name: mautic${1:+_$1}_docroot
  mautic${1:+_$1}_media:
    external: true
    name: mautic${1:+_$1}_media
  mautic${1:+_$1}_logs:
    external: true
    name: mautic${1:+_$1}_logs
  mautic${1:+_$1}_cron:
    external: true
    name: mautic${1:+_$1}_cron

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Mautic"
fi
STACK_NAME="mautic${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c mautic.yaml mautic > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Mautic"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull mautic/mautic:5.2.8-apache

## Usa o serviço wait_stack "mautic" para verificar se o serviço esta online
wait_stack mautic${1:+_$1}_mautic_web${1:+_$1} mautic${1:+_$1}_mautic_worker${1:+_$1} mautic${1:+_$1}_mautic_cron${1:+_$1}

telemetria Mautic finalizado

cd dados_vps

cat > dados_mautic${1:+_$1} <<EOL
[ MAUTIC 5 ]

Dominio do Mautic: $url_mautic

Email: Precisa de criar no primeiro acesso do Mautic

Senha: Precisa de criar no primeiro acesso do Mautic

Database Name: mautic${1:+_$1}

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ MAUTIC 5 ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_mautic\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa de criar no primeiro acesso do Mautic\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar no primeiro acesso do Mautic\e[0m"
echo ""

echo -e "\e[33mDatabase Name:\e[97m mautic${1:+_$1}\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗ ██████╗ ██████╗ ███████╗███╗   ███╗██╗████████╗██╗  ██╗
## ██╔══██╗██╔══██╗██╔══██╗██╔════╝████╗ ████║██║╚══██╔══╝██║  ██║
## ███████║██████╔╝██████╔╝███████╗██╔████╔██║██║   ██║   ███████║
## ██╔══██║██╔═══╝ ██╔═══╝ ╚════██║██║╚██╔╝██║██║   ██║   ██╔══██║
## ██║  ██║██║     ██║     ███████║██║ ╚═╝ ██║██║   ██║   ██║  ██║
## ╚═╝  ╚═╝╚═╝     ╚═╝     ╚══════╝╚═╝     ╚═╝╚═╝   ╚═╝   ╚═╝  ╚═╝
                                                               
ferramenta_appsmith() {

## Verifica os recursos
recursos 2 4 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_appsmith

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Appsmith (ex: appsmith.oriondesign.art.br): \e[0m" && read -r url_appsmith
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_appsmith
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Appsmith\e[97m $url_appsmith\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_appsmith

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO APPSMITH \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Appsmith iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO APPSMITH \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando uma Encryption Key Aleatória
secret=$(openssl rand -hex 16)

## Criando a stack appsmith.yaml
cat > appsmith${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  appsmith${1:+_$1}:
    image: appsmith/appsmith-ee:latest

    volumes:
      - appsmith${1:+_$1}_data:/appsmith-stacks

    networks:
      - $nome_rede_interna

    environment:
    ## 🌐 Url Appsmith
      - APPSMITH_CUSTOM_DOMAIN=https://$url_appsmith

    ## 🔐 Ativar/Desativar Novas Inscrições
      - APPSMITH_SIGNUP_DISABLED=false
      - APPSMITH_FORM_LOGIN_DISABLED=false
    
    ## 👀 Desativar telemetria
      - APPSMITH_DISABLE_TELEMETRY=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.appsmith${1:+_$1}.rule=Host(\`$url_appsmith\`)
        - traefik.http.routers.appsmith${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.appsmith${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.appsmith${1:+_$1}.service=appsmith${1:+_$1}
        - traefik.http.services.appsmith${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.services.appsmith${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  appsmith${1:+_$1}_data:
    external: true
    name: appsmith${1:+_$1}_data

networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Appsmith"
fi
STACK_NAME="appsmith${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c appsmith.yaml appsmith  > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Appsmith"
#fi


## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull appsmith/appsmith-ee:latest

## Usa o serviço wait_stack "nocobase" para verificar se o serviço esta online
wait_stack appsmith${1:+_$1}_appsmith${1:+_$1}

telemetria Appsmith finalizado

cd dados_vps

cat > dados_appsmith${1:+_$1} <<EOL
[ APPSMITH ]

Dominio do Appsmith: https://$url_nocobase

Usuario: Precisa criar no primeiro acesso do Appsmith

Senha: Precisa criar no primeiro acesso do Appsmith
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ APPSMITH ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_appsmith\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Appsmith\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Appsmith\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗ ██████╗  █████╗ ███╗   ██╗████████╗
## ██╔═══██╗██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══██╔══╝
## ██║   ██║██║  ██║██████╔╝███████║██╔██╗ ██║   ██║   
## ██║▄▄ ██║██║  ██║██╔══██╗██╔══██║██║╚██╗██║   ██║   
## ╚██████╔╝██████╔╝██║  ██║██║  ██║██║ ╚████║   ██║   
##  ╚══▀▀═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   
                                                    
ferramenta_qdrant() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_qdrant

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    read -r ip _ <<<$(hostname -I)
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite dominio para o Qdrant (ex: qdrant.oriondesign.art.br): \e[0m" && read -r url_qdrant
    echo ""
    
    ## Pergunta quandos nodes deseja
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite quantos Nodes você deseja (recomendado: 5, minimo: 1): \e[0m" && read -r nodes_qdrant
    echo ""

    key_qdrant=$(openssl rand -hex 16)
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_qdrant
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Qdrant:\e[97m $url_qdrant\e[0m"
    echo ""
    
    ## Informação sobre quantidade de nodes
    echo -e "\e[33mQuantidade de Nodes:\e[97m $nodes_qdrant\e[0m"
    echo ""

    ## Informação sobre Apikey
    echo -e "\e[33mApikey:\e[97m $key_qdrant\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_qdrant

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO QDRANT \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria QDrant iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO QDRANT \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando o arquivo qdrant.yaml
suffix="${1:+_$1}"
filename="qdrant${suffix}.yaml"
stack_name="${stack_name:-${filename%.yaml}}"

cat <<EOL > $filename
version: "3.7"
services:

EOL

containers_qdrant=""

for ((i=0; i< $nodes_qdrant; i++)); do
  node_name="qdrant${suffix}_node_$i"
  volume_name="qdrant${suffix}_data_$i"
  uri_node="qdrant${suffix}_node_$i"
  uri_node_0="qdrant${suffix}_node_0"
  
  # Nome completo do serviço no Docker Swarm (stack_name + node_name)
  service_full_name="${stack_name}_${node_name}"
  
  # Acumula os nomes dos containers com o nome da stack
  if [ -z "$containers_qdrant" ]; then
    containers_qdrant="$service_full_name"
  else
    containers_qdrant="$containers_qdrant $service_full_name"
  fi

  # Adiciona comentário antes do serviço (apenas no primeiro ou antes de cada serviço subsequente)
  if ((i == 0)); then
    cat <<EOL >> $filename
## --------------------------- ORION --------------------------- ##

  $node_name:
    image: qdrant/qdrant:latest ## Versão do Qdrant
EOL
  else
    cat <<EOL >> $filename
  $node_name:
    image: qdrant/qdrant:latest ## Versão do Qdrant
EOL
  fi

  ## Command - diferente para node 0 e outros
  if ((i == 0)); then
    echo "    command: ./qdrant --uri 'http://$uri_node_0:6335'" >> $filename
  else
    sleep_time=$((10 + i * 3))
    echo "    command: bash -c \"sleep $sleep_time && ./qdrant --bootstrap 'http://$uri_node_0:6335' --uri 'http://$uri_node:6335'\"" >> $filename
  fi

  cat <<EOL >> $filename

    volumes:
      - $volume_name:/qdrant/storage

    networks:
      - $nome_rede_interna
EOL

  ## Ports apenas no node 0 (comentados)
  if ((i == 0)); then
    cat <<EOL >> $filename
    ## Descomente as linhas abaixo para usar via ip:porta
    # ports:
    #   - "6333:6333"  # HTTP REST API
    #   - "6334:6334"  # gRPC API
EOL
  fi

  cat <<EOL >> $filename

    environment:
      - QDRANT__SERVICE__GRPC_PORT=6334
      - QDRANT__CLUSTER__ENABLED=true
      - QDRANT__CLUSTER__P2P__PORT=6335
      - QDRANT__CLUSTER__CONSENSUS__MAX_MESSAGE_QUEUE_SIZE=5000
      - QDRANT__LOG_LEVEL=INFO
      - QDRANT__SERVICE__API_KEY=$key_qdrant

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.3"
          memory: 1024M
EOL

  ## Labels do Traefik apenas no node 0
  if ((i == 0)); then
    cat <<EOL >> $filename
      labels:
        - traefik.enable=true
        - traefik.http.routers.qdrant${suffix}.rule=Host(\`$url_qdrant\`)
        - traefik.http.services.qdrant${suffix}.loadbalancer.server.port=6333
        - traefik.http.routers.qdrant${suffix}.service=qdrant${suffix}
        - traefik.http.routers.qdrant${suffix}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.qdrant${suffix}.entrypoints=websecure
        - traefik.http.routers.qdrant${suffix}.tls=true
EOL
  fi

  # Adiciona comentário e linha em branco antes do próximo serviço (exceto no último)
  if ((i < $nodes_qdrant - 1)); then
    cat <<EOL >> $filename

## --------------------------- ORION --------------------------- ##

EOL
  fi
done

cat <<EOL >> $filename

## --------------------------- ORION --------------------------- ##

volumes:
EOL

for ((i=0; i< $nodes_qdrant; i++)); do
  volume_name="qdrant${suffix}_data_$i"
  cat <<EOL >> $filename
  $volume_name:
    external: true
    name: $volume_name
EOL
done

cat <<EOL >> $filename

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Qdrant"
fi

STACK_NAME="qdrant${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c qdrant.yaml qdrant  > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Qdrant"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Usa o serviço wait_stack "qdrant" para verificar se o serviço esta online
wait_stack $containers_qdrant

telemetria QDrant finalizado

cd dados_vps

cat > dados_qdrant <<EOL
[ QDRANT ]

Dashboard do Qdrant: https://$url_qdrant/dashboard

Rest Url: https://$url_qdrant

Apikey: $key_qdrant
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ QDRANT ]\e[0m"
echo ""

echo -e "\e[33mDashboard:\e[97m https://$url_qdrant/dashboard\e[0m"
echo ""

echo -e "\e[33mRest Url:\e[97m https://$url_qdrant\e[0m"
echo ""

echo -e "\e[33mApikey:\e[97m $key_qdrant\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗    ██╗ ██████╗  ██████╗ ███████╗███████╗██████╗      ██████╗██████╗ ███╗   ███╗
## ██║    ██║██╔═══██╗██╔═══██╗██╔════╝██╔════╝██╔══██╗    ██╔════╝██╔══██╗████╗ ████║
## ██║ █╗ ██║██║   ██║██║   ██║█████╗  █████╗  ██║  ██║    ██║     ██████╔╝██╔████╔██║
## ██║███╗██║██║   ██║██║   ██║██╔══╝  ██╔══╝  ██║  ██║    ██║     ██╔══██╗██║╚██╔╝██║
## ╚███╔███╔╝╚██████╔╝╚██████╔╝██║     ███████╗██████╔╝    ╚██████╗██║  ██║██║ ╚═╝ ██║
##  ╚══╝╚══╝  ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝╚═════╝      ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝
                                                                                   
ferramenta_woofed() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_woofedcrm

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos    
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o WoofedCRM (ex: woofedcrm.oriondesign.art.br): \e[0m" && read -r url_woofed
    echo ""

    ## Pergunta o nome do Usuario do Motor
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -e "$amarelo--> Evite os caracteres especiais: @\!#$ e/ou espaço"
    echo -en "\e[33mDigite o User do MOTOR (ex: oriondesign): \e[0m" && read -r email_admin_woofed
    echo ""

    ## Pergunta o nome do Senha do Motor
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$ e/ou espaço"
    echo -en "\e[33mDigite a Senha do MOTOR (ex: @Senha123_): \e[0m" && read -r senha_email_woofed
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_woofedcrm
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre o dominio
    echo -e "\e[33mDominio:\e[97m $url_woofed\e[0m"
    echo ""

    ## Informação sobre o usuario
    echo -e "\e[33mUser MOTOR:\e[97m $email_admin_woofed\e[0m"
    echo ""

    ## Informação sobre a senha
    echo -e "\e[33mSenha MOTOR:\e[97m $senha_email_woofed\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_woofedcrm

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WOOFED CRM \e[33m[1/6]\e[0m"
echo ""
sleep 1

telemetria WoofedCRM iniciado
dados

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES VECTOR \e[33m[2/6]\e[0m"
echo ""
sleep 1

verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - PgVector já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do PgVector"
    criar_banco_pgvector_da_stack "woofedcrm${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "woofedcrm${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO WOOFED CRM \e[33m[3/6]\e[0m"
echo ""
sleep 1

## Criando uma Encryption Key Aleatória
encryption_key_woofed=$(openssl rand -hex 32)

# Verifica se o arquivo evolution.yaml existe
if [ -f "/root/evolution_v1.yaml" ]; then
    # Extrai os valores do arquivo evolution.yaml e formata no estilo desejado
    EVOLUTION_API_ENDPOINT="- EVOLUTION_API_ENDPOINT=$(grep -oP '(?<=- SERVER_URL=)[^#]*' /root/evolution.yaml | sed 's/ //g')"
    EVOLUTION_API_ENDPOINT_TOKEN="- EVOLUTION_API_ENDPOINT_TOKEN=$(grep -oP '(?<=- AUTHENTICATION_API_KEY=)[^#]*' /root/evolution.yaml | sed 's/ //g')"
else
    # Define os valores padrão se o arquivo não existir
    EVOLUTION_API_ENDPOINT="#- EVOLUTION_API_ENDPOINT="
    EVOLUTION_API_ENDPOINT_TOKEN="#- EVOLUTION_API_ENDPOINT_TOKEN="
fi

## Criando a stack woofedcrm.yaml
cat > woofedcrm${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  woofedcrm${1:+_$1}_web:
    image: douglara/woofedcrm:latest
    command: bash -c "bundle exec rails db:prepare && bundle exec puma -C config/puma.rb"

    volumes:
      - woofedcrm${1:+_$1}_data:/app/storage

    networks:
      - $nome_rede_interna

    environment:
    ## 🌐 Url WoofedCRM
      - FRONTEND_URL=https://$url_woofed
      - SECRET_KEY_BASE=$encryption_key_woofed

    ## 🗣️ Idioma
      - LANGUAGE=pt-BR

    ## 🚫✅ Permitir/Bloquear novas Inscrições
      - ENABLE_USER_SIGNUP=true

    ## 🔑 Credenciais Motor
      - MOTOR_AUTH_USERNAME=$email_admin_woofed
      - MOTOR_AUTH_PASSWORD=$senha_email_woofed

    ## 🔗 Endpoints Evolution API
      $EVOLUTION_API_ENDPOINT ## BaseUrl
      $EVOLUTION_API_ENDPOINT_TOKEN ## Global Api Key

    ## 🕒 Timezone
      - DEFAULT_TIMEZONE=Brasilia

    ## 🤖 Dados OpenAI
      #- OPENAI_API_KEY=

    ## 🧠 Dados PgVector
      - DATABASE_URL=postgres://postgres:$senha_pgvector@pgvector:5432/woofedcrm${1:+_$1}

    ## 🔁 Dados Redis
      - REDIS_URL=redis://redis:6379/0

    ## 💾 Dados Storage
      - ACTIVE_STORAGE_SERVICE=local

    ## 🚀 Modo de Produção
      - RAILS_ENV=production
      - RACK_ENV=production
      - NODE_ENV=production
      - RAILS_LOG_LEVEL=debug

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.woofedcrm${1:+_$1}.rule=Host(\`$url_woofed\`)
        - traefik.http.routers.woofedcrm${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.woofedcrm${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.woofedcrm${1:+_$1}.priority=1
        - traefik.http.routers.woofedcrm${1:+_$1}.service=woofedcrm${1:+_$1}
        - traefik.http.services.woofedcrm${1:+_$1}.loadbalancer.server.port=3000 
        - traefik.http.services.woofedcrm${1:+_$1}.loadbalancer.passHostHeader=true 
        - traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.routers.woofedcrm${1:+_$1}.middlewares=sslheader

## --------------------------- ORION --------------------------- ##

  woofedcrm${1:+_$1}_sidekiq:
    image: douglara/woofedcrm:latest
    command: bundle exec sidekiq -C config/sidekiq.yml

    volumes:
      - woofedcrm${1:+_$1}_data:/app/storage

    networks:
      - $nome_rede_interna

    environment:
    ## 🌐 Url WoofedCRM
      - FRONTEND_URL=https://$url_woofed
      - SECRET_KEY_BASE=$encryption_key_woofed

    ## 🗣️ Idioma
      - LANGUAGE=pt-BR

    ## 🚫✅ Permitir/Bloquear novas Inscrições
      - ENABLE_USER_SIGNUP=true

    ## 🔑 Credenciais Motor
      - MOTOR_AUTH_USERNAME=$email_admin_woofed
      - MOTOR_AUTH_PASSWORD=$senha_email_woofed

    ## 🔗 Endpoints Evolution API
      $EVOLUTION_API_ENDPOINT ## BaseUrl
      $EVOLUTION_API_ENDPOINT_TOKEN ## Global Api Key

    ## 🕒 Timezone
      - DEFAULT_TIMEZONE=Brasilia

    ## 🤖 Dados OpenAI
      #- OPENAI_API_KEY=

    ## 🧠 Dados PgVector
      - DATABASE_URL=postgres://postgres:$senha_pgvector@pgvector:5432/woofedcrm${1:+_$1}

    ## 🔁 Dados Redis
      - REDIS_URL=redis://redis:6379/0

    ## 💾 Dados Storage
      - ACTIVE_STORAGE_SERVICE=local

    ## 🚀 Modo de Produção
      - RAILS_ENV=production
      - RACK_ENV=production
      - NODE_ENV=production
      - RAILS_LOG_LEVEL=debug
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  woofedcrm${1:+_$1}_job:
    image: douglara/woofedcrm:latest
    command: bundle exec good_job

    volumes:
      - woofedcrm${1:+_$1}_data:/app/storage

    networks:
      - $nome_rede_interna

    environment:
    ## 🌐 Url WoofedCRM
      - FRONTEND_URL=https://$url_woofed
      - SECRET_KEY_BASE=$encryption_key_woofed

    ## 🗣️ Idioma
      - LANGUAGE=pt-BR

    ## 🚫✅ Permitir/Bloquear novas Inscrições
      - ENABLE_USER_SIGNUP=true

    ## 🔑 Credenciais Motor
      - MOTOR_AUTH_USERNAME=$email_admin_woofed
      - MOTOR_AUTH_PASSWORD=$senha_email_woofed

    ## 🔗 Endpoints Evolution API
      $EVOLUTION_API_ENDPOINT ## BaseUrl
      $EVOLUTION_API_ENDPOINT_TOKEN ## Global Api Key

    ## 🕒 Timezone
      - DEFAULT_TIMEZONE=Brasilia

    ## 🤖 Dados OpenAI
      #- OPENAI_API_KEY=

    ## 🧠 Dados PgVector
      - DATABASE_URL=postgres://postgres:$senha_pgvector@pgvector:5432/woofedcrm${1:+_$1}

    ## 🔁 Dados Redis
      - REDIS_URL=redis://redis:6379/0

    ## 💾 Dados Storage
      - ACTIVE_STORAGE_SERVICE=local

    ## 🚀 Modo de Produção
      - RAILS_ENV=production
      - RACK_ENV=production
      - NODE_ENV=production
      - RAILS_LOG_LEVEL=debug

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  woofedcrm${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - woofedcrm${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  woofedcrm${1:+_$1}_data:
    external: true
    name: woofedcrm${1:+_$1}_data
  woofedcrm${1:+_$1}_redis:
    external: true
    name: woofedcrm${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do WoofedCRM"
fi
STACK_NAME="woofedcrm${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c woofedcrm.yaml woofedcrm #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do WoofedCRM"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/6]\e[0m"
wait_30_sec
echo ""
sleep 1

## Baixando imagens:
pull douglara/woofedcrm:latest

## Usa o serviço wait_stack "woofedcrm" para verificar se o serviço esta online
wait_stack woofedcrm${1:+_$1}_woofedcrm${1:+_$1}_web woofedcrm${1:+_$1}_woofedcrm${1:+_$1}_sidekiq woofedcrm${1:+_$1}_woofedcrm${1:+_$1}_job

telemetria WoofedCRM finalizado


## Mensagem de Passo
echo -e "\e[97m• CONFIGURANDO E MIGRANDO BANCO DE DADOS \e[33m[5/6]\e[0m"
echo ""
sleep 1

#MIGRANDO BANCO DE DADOS DO WOOFED CRM
container_name="woofedcrm${1:+_$1}_web"

max_wait_time=1200

wait_interval=60

elapsed_time=0

while [ $elapsed_time -lt $max_wait_time ]; do
  CONTAINER_ID=$(docker ps -q --filter "name=$container_name")
  if [ -n "$CONTAINER_ID" ]; then
    break
  fi
  sleep $wait_interval
  elapsed_time=$((elapsed_time + wait_interval))
done

if [ -z "$CONTAINER_ID" ]; then
  echo "O contêiner não foi encontrado após $max_wait_time segundos."
  exit 1
fi

docker exec -it "$CONTAINER_ID" bundle exec rails db:create > /dev/null 2>&1
if [ $? -eq 0 ]; then
  echo "1/2 - [ OK ] - Executando: bundle exec rails db:create"
else
    echo "1/2- [ OFF ] - Executando: bundle exec rails db:create"
fi
docker exec -it "$CONTAINER_ID" bundle exec rails db:migrate > /dev/null 2>&1
if [ $? -eq 0 ]; then
  echo "2/2 - [ OK ] - Executando: bundle exec rails db:migrate"
else
    echo "2/2- [ OFF ] - Executando: bundle exec rails db:migrate"
fi
echo ""

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[6/6]\e[0m"
echo ""
sleep 1

## Usa o serviço wait_stack "woofedcrm" para verificar se o serviço esta online
wait_stack woofedcrm${1:+_$1}_woofedcrm${1:+_$1}_web woofedcrm${1:+_$1}_woofedcrm${1:+_$1}_sidekiq woofedcrm${1:+_$1}_woofedcrm${1:+_$1}_job

cd dados_vps

cat > dados_woofedcrm${1:+_$1} <<EOL
[ WOOFED CRM ]

Dominio do WoofedCRM: https://$url_woofed

Email: Precisa criar dentro do WoofedCRM

Senha: Precisa criar dentro do WoofedCRM

Acesso ao Motor: https://$url_woofed/motor_admin

Usuario do Motor: $email_admin_woofed

Senha do Motor: $senha_email_woofed
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WOOFED CRM ]\e[0m"
echo ""

echo -e "\e[97mDominio:\e[33m https://$url_woofed\e[0m"
echo ""

echo -e "\e[97mEmail:\e[33m Precisa criar dentro do WoofedCRM\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m Precisa criar dentro do WoofedCRM\e[0m"
echo ""

echo -e "\e[97mURL MOTOR:\e[33m https://$url_woofed/motor_admin\e[0m"
echo ""

echo -e "\e[97mUser MOTOR:\e[33m $email_admin_woofed\e[0m"
echo ""

echo -e "\e[97mSenha MOTOR:\e[33m $senha_email_woofed\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗ ██████╗ ██████╗ ███╗   ███╗██████╗ ██████╗ ██╗ ██████╗██╗  ██╗███████╗
## ██╔════╝██╔═══██╗██╔══██╗████╗ ████║██╔══██╗██╔══██╗██║██╔════╝██║ ██╔╝██╔════╝
## █████╗  ██║   ██║██████╔╝██╔████╔██║██████╔╝██████╔╝██║██║     █████╔╝ ███████╗
## ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║██╔══██╗██╔══██╗██║██║     ██╔═██╗ ╚════██║
## ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║██████╔╝██║  ██║██║╚██████╗██║  ██╗███████║
## ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚═════╝ ╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝
                                                                               
ferramenta_formbricks() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_formbricks

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Formbricks (ex: formbricks.oriondesign.art.br): \e[0m" && read -r url_formbricks
    echo ""
    
    ## Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite um Email para o SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_formbricks
    echo ""

    ## Pergunta o User SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuario do SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_formbricks
    echo ""
    
    ## Pergunta a Senha SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do email (ex: @Senha123_): \e[0m" && read -r senha_formbricks
    echo ""
    
    ## Pergunta o Host SMTP
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do email (ex: smtp.hostinger.com): \e[0m" && read -r host_formbricks
    echo ""
    
    ## Pergunta a Porta SMTP 
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a Porta SMTP do email (ex: 465): \e[0m" && read -r porta_formbricks
    echo ""
    
    if [ "$porta_formbricks" -eq 465 ] || [ "$porta_formbricks" -eq 25 ]; then
        ssl_formbricks=1
    else
        ssl_formbricks=0
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_formbricks
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio:\e[97m $url_formbricks\e[0m"
    echo ""
    
    ## Informação sobre Email
    echo -e "\e[33mEmail SMTP:\e[97m $email_formbricks\e[0m"
    echo ""

    ## Informação sobre UserSMTP
    echo -e "\e[33mUser SMTP:\e[97m $user_smtp_formbricks\e[0m"
    echo ""
    
    ## Informação sobre Senha
    echo -e "\e[33mSenha SMTP:\e[97m $senha_formbricks\e[0m"
    echo ""
    
    ## Informação sobre Host
    echo -e "\e[33mHost SMTP:\e[97m $host_formbricks\e[0m"
    echo ""
    
    ## Informação sobre Porta
    echo -e "\e[33mPorta SMTP:\e[97m $porta_formbricks\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_formbricks

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO FORMBRICKS \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria Formbricks iniciado

## Nada nada nada.. só para aparecer a mensagem de passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO PGVECTOR \e[33m[2/5]\e[0m"
echo ""
sleep 1

verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - PgVector já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do PgVector"
    criar_banco_pgvector_da_stack "formbricks${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "formbricks${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[3/5]\e[0m"
echo ""
sleep 1

pegar_senha_minio
minio.bucket formbricks${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
    echo ""
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi

echo ""
## Mensagem de Passo
echo -e "\e[97m• INSTALANDO FORMBRICKS \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Gera keys aleatórias
encryption_key_form=$(openssl rand -hex 32)
next_key_form=$(openssl rand -hex 32)
cron_key_form=$(openssl rand -hex 32)

## Criando a stack formbricks.yaml
cat > formbricks${1:+_$1}.yaml <<-EOF
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  formbricks${1:+_$1}_app:
    image: ghcr.io/formbricks/formbricks:latest

    volumes:
      - formbricks${1:+_$1}_data:/home/nextjs/apps/web/uploads/

    networks:
      - $nome_rede_interna

    environment:
      ## Url da aplicação
      - WEBAPP_URL=https://$url_formbricks
      - NEXTAUTH_URL=https://$url_formbricks

      ## Banco de dados Postgres
      - DATABASE_URL=postgresql://postgres:$senha_pgvector@pgvector:5432/formbricks${1:+_$1}?schema=public

      ## Licença Enterprise ou Self-hosting
      ## Solicitar licenta Self-hosting --> https://oriondesign.art.br/formbricks_licence/ <-- ##
      - ENTERPRISE_LICENSE_KEY=

      ## Keys aleatórias 32 caracteres
      - ENCRYPTION_KEY=$encryption_key_form
      - NEXTAUTH_SECRET=$next_key_form
      - CRON_SECRET=$cron_key_form

      ## Dados do SMTP
      - MAIL_FROM=$email_formbricks
      - SMTP_HOST=$host_formbricks
      - SMTP_PORT=$porta_formbricks
      - SMTP_SECURE_ENABLED=$ssl_formbricks #(0= false | 1= true)
      - SMTP_USER=$user_smtp_formbricks
      - SMTP_PASSWORD=$senha_formbricks

      ## Ativar/Desativar registros e convites (0= false | 1= true)
      - SIGNUP_DISABLED=0
      - INVITE_DISABLED=0
      - EMAIL_VERIFICATION_DISABLED=0
      - PASSWORD_RESET_DISABLED=0

    ## Dados do S3
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_REGION=eu-south
      - S3_BUCKET_NAME=formbricks${1:+-$1}
      - S3_ENDPOINT_URL=https://$url_s3
      - S3_FORCE_PATH_STYLE=1
    
    ## Dados do Redis
      - REDIS_URL=redis://formbricks${1:+_$1}_redis:6379

      ## Dados do Formbricks (para pesquisa)
      - NEXT_PUBLIC_FORMBRICKS_API_HOST=
      - NEXT_PUBLIC_FORMBRICKS_ENVIRONMENT_ID=
      - NEXT_PUBLIC_FORMBRICKS_ONBOARDING_SURVEY_ID=

      ## Login Google Cloud
      - GOOGLE_AUTH_ENABLED=0
      - GOOGLE_CLIENT_ID=
      - GOOGLE_CLIENT_SECRET=

      ## Google Sheets
      - GOOGLE_SHEETS_CLIENT_ID=
      - GOOGLE_SHEETS_CLIENT_SECRET=
      - GOOGLE_SHEETS_REDIRECT_URL=

      ## Login Github
      - GITHUB_AUTH_ENABLED=0
      - GITHUB_ID=
      - GITHUB_SECRET=

      ## Login Github
      - NOTION_OAUTH_CLIENT_ID=
      - NOTION_OAUTH_CLIENT_SECRET=   
      
      ## Login Airtable
      - AIRTABLE_CLIENT_ID=

      ## Termos e politica de privacidade
      #- PRIVACY_URL=
      #- TERMS_URL=
      #- IMPRINT_URL=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.formbricks${1:+_$1}_app.rule=Host(\`$url_formbricks\`)
        - traefik.http.services.formbricks${1:+_$1}_app.loadbalancer.server.port=3000
        - traefik.http.routers.formbricks${1:+_$1}_app.service=formbricks${1:+_$1}_app
        - traefik.http.routers.formbricks${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.formbricks${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.formbricks${1:+_$1}_app.tls=true

## --------------------------- ORION --------------------------- ##

  formbricks${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - formbricks${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  formbricks${1:+_$1}_data:
    external: true
    name: formbricks${1:+_$1}_data
  formbricks${1:+_$1}_redis:
    external: true
    name: formbricks${1:+_$1}_redis

networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOF
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Formbricks"
fi
STACK_NAME="formbricks${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c formbricks.yaml formbricks > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Formbricks"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest ghcr.io/formbricks/formbricks:latest

## Usa o serviço wait_stack "formbricks" para verificar se o serviço esta online
wait_stack formbricks${1:+_$1}_formbricks${1:+_$1}_redis formbricks${1:+_$1}_formbricks${1:+_$1}_app
wait_30_sec
telemetria Formbricks finalizado

cd dados_vps

cat > dados_formbricks${1:+_$1} <<EOL
[ FORMBRICKS ]

Dominio do Formbricks: https://$url_formbricks

Email: Precisa de criar dentro do Formbricks

Senha: Precisa de criar dentro do Formbricks
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ FORMBRICKS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_formbricks\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa de criar dentro do Formbricks\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar dentro do Formbricks\e[0m"
echo ""
echo "> Aguarde aproximadamente 5 minutos antes de acessar devido à migração em andamento."

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗ ██████╗  ██████╗ ██████╗ ██████╗ ██████╗ 
## ████╗  ██║██╔═══██╗██╔════╝██╔═══██╗██╔══██╗██╔══██╗
## ██╔██╗ ██║██║   ██║██║     ██║   ██║██║  ██║██████╔╝
## ██║╚██╗██║██║   ██║██║     ██║   ██║██║  ██║██╔══██╗
## ██║ ╚████║╚██████╔╝╚██████╗╚██████╔╝██████╔╝██████╔╝
## ╚═╝  ╚═══╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚═════╝ ╚═════╝ 

ferramenta_nocodb() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_nocodb

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o NocoDB (ex: nocodb.oriondesign.art.br): \e[0m" && read -r url_nocodb
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_nocodb
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o NocoDB:\e[97m $url_nocodb\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_nocodb

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO NOCODB \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria NocoDB iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Já sabe né ksk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "nocodb${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "nocodb${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO NOCODB \e[33m[3/4]\e[0m"
echo ""
sleep 1

secret_nocodb=$(openssl rand -hex 16)

## Criando a stack
cat > nocodb${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  nocodb${1:+_$1}_app: 
    image: nocodb/nocodb:latest

    volumes: 
      - nocodb${1:+_$1}_data:/usr/app/data

    networks:
      - $nome_rede_interna

    environment: 
    ## 🌐 Url do Nocobase
      - NC_PUBLIC_URL=https://$url_nocodb

    ## 🐘 Dados Postgres
      - NC_DB=pg://postgres:5432?u=postgres&p=$senha_postgres&d=nocodb${1:+_$1}

    ## 🔗 Dados do redis
      - NC_REDIS_URL=redis://nocodb${1:+_$1}_redis:6379

    ## 👀 Desativar Telemetria
      - NC_DISABLE_TELE=true  

    ## 🔑 Secret Key
      - NC_AUTH_JWT_SECRET=$secret_nocodb

    ## 📧 Dados do SMTP
      #- NC_SMTP_FROM=
      #- NC_SMTP_USERNAMENC_SMTP_USERNAME=
      #- NC_SMTP_HOST=
      #- NC_SMTP_PORT=587
      #- NC_SMTP_SECURE=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.nocodb${1:+_$1}_app.rule=Host(\`$url_nocodb\`)
        - traefik.http.routers.nocodb${1:+_$1}_app.entrypoints=websecure
        - traefik.http.services.nocodb${1:+_$1}_app.loadbalancer.server.port=8080
        - traefik.http.routers.nocodb${1:+_$1}_app.service=nocodb${1:+_$1}_app
        - traefik.http.routers.nocodb${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - com.centurylinklabs.watchtower.enable=true

## --------------------------- ORION --------------------------- ##

  nocodb${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - nocodb${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  nocodb${1:+_$1}_data:
    external: true
    name: nocodb${1:+_$1}_data
  nocodb${1:+_$1}_redis:
    external: true
    name: nocodb${1:+_$1}_redis

networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do NocoDB"
fi
STACK_NAME="nocodb${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c nocodb.yaml nocodb > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do NocoDB"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull nocodb/nocodb:latest

## Usa o serviço wait_nocodb para verificar se o serviço esta online
wait_stack nocodb${1:+_$1}_nocodb${1:+_$1}

telemetria NocoDB finalizado

cd dados_vps

cat > dados_nocodb${1:+_$1} <<EOL
[ NOCODB ]

Dominio do NocoDB: https://$url_nocodb

Usuario: Precisa criar no primeiro acesso do NocoDB

Senha: Precisa criar no primeiro acesso do NocoDB

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ NOCODB ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_nocodb\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do NocoDB\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do NocoDB\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗      █████╗ ███╗   ██╗ ██████╗ ███████╗██╗   ██╗███████╗███████╗
## ██║     ██╔══██╗████╗  ██║██╔════╝ ██╔════╝██║   ██║██╔════╝██╔════╝
## ██║     ███████║██╔██╗ ██║██║  ███╗█████╗  ██║   ██║███████╗█████╗  
## ██║     ██╔══██║██║╚██╗██║██║   ██║██╔══╝  ██║   ██║╚════██║██╔══╝  
## ███████╗██║  ██║██║ ╚████║╚██████╔╝██║     ╚██████╔╝███████║███████╗
## ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝      ╚═════╝ ╚══════╝╚══════╝

ferramenta_langfuse() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_langfuse

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Langfuse (ex: langfuse.oriondesign.art.br): \e[0m" && read -r url_langfuse
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_langfuse
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ARQUIVO_CLICKHOUSE="/root/dados_vps/dados_clickhouse"

    API_CLICKHOUSE=$(grep "API do clickhouse:" "$ARQUIVO_CLICKHOUSE" | cut -d ":" -f2- | xargs)
    USUARIO_CLICKHOUSE=$(grep "Usuario:" "$ARQUIVO_CLICKHOUSE" | cut -d ":" -f2- | xargs)
    SENHA_CLICKHOUSE=$(grep "Senha:" "$ARQUIVO_CLICKHOUSE" | cut -d ":" -f2- | xargs)
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o Langfuse:\e[97m $url_langfuse\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mDominio do ClickHouse:\e[97m $API_CLICKHOUSE\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mUsuario do ClickHouse:\e[97m $USUARIO_CLICKHOUSE\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mSenha do ClickHouse:\e[97m $SENHA_CLICKHOUSE\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_langfuse

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO LANGFUSE \e[33m[1/6]\e[0m"
echo ""
sleep 1

telemetria Langfuse iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/6]\e[0m"
echo ""
sleep 1

## Já sabe né ksk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "langfuse${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "langfuse${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BANCO NO CLICKHOUSE \e[33m[3/6]\e[0m"
echo ""
sleep 1

docker exec -it "$(docker ps --filter 'name=clickhouse' -q)" clickhouse-client -q "CREATE DATABASE langfuse${1:+_$1};" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Banco langfuse${1:+_$1} criado"
else
    echo "1/1 - [ OFF ] - Erro ao criar Banco langfuse${1:+_$1}"
fi

echo ""

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[4/6]\e[0m"
echo ""
sleep 1

pegar_senha_minio
minio.bucket langfuse${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO LANGFUSE \e[33m[5/6]\e[0m"
echo ""
sleep 1

## Criando key Aleatória 64caracteres
key_encryption=$(openssl rand -hex 32)

## Criando key Aleatória 64caracteres
key_secret=$(openssl rand -hex 32)

## Criando key Aleatória 32caracteres
key_salt=$(openssl rand -hex 32)

## Criando a stack langfuse.yaml
cat > langfuse${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  langfuse${1:+_$1}_app:
    image: langfuse/langfuse:latest

    networks:
     - $nome_rede_interna ## Rede interna

    environment:
    ## 🔗 Url do Langfuse
      - NEXTAUTH_URL=https://$url_langfuse

    ## 🚫 Desativar novas incrições
      - NEXT_PUBLIC_SIGN_UP_DISABLED=false

    ## 🔐 Secrets Key
      - ENCRYPTION_KEY=$key_encryption
      - NEXTAUTH_SECRET=$key_secret
      - SALT=$key_salt

    ## 🗄️ Dados Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/langfuse${1:+_$1}
      
    ## 🗄️ Dados do ClickHouse
      - CLICKHOUSE_MIGRATION_URL=clickhouse://clickhouse:9000
      - CLICKHOUSE_URL=$API_CLICKHOUSE
      - CLICKHOUSE_USER=$USUARIO_CLICKHOUSE
      - CLICKHOUSE_PASSWORD=$SENHA_CLICKHOUSE
      - CLICKHOUSE_CLUSTER_ENABLED=false
      - CLICKHOUSE_DB=langfuse${1:+_$1}

    ## 🔁 Dados Redis
      - REDIS_CONNECTION_STRING=redis://langfuse${1:+_$1}_redis:6379

    ## 🗄️ Dados do S3 - Eventos
      - LANGFUSE_S3_EVENT_UPLOAD_ENDPOINT=https://$url_s3
      - LANGFUSE_S3_EVENT_UPLOAD_BUCKET=langfuse${1:+-$1}
      - LANGFUSE_S3_EVENT_UPLOAD_ACCESS_KEY_ID=$S3_ACCESS_KEY
      - LANGFUSE_S3_EVENT_UPLOAD_SECRET_ACCESS_KEY=$S3_SECRET_KEY
      - LANGFUSE_S3_EVENT_UPLOAD_REGION=auto
      - LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE=true
      - LANGFUSE_S3_EVENT_UPLOAD_PREFIX=events/

    ## 🗄️ Dados do S3 - Medias
      - LANGFUSE_S3_MEDIA_UPLOAD_ENDPOINT=https://$url_s3
      - LANGFUSE_S3_MEDIA_UPLOAD_BUCKET=langfuse${1:+-$1}
      - LANGFUSE_S3_MEDIA_UPLOAD_ACCESS_KEY_ID=$S3_ACCESS_KEY
      - LANGFUSE_S3_MEDIA_UPLOAD_SECRET_ACCESS_KEY=$S3_SECRET_KEY
      - LANGFUSE_S3_MEDIA_UPLOAD_REGION=auto
      - LANGFUSE_S3_MEDIA_UPLOAD_FORCE_PATH_STYLE=true
      - LANGFUSE_S3_MEDIA_UPLOAD_PREFIX=media/

    ## 📊 Ativar Telemetria
      - TELEMETRY_ENABLED=false

    ## 🔍 Features experimentais
      - LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES=false

    ## 🔍 Node
      - NODE_ENV=production

    deploy:
      mode: replicated
      replicas: 1
      placement:
          constraints:
            - node.role == manager
      resources:
          limits:
            cpus: '1'
            memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.langfuse${1:+_$1}.rule=Host(\`$url_langfuse\`)
        - traefik.http.routers.langfuse${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.langfuse${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.langfuse${1:+_$1}.service=langfuse${1:+_$1}
        - traefik.http.services.langfuse${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.services.langfuse${1:+_$1}.loadbalancer.server.port=3000

## --------------------------- ORION --------------------------- ##

  langfuse${1:+_$1}_worker:
    image: langfuse/langfuse-worker:latest

    networks:
     - $nome_rede_interna ## Rede interna

    environment:
    ## 🔗 Url do Langfuse
      - NEXTAUTH_URL=https://$url_langfuse

    ## 🚫 Desativar novas incrições
      - NEXT_PUBLIC_SIGN_UP_DISABLED=false

    ## 🔐 Secrets Key
      - ENCRYPTION_KEY=$key_encryption
      - NEXTAUTH_SECRET=$key_secret
      - SALT=$key_salt

    ## 🗄️ Dados Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/langfuse${1:+_$1}
      
    ## 🗄️ Dados do ClickHouse
      - CLICKHOUSE_MIGRATION_URL=clickhouse://clickhouse:9000
      - CLICKHOUSE_URL=$API_CLICKHOUSE
      - CLICKHOUSE_USER=$USUARIO_CLICKHOUSE
      - CLICKHOUSE_PASSWORD=$SENHA_CLICKHOUSE
      - CLICKHOUSE_CLUSTER_ENABLED=false
      - CLICKHOUSE_DB=langfuse${1:+_$1}

    ## 🔁 Dados Redis
      - REDIS_CONNECTION_STRING=redis://langfuse${1:+_$1}_redis:6379

    ## 🗄️ Dados do S3 - Eventos
      - LANGFUSE_S3_EVENT_UPLOAD_ENDPOINT=https://$url_s3
      - LANGFUSE_S3_EVENT_UPLOAD_BUCKET=langfuse${1:+-$1}
      - LANGFUSE_S3_EVENT_UPLOAD_ACCESS_KEY_ID=$S3_ACCESS_KEY
      - LANGFUSE_S3_EVENT_UPLOAD_SECRET_ACCESS_KEY=$S3_SECRET_KEY
      - LANGFUSE_S3_EVENT_UPLOAD_REGION=auto
      - LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE=true
      - LANGFUSE_S3_EVENT_UPLOAD_PREFIX=events/

    ## 🗄️ Dados do S3 - Medias
      - LANGFUSE_S3_MEDIA_UPLOAD_ENDPOINT=https://$url_s3
      - LANGFUSE_S3_MEDIA_UPLOAD_BUCKET=langfuse${1:+-$1}
      - LANGFUSE_S3_MEDIA_UPLOAD_ACCESS_KEY_ID=$S3_ACCESS_KEY
      - LANGFUSE_S3_MEDIA_UPLOAD_SECRET_ACCESS_KEY=$S3_SECRET_KEY
      - LANGFUSE_S3_MEDIA_UPLOAD_REGION=auto
      - LANGFUSE_S3_MEDIA_UPLOAD_FORCE_PATH_STYLE=true
      - LANGFUSE_S3_MEDIA_UPLOAD_PREFIX=media/

    ## 📊 Ativar Telemetria
      - TELEMETRY_ENABLED=false

    ## 🔍 Features experimentais
      - LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES=false

    ## 🔍 Node
      - NODE_ENV=production

    deploy:
      mode: replicated
      replicas: 1
      placement:
          constraints:
            - node.role == manager
      resources:
          limits:
            cpus: '1'
            memory: 1024M

## --------------------------- ORION --------------------------- ##

  langfuse${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - langfuse${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
   langfuse${1:+_$1}_redis:
    external: true
    name: langfuse${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Rede interna
    external: true
    name: $nome_rede_interna ## Rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do langfuse"
fi
STACK_NAME="langfuse${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c langfuse.yaml langfuse > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do langfuse"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[6/6]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest langfuse/langfuse-worker:latest langfuse/langfuse:latest

## Usa o serviço wait_langfuse para verificar se o serviço esta online
wait_stack langfuse${1:+_$1}_langfuse${1:+_$1}_redis langfuse${1:+_$1}_langfuse${1:+_$1}_worker langfuse${1:+_$1}_langfuse${1:+_$1}_app

telemetria Langfuse finalizado

cd dados_vps

cat > dados_langfuse${1:+_$1} <<EOL
[ LANGFUSE ]

Dominio do Langfuse: https://$url_langfuse

Usuario: Precisa criar no primeiro acesso do langfuse

Senha: Precisa criar no primeiro acesso do langfuse

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ LANGFUSE ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_langfuse\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Langfuse\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Langfuse\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ███╗███████╗████████╗ █████╗ ██████╗  █████╗ ███████╗███████╗
## ████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝
## ██╔████╔██║█████╗     ██║   ███████║██████╔╝███████║███████╗█████╗  
## ██║╚██╔╝██║██╔══╝     ██║   ██╔══██║██╔══██╗██╔══██║╚════██║██╔══╝  
## ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║██████╔╝██║  ██║███████║███████╗
## ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝

ferramenta_metabase() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_metabase

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Metabase (ex: metabase.oriondesign.art.br): \e[0m" && read -r url_metabase
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_metabase
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o metabase:\e[97m $url_metabase\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_metabase

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO METABASE \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria MetaBase iniciado
## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Já sabe né ksk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "metabase${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "metabase${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO METABASE \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando key Aleatória 64caracteres
key_secret=$(openssl rand -hex 32)

## Criando key Aleatória 32caracteres
key_salt=$(openssl rand -hex 16)

## Criando a stack metabase.yaml
cat > metabase${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  metabase${1:+_$1}:
    image: metabase/metabase:latest

    volumes:
      - metabase${1:+_$1}_data:/metabase3-data

    networks:
      - $nome_rede_interna

    environment:
    ## 🔗 Url MetaBase
      - MB_SITE_URL=https://$url_metabase
      - MB_REDIRECT_ALL_REQUESTS_TO_HTTPS=true
      - MB_JETTY_PORT=3000
      - MB_JETTY_HOST=0.0.0.0

    ## 🗄️ Dados postgres
      - MB_DB_TYPE=postgres
      - MB_DB_HOST=postgres
      - MB_DB_PORT=5432
      - MB_DB_DBNAME=metabase${1:+_$1}
      - MB_DB_USER=postgres
      - MB_DB_PASS=$senha_postgres
      - MB_DB_MIGRATION_LOCATION=none
      - MB_AUTOMIGRATE=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.metabase${1:+_$1}.rule=Host(\`$url_metabase\`)
        - traefik.http.services.metabase${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.metabase${1:+_$1}.service=metabase${1:+_$1}
        - traefik.http.routers.metabase${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.metabase${1:+_$1}.tls=true
        - traefik.http.routers.metabase${1:+_$1}.tls.certresolver=letsencryptresolver

## --------------------------- ORION --------------------------- ##

volumes:
  metabase${1:+_$1}_data:
    external: true
    name: metabase${1:+_$1}_data

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do metabase"
fi
STACK_NAME="metabase${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c metabase.yaml metabase > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do metabase"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull metabase/metabase:latest

## Usa o serviço wait_stack "metabase" para verificar se o serviço esta online
wait_stack metabase${1:+_$1}_metabase${1:+_$1}

telemetria MetaBase finalizado

cd dados_vps

cat > dados_metabase${1:+_$1} <<EOL
[ METABASE ]

Dominio do metabase: https://$url_metabase

Usuario: Precisa criar no primeiro acesso do metabase

Senha: Precisa criar no primeiro acesso do metabase
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ METABASE ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_metabase\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do metabase\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do metabase\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗  ██████╗  ██████╗ 
## ██╔═══██╗██╔══██╗██╔═══██╗██╔═══██╗
## ██║   ██║██║  ██║██║   ██║██║   ██║
## ██║   ██║██║  ██║██║   ██║██║   ██║
## ╚██████╔╝██████╔╝╚██████╔╝╚██████╔╝
##  ╚═════╝ ╚═════╝  ╚═════╝  ╚═════╝ 
                                   
ferramenta_odoo() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_odoo

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o Odoo (ex: odoo.oriondesign.art.br): \e[0m" && read -r url_odoo
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -e "$amarelo--> 1 = 19.0"
    echo -e "$amarelo--> 2 = 18.0"
    echo -e "$amarelo--> 3 = 17.0"
    echo -e "$amarelo--> 4 = 16.0"
    echo -en "\e[33mDigite a versão desejada para o Odoo (ex: 1): \e[0m" && read -r versao_odoo
    echo ""+
    if [ "$versao_odoo" = "1" ]; then
        odoo_version_selected="19.0"
    elif [ "$versao_odoo" = "2" ]; then
        odoo_version_selected="18.0"
    elif [ "$versao_odoo" = "4" ]; then
        odoo_version_selected="17.0"
    elif [ "$versao_odoo" = "5" ]; then
        odoo_version_selected="16.0"
    else
        echo -e "\e[31mOpção inválida. Usando versão '19.0' por padrão.\e[0m"
        odoo_version_selected="19.0"
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_odoo
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o Odoo:\e[97m $url_odoo\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mVersão do Odoo:\e[97m $odoo_version_selected\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_odoo

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO ODOO \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Odoo iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO ODOO \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando senha do postgres
senha_postgres_odoo=$(openssl rand -hex 16)

## Criando a stack odoo.yaml
cat > odoo${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  odoo${1:+_$1}_app:
    image: odoo:$odoo_version_selected

    volumes:
      - odoo${1:+_$1}_app_data:/var/lib/odoo
      - odoo${1:+_$1}_app_config:/etc/odoo
      - odoo${1:+_$1}_app_addons:/mnt/extra-addons

    networks:
      - $nome_rede_interna

    environment:
    ## 🗄️ Dados postgres do Odoo
      - HOST=odoo${1:+_$1}_db
      - USER=odoo
      - PASSWORD=$senha_postgres_odoo

    deploy:
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.odoo${1:+_$1}_app.rule=Host(\`$url_odoo\`)
        - traefik.http.routers.odoo${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.odoo${1:+_$1}_app.tls=true
        - traefik.http.routers.odoo${1:+_$1}_app.service=odoo${1:+_$1}_app
        - traefik.http.routers.odoo${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.services.odoo${1:+_$1}_app.loadbalancer.server.port=8069

## --------------------------- ORION --------------------------- ##

  odoo${1:+_$1}_db:
    image: postgres:15

    volumes:
      - odoo${1:+_$1}_db_data:/var/lib/postgresql/data/pgdata

    networks:
      - $nome_rede_interna
    #ports:
    #  - 5434:5432

    environment:
    ## 🗄️ Dados Postgres
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=$senha_postgres_odoo
      - POSTGRES_USER=odoo
      - PGDATA=/var/lib/postgresql/data/pgdata
    deploy:
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

volumes:
  odoo${1:+_$1}_app_data:
    external: true
    name: odoo${1:+_$1}_app_data
  odoo${1:+_$1}_app_config:
    external: true
    name: odoo${1:+_$1}_app_config
  odoo${1:+_$1}_app_addons:
    external: true
    name: odoo${1:+_$1}_app_addons
  odoo${1:+_$1}_db_data:
    external: true
    name: odoo${1:+_$1}_db_data

networks:
  $nome_rede_interna:
    external: true
    attachable: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do odoo"
fi
STACK_NAME="odoo${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c odoo.yaml odoo > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Odoo"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull postgres:15 odoo:$odoo_version_selected

## Usa o serviço wait_odoo para verificar se o serviço esta online
wait_stack odoo${1:+_$1}_odoo${1:+_$1}_app odoo${1:+_$1}_odoo${1:+_$1}_db

telemetria Odoo finalizado

cd dados_vps

cat > dados_odoo${1:+_$1} <<EOL
[ ODOO ]

Dominio do odoo: https://$url_odoo

Usuario: Precisa criar no primeiro acesso do Odoo

Senha: Precisa criar no primeiro acesso do Odoo

Database Name: odoo

Database Password: $senha_postgres_odoo
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ODOO ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_odoo\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Odoo\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Odoo\e[0m"
echo ""

echo -e "\e[33mDatabase Name:\e[97m odoo\e[0m"
echo ""

echo -e "\e[33mDatabase Password:\e[97m $senha_postgres_odoo\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗██╗  ██╗ █████╗ ████████╗██╗    ██╗ ██████╗  ██████╗ ████████╗
## ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██║    ██║██╔═══██╗██╔═══██╗╚══██╔══╝
## ██║     ███████║███████║   ██║   ██║ █╗ ██║██║   ██║██║   ██║   ██║   
## ██║     ██╔══██║██╔══██║   ██║   ██║███╗██║██║   ██║██║   ██║   ██║   
## ╚██████╗██║  ██║██║  ██║   ██║   ╚███╔███╔╝╚██████╔╝╚██████╔╝   ██║   
##  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚══╝╚══╝  ╚═════╝  ╚═════╝    ╚═╝   
##
##         ███╗   ██╗███████╗███████╗████████╗ ██████╗ ██████╗ 
##         ████╗  ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗
##         ██╔██╗ ██║█████╗  ███████╗   ██║   ██║   ██║██████╔╝
##         ██║╚██╗██║██╔══╝  ╚════██║   ██║   ██║   ██║██╔══██╗
##         ██║ ╚████║███████╗███████║   ██║   ╚██████╔╝██║  ██║
##         ╚═╝  ╚═══╝╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
                                                    
                                                               
ferramenta_chatwoot_nestor() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_chatwoot_nestor

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Chatwoot (ex: chatwoot.oriondesign.art.br): \e[0m" && read -r url_chatwoot
    echo ""
    
    ## Pega o nome do dominio para ser o nome da empresa
    nome_empresa_chatwoot="$nome_servidor"
    
    ## Pergunta o email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_admin_chatwoot
    echo ""

    ## Define o dominio SMTP com o dominio do email
    dominio_smtp_chatwoot=$(echo "$email_admin_chatwoot" | cut -d "@" -f 2)

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_chatwoot
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_chatwoot
    echo ""
    
    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_chatwoot
    echo ""
    
    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_chatwoot
    
    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_chatwoot" -eq 465 ]; then
     sobre_ssl=true
    else
     sobre_ssl=false
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_chatwoot_nestor
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Chatwoot:\e[97m $url_chatwoot\e[0m"
    echo ""

    ## Informação sobre Nome da Empresa
    echo -e "\e[33mNome da Empresa:\e[97m $nome_empresa_chatwoot\e[0m"
    echo ""

    ## Informação sobre Email de SMTP
    echo -e "\e[33mEmail do SMTP:\e[97m $email_admin_chatwoot\e[0m"
    echo ""

    ## Informação sobre Usuario do SMTP
    echo -e "\e[33mUser do SMTP:\e[97m $user_smtp_chatwoot\e[0m"
    echo ""

    ## Informação sobre Senha de SMTP
    echo -e "\e[33mSenha do SMTP:\e[97m $senha_email_chatwoot\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP:\e[97m $smtp_email_chatwoot\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_chatwoot\e[0m"
    echo ""
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_chatwoot_nestor

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO CHATWOOT NESTOR \e[33m[1/7]\e[0m"
echo ""
sleep 1

telemetria "Chatwoot Nestor" "iniciado"

## Ativa a função dados para pegar os dados da vps
dados

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO PGVECTOR \e[33m[2/7]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_pgvector_da_stack "chatwoot_nestor${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "chatwoot_nestor${1:+_$1}"
fi

## Verifica/instala o Redis
verificar_container_redis
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Redis já instalado"
    echo ""
else
    ferramenta_redis
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO CHATWOOT NESTOR \e[33m[4/7]\e[0m"
echo ""
sleep 1

## Neste passo vamos estar criando a Stack yaml do Chatwoot na pasta /root/
## Isso possibilitará que o usuario consiga edita-lo posteriormente

## Depois vamos instalar o Chatwoot e verificar se esta tudo certo.

## Criando key aleatória
encryption_key=$(openssl rand -hex 16)

## Criando a stack chatwoot_nestor.yaml
cat > chatwoot_nestor${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

   chatwoot_nestor${1:+_$1}_app:
    image: sendingtk/chatwoot:latest ## Versão do Chatwoot Nestor
    command: bundle exec rails s -p 3000 -b 0.0.0.0
    entrypoint: docker/entrypoints/rails.sh

    volumes:
      - chatwoot_nestor${1:+_$1}_storage:/app/storage ## Arquivos de conversa
      - chatwoot_nestor${1:+_$1}_public:/app/public ## Arquivos de logos
      - chatwoot_nestor${1:+_$1}_mailer:/app/app/views/devise/mailer ## Arquivos de email
      - chatwoot_nestor${1:+_$1}_mailers:/app/app/views/mailers ## Arquivos de emails

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
      ## Qualquer Url com # no final
      - CHATWOOT_HUB_URL=https://oriondesign.art.br/setup#

      ## Nome da Empresa
      - INSTALLATION_NAME=$nome_empresa_chatwoot

      ## Secret key
      - SECRET_KEY_BASE=$encryption_key

      ## Url Chatwoot
      - FRONTEND_URL=https://$url_chatwoot
      - FORCE_SSL=true

      ## Idioma/Localização padrão
      - DEFAULT_LOCALE=pt_BR
      - TZ=America/Brasil

      ## Google Cloud - Modifique de acordo com os seus dados (lembre-se de mudar no chatwoot_sidekiq)
      #- GOOGLE_OAUTH_CLIENT_ID=369777777777-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com
      #- GOOGLE_OAUTH_CLIENT_SECRET=ABCDEF-GHijklmnoPqrstuvwX-yz1234567
      #- GOOGLE_OAUTH_CALLBACK_URL=https://<your-server-domain>/omniauth/google_oauth2/callback

      ## Dados do Redis
      - REDIS_URL=redis://redis:6379
      - REDIS_PREFIX=chatwoot_nestor${1:+_$1}_

      ## Dados do Postgres
      - POSTGRES_HOST=pgvector
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$senha_pgvector ## Senha do postgres
      - POSTGRES_DATABASE=chatwoot_nestor${1:+_$1}

      ## Armazenamento
      - ACTIVE_STORAGE_SERVICE=local ## use s3_compatible para MinIO
      #- STORAGE_BUCKET_NAME=chatwoot_nestor${1:+_$1}
      #- STORAGE_ACCESS_KEY_ID=ACCESS_KEY_MINIO
      #- STORAGE_SECRET_ACCESS_KEY=SECRET_KEY_MINIO
      #- STORAGE_REGION=eu-south
      #- STORAGE_ENDPOINT=https://s3.DOMINIO.COM
      #- STORAGE_FORCE_PATH_STYLE=true

      ## Dados do SMTP
      - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot> ## Email SMTP
      - SMTP_DOMAIN=$dominio_smtp_chatwoot ## Dominio do email
      - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP
      - SMTP_PORT=$porta_smtp_chatwoot ## Porta SMTP
      - SMTP_SSL=$sobre_ssl ## Se a porta for 465 = true | Se a porta for 587 = false
      - SMTP_USERNAME=$user_smtp_chatwoot ## Usuario SMTP
      - SMTP_PASSWORD=$senha_email_chatwoot ## Senha do SMTP
      - SMTP_AUTHENTICATION=login
      - SMTP_ENABLE_STARTTLS_AUTO=true
      - SMTP_OPENSSL_VERIFY_MODE=peer
      - MAILER_INBOUND_EMAIL_DOMAIN=$email_admin_chatwoot ## Email SMTP

      ## Melhorias
      - SIDEKIQ_CONCURRENCY=10
      - RACK_TIMEOUT_SERVICE_TIMEOUT=0
      - RAILS_MAX_THREADS=5
      - WEB_CONCURRENCY=2
      - ENABLE_RACK_ATTACK=false

      ## Outras configurações
      - NODE_ENV=production
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
      - RAILS_LOG_TO_STDOUT=true
      - USE_INBOX_AVATAR_FOR_BOT=true
      - ENABLE_ACCOUNT_SIGNUP=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.chatwoot_nestor${1:+_$1}_app.rule=Host(\`$url_chatwoot\`)
        - traefik.http.routers.chatwoot_nestor${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.chatwoot_nestor${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.chatwoot_nestor${1:+_$1}_app.priority=1
        - traefik.http.routers.chatwoot_nestor${1:+_$1}_app.service=chatwoot_nestor${1:+_$1}_app
        - traefik.http.services.chatwoot_nestor${1:+_$1}_app.loadbalancer.server.port=3000 
        - traefik.http.services.chatwoot_nestor${1:+_$1}_app.loadbalancer.passHostHeader=true 
        - traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.routers.chatwoot_nestor${1:+_$1}_app.middlewares=sslheader

## --------------------------- ORION --------------------------- ##

   chatwoot_nestor${1:+_$1}_sidekiq:
    image: sendingtk/chatwoot:latest ## Versão do Chatwoot Nestor
    command: bundle exec sidekiq -C config/sidekiq.yml

    volumes:
      - chatwoot_nestor${1:+_$1}_storage:/app/storage ## Arquivos de conversa
      - chatwoot_nestor${1:+_$1}_public:/app/public ## Arquivos de logos
      - chatwoot_nestor${1:+_$1}_mailer:/app/app/views/devise/mailer ## Arquivos de email
      - chatwoot_nestor${1:+_$1}_mailers:/app/app/views/mailers ## Arquivos de emails

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      ## Qualquer Url com # no final
      - CHATWOOT_HUB_URL=https://oriondesign.art.br/setup#

      ## Nome da Empresa
      - INSTALLATION_NAME=$nome_empresa_chatwoot

      ## Secret key
      - SECRET_KEY_BASE=$encryption_key

      ## Url Chatwoot
      - FRONTEND_URL=https://$url_chatwoot
      - FORCE_SSL=true

      ## Idioma/Localização padrão
      - DEFAULT_LOCALE=pt_BR
      - TZ=America/Sao_Paulo

      ## Google Cloud - Modifique de acordo com os seus dados (lembre-se de mudar no chatwoot_sidekiq)
      #- GOOGLE_OAUTH_CLIENT_ID=369777777777-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com
      #- GOOGLE_OAUTH_CLIENT_SECRET=ABCDEF-GHijklmnoPqrstuvwX-yz1234567
      #- GOOGLE_OAUTH_CALLBACK_URL=https://<your-server-domain>/omniauth/google_oauth2/callback

      ## Dados do Redis
      - REDIS_URL=redis://redis:6379
      - REDIS_PREFIX=chatwoot_nestor${1:+_$1}_

      ## Dados do Postgres
      - POSTGRES_HOST=pgvector
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$senha_pgvector ## Senha do postgres
      - POSTGRES_DATABASE=chatwoot_nestor${1:+_$1}

      ## Armazenamento
      - ACTIVE_STORAGE_SERVICE=local ## use s3_compatible para MinIO
      #- STORAGE_BUCKET_NAME=chatwoot_nestor${1:+_$1}
      #- STORAGE_ACCESS_KEY_ID=ACCESS_KEY_MINIO
      #- STORAGE_SECRET_ACCESS_KEY=SECRET_KEY_MINIO
      #- STORAGE_REGION=eu-south
      #- STORAGE_ENDPOINT=https://s3.DOMINIO.COM
      #- STORAGE_FORCE_PATH_STYLE=true

      ## Dados do SMTP
      - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot> ## Email SMTP
      - SMTP_DOMAIN=$dominio_smtp_chatwoot ## Dominio do email
      - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP
      - SMTP_PORT=$porta_smtp_chatwoot ## Porta SMTP
      - SMTP_SSL=$sobre_ssl ## Se a porta for 465 = true | Se a porta for 587 = false
      - SMTP_USERNAME=$user_smtp_chatwoot ## Usuario SMTP
      - SMTP_PASSWORD=$senha_email_chatwoot ## Senha do SMTP
      - SMTP_AUTHENTICATION=login
      - SMTP_ENABLE_STARTTLS_AUTO=true
      - SMTP_OPENSSL_VERIFY_MODE=peer
      - MAILER_INBOUND_EMAIL_DOMAIN=$email_admin_chatwoot ## Email SMTP

      ## Melhorias
      - SIDEKIQ_CONCURRENCY=10
      - RACK_TIMEOUT_SERVICE_TIMEOUT=0
      - RAILS_MAX_THREADS=5
      - WEB_CONCURRENCY=2
      - ENABLE_RACK_ATTACK=false

      ## Outras configurações
      - NODE_ENV=production
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
      - RAILS_LOG_TO_STDOUT=true
      - USE_INBOX_AVATAR_FOR_BOT=true
      - ENABLE_ACCOUNT_SIGNUP=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  chatwoot_nestor${1:+_$1}_storage:
    external: true
    name: chatwoot_nestor${1:+_$1}_storage
  chatwoot_nestor${1:+_$1}_public:
    external: true
    name: chatwoot_nestor${1:+_$1}_public
  chatwoot_nestor${1:+_$1}_mailer:
    external: true
    name: chatwoot_nestor${1:+_$1}_mailer
  chatwoot_nestor${1:+_$1}_mailers:
    external: true
    name: chatwoot_nestor${1:+_$1}_mailers

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Chatwoot"
fi
STACK_NAME="chatwoot_nestor${1:+_$1}"
stack_editavel #> /dev/null 2>&1

#docker stack deploy --prune --resolve-image always -c chatwoot_nestor.yaml chatwoot > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Chatwoot"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/7]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull sendingtk/chatwoot:latest

## Usa o serviço wait_chatwoot para verificar se o serviço esta online
wait_stack chatwoot_nestor${1:+_$1}_chatwoot_nestor${1:+_$1}_app chatwoot_nestor${1:+_$1}_chatwoot_nestor${1:+_$1}_sidekiq

telemetria "Chatwoot Nestor" "finalizado"
## Mensagem de Passo
echo -e "\e[97m• MIGRANDO BANCO DE DADOS \e[33m[6/7]\e[0m"
echo ""
sleep 1

## Aqui vamos estar migrando o banco de dados usando o comando "bundle exec rails db:chatwoot_prepare"

## Basicamente voce poderia entrar no banco de dados do chatwoot e executar o comando por lá tambem

container_name="chatwoot_nestor${1:+_$1}_chatwoot_nestor${1:+_$1}_app"

max_wait_time=1200

wait_interval=60

elapsed_time=0

while [ $elapsed_time -lt $max_wait_time ]; do
  CONTAINER_ID=$(docker ps -q --filter "name=$container_name")
  if [ -n "$CONTAINER_ID" ]; then
    break
  fi
  sleep $wait_interval
  elapsed_time=$((elapsed_time + wait_interval))
done

if [ -z "$CONTAINER_ID" ]; then
  echo "O contêiner não foi encontrado após $max_wait_time segundos."
  exit 1
fi

docker exec -it "$CONTAINER_ID" bundle exec rails db:chatwoot_prepare > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Executando no container: bundle exec rails db:chatwoot_prepare"
else
    echo "1/1 - [ OFF ] - Executando no container: bundle exec rails db:chatwoot_prepare"
    echo "Não foi possivel migrar o banco de dados"
fi

echo ""
## Mensagem de Passo
echo -e "\e[97m• ATIVANDO FUNÇÕES DO SUPER ADMIN \e[33m[7/7]\e[0m"
echo ""
sleep 1

##  Aqui vamos alterar um dado no postgres para liberar algumas funções ocultas no painel de super admin
wait_for_pgvector

CONTAINER_ID_NESTOR=$(docker ps -q --filter "name=pgvector_pgvector")

docker exec -i $CONTAINER_ID_NESTOR psql -U postgres <<EOF > /dev/null 2>&1
\c chatwoot_nestor${1:+_$1};
update installation_configs set locked = false;
\q
EOF
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Desbloqueando tabela installation_configs no postgres"
else
    echo "1/1 - [ OFF ] - Desbloqueando tabela installation_configs no postgres"
    echo "Não foi possivel liberar as funções do super_admin"
fi

echo ""

## Salvando informações da instalação dentro de /dados_vps/
cd dados_vps

cat > dados_chatwoot_nestor${1:+_$1} <<EOL
[ CHATWOOT NESTOR ]

Dominio do Chatwoot: https://$url_chatwoot

Usuario: Precisa criar dentro do Chatwoot

Senha: Precisa criar dentro do Chatwoot
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ CHATWOOT NESTOR ]\e[0m"
echo ""

echo -e "\e[97mDominio:\e[33m https://$url_chatwoot\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m Precisa criar dentro do Chatwoot\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m Precisa criar dentro do Chatwoot\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗   ██╗███╗   ██╗ ██████╗      █████╗ ██████╗ ██╗
## ██║   ██║████╗  ██║██╔═══██╗    ██╔══██╗██╔══██╗██║
## ██║   ██║██╔██╗ ██║██║   ██║    ███████║██████╔╝██║
## ██║   ██║██║╚██╗██║██║   ██║    ██╔══██║██╔═══╝ ██║
## ╚██████╔╝██║ ╚████║╚██████╔╝    ██║  ██║██║     ██║
##  ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝     ╚═╝  ╚═╝╚═╝     ╚═╝

ferramenta_unoapi() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_unoapi

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio da UnoApi
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para a Uno API (ex: unoapi.oriondesign.art.br): \e[0m" && read -r url_unoapi
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_unoapi
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    echo -e "\e[33mDominio da Uno API:\e[97m $url_unoapi\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_unoapi

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA UNO API \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria "Uno API" "iniciado"

## Nada nada nada.. só para aparecer a mensagem de passo..

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[2/5]\e[0m"
echo ""
sleep 1

pegar_senha_minio
minio.bucket unoapi${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
    echo ""
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO VHOST NO RABBITMQ \e[33m[3/5]\e[0m"
echo ""
sleep 1

pegar_user_senha_rabbitmq
sleep 5
curl -u $user_rabbit_mqs:$senha_rabbit_mqs -X PUT https://$url_rabbit_mqs/api/vhosts/unoapi${1:+_$1}
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - VHost criado:\e[33m unoapi${1:+_$1}\e[0m"
    echo ""
else
    echo "1/1 - [ OFF ] - Erro ao criar VHost"
    echo ""
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO UNO API \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
key_unoapi=$(openssl rand -hex 16)

## Criando a stack unoapi.yaml
cat > unoapi${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  unoapi${1:+_$1}_api:
    image: clairton/unoapi-cloud:latest
    entrypoint: yarn cloud

    volumes:
      - unoapi${1:+_$1}_data:/home/u/app

    networks:
      - $nome_rede_interna

    environment:
    ## 🔗 Url Uno API
      - BASE_URL=https://$url_unoapi

    ## 🔐 Token Uno Api
      - UNOAPI_AUTH_TOKEN=$key_unoapi

    ## 🔍 Configurações da Uno API
      - CONFIG_SESSION_PHONE_CLIENT=OrionDesign
      - CONFIG_SESSION_PHONE_NAME=Chrome ## Chrome | Firefox | Edge | Opera | Safari

    ## 🔗 Configuração do Webhook
      #- WEBHOOK_URL=https://UrlDoChatwoot.com/webhooks/whatsapp
      #- WEBHOOK_HEADER=api_access_token
      #- WEBHOOK_TOKEN=token_do_admin

    ## 🗄️ Dados do Minio/S3
      - STORAGE_ENDPOINT=https://$url_s3
      - STORAGE_ACCESS_KEY_ID=$S3_ACCESS_KEY
      - STORAGE_SECRET_ACCESS_KEY=$S3_SECRET_KEY
      - STORAGE_BUCKET_NAME=unoapi${1:+-$1}
      - STORAGE_REGION=eu-south
      - STORAGE_FORCE_PATH_STYLE=true

    ## 🔁 Dados do RabbitMQ
      - AMQP_URL=amqp://$user_rabbit_mqs:$senha_rabbit_mqs@rabbitmq:5672/unoapi${1:+_$1}

    ## 🔁 Dados do Redis
      - REDIS_URL=redis://unoapi${1:+_$1}_redis:6379

    ## 🔍 Outras configurações
      - LOG_LEVEL=debug
      - UNO_LOG_LEVEL=debug
      - UNOAPI_RETRY_REQUEST_DELAY=1_000

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.unoapi${1:+_$1}.rule=Host(\`$url_unoapi\`)
        - traefik.http.routers.unoapi${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.unoapi${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.unoapi${1:+_$1}.loadbalancer.server.port=9876
        - traefik.http.routers.unoapi${1:+_$1}.priority=1
        - traefik.http.services.unoapi${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.routers.unoapi${1:+_$1}.service=unoapi${1:+_$1}

## --------------------------- ORION --------------------------- ##

  unoapi${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - unoapi${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  unoapi${1:+_$1}_data:
    external: true
    name: unoapi${1:+_$1}_data
  unoapi${1:+_$1}_redis:
    external: true
    name: unoapi${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Uno API"
fi
STACK_NAME="unoapi${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c unoapi.yaml unoapi > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Uno API"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest clairton/unoapi-cloud:latest

## Usa o serviço wait_unoapi para verificar se o serviço esta online
wait_stack unoapi${1:+_$1}_unoapi${1:+_$1}_redis unoapi${1:+_$1}_unoapi${1:+_$1}_api

telemetria "Uno API" "finalizado"

cd dados_vps

cat > dados_unoapi${1:+_$1} <<EOL
[ UNO API ]

Dominio do unoapi: https://$url_unoapi

Auth Token: $key_unoapi
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ UNO API ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_unoapi\e[0m"
echo ""

echo -e "\e[33mAuth Token:\e[97m $key_unoapi\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗ █████╗ ███╗   ██╗     ██████╗ ██████╗ ███╗   ███╗    ███╗   ██╗ ██████╗ ██████╗ ███████╗███████╗
## ████╗  ██║██╔══██╗████╗  ██║    ██╔════╝██╔═══██╗████╗ ████║    ████╗  ██║██╔═══██╗██╔══██╗██╔════╝██╔════╝
## ██╔██╗ ██║╚█████╔╝██╔██╗ ██║    ██║     ██║   ██║██╔████╔██║    ██╔██╗ ██║██║   ██║██║  ██║█████╗  ███████╗
## ██║╚██╗██║██╔══██╗██║╚██╗██║    ██║     ██║   ██║██║╚██╔╝██║    ██║╚██╗██║██║   ██║██║  ██║██╔══╝  ╚════██║
## ██║ ╚████║╚█████╔╝██║ ╚████║    ╚██████╗╚██████╔╝██║ ╚═╝ ██║    ██║ ╚████║╚██████╔╝██████╔╝███████╗███████║
## ╚═╝  ╚═══╝ ╚════╝ ╚═╝  ╚═══╝     ╚═════╝ ╚═════╝ ╚═╝     ╚═╝    ╚═╝  ╚═══╝ ╚═════╝ ╚═════╝ ╚══════╝╚══════╝
##
##            ██████╗  ██████╗      ██████╗ ██╗   ██╗███████╗██████╗  █████╗ ███████╗ █████╗ 
##            ██╔══██╗██╔═══██╗    ██╔═══██╗██║   ██║██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗
##            ██║  ██║██║   ██║    ██║   ██║██║   ██║█████╗  ██████╔╝███████║███████╗███████║
##            ██║  ██║██║   ██║    ██║▄▄ ██║██║   ██║██╔══╝  ██╔═══╝ ██╔══██║╚════██║██╔══██║
##            ██████╔╝╚██████╔╝    ╚██████╔╝╚██████╔╝███████╗██║     ██║  ██║███████║██║  ██║
##            ╚═════╝  ╚═════╝      ╚══▀▀═╝  ╚═════╝ ╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝

ferramenta_n8n_quepasa() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_n8n_quepasa

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do N8N
    echo -e "\e[97mPasso$amarelo 1/8\e[0m"
    echo -en "\e[33mDigite o dominio para o N8N (ex: n8n.oriondesign.art.br): \e[0m" && read -r url_editorn8n
    echo ""
    
    ##Pergunta o Dominio do Webhook
    echo -e "\e[97mPasso$amarelo 2/8\e[0m"
    echo -en "\e[33mDigite o dominio para o Webhook do N8N (ex: webhook.oriondesign.art.br): \e[0m" && read -r url_webhookn8n
    echo ""

    ##Pergunta Dominio do Chatwoot
    echo -e "\e[97mPasso$amarelo 3/8\e[0m"
    echo -en "\e[33mDigite o dominio do Chatwoot (ex: chatwoot.oriondesign.art.br): \e[0m" && read -r dominio_chatwoot
    echo ""

    ##Pergunta Dominio do Quepasa
    echo -e "\e[97mPasso$amarelo 4/8\e[0m"
    echo -en "\e[33mDigite o dominio do Quepasa (ex: quepasa.oriondesign.art.br): \e[0m" && read -r dominio_quepasa
    echo ""

    ##Pergunta Email do Quepasa
    echo -e "\e[97mPasso$amarelo 5/8\e[0m"
    echo -en "\e[33mDigite o email do Quepasa (ex: contato@oriondesign.art.br): \e[0m" && read -r email_quepasa
    echo ""

     ## Nome usuario padrão para criação do qrcode (utoken)
    echo -e "\e[97mPasso$amarelo 6/8\e[0m"
    echo -en "\e[33mNome do usuario padrão (Crie um usuario Admin no Chatwoot) (ex: Bot): \e[0m" && read -r user_padrao
    echo ""

     ## Token do usuario criado Admin
    echo -e "\e[97mPasso$amarelo 7/8\e[0m"
    echo -en "\e[33mToken do seu usuario criado (ex: cv1dNNkgiXLvqKl6LSj0V4yu6Eqd77N): \e[0m" && read -r user_padrao_token
    echo ""

     ## ID do usuario criado Admin
    echo -e "\e[97mPasso$amarelo 8/8\e[0m"
    echo -en "\e[33mID do seu usuario criado (ex: 2): \e[0m" && read -r user_padrao_id
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_n8n_quepasa
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do N8N
    echo -e "\e[33mDominio do N8N:\e[97m $url_editorn8n\e[0m"
    echo ""
    
    ## Informação sobre URL do Webhook
    echo -e "\e[33mDominio para o Webhook:\e[97m $url_webhookn8n\e[0m"
    echo ""

    ## Informação sobre URL do Chatwoot
    echo -e "\e[33mDominio do Chatwoot:\e[97m $dominio_chatwoot\e[0m"
    echo ""

    ## Informação sobre URL do Quepasa
    echo -e "\e[33mDominio do Quepasa:\e[97m $dominio_quepasa\e[0m"
    echo ""

    ## Informação Email do Quepasa
    echo -e "\e[33mEmail do Quepasa:\e[97m $email_quepasa\e[0m"
    echo ""
    ## Nome do usuario padrão para vincular ao qrcode (utoken)
    echo -e "\e[33mNome do User Padrão:\e[97m $user_padrao\e[0m"
    echo ""

     ## Token do usuario padrão para vincular ao qrcode (utoken)
    echo -e "\e[33mToken User Padrão:\e[97m $user_padrao_token\e[0m"
    echo ""
    
     ## ID do usuario padrão para vincular ao qrcode (utoken)
    echo -e "\e[33mToken User Padrão:\e[97m $user_padrao_id\e[0m"
    echo ""

    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_n8n_quepasa

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO N8N \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria "N8N & Quepasa" "iniciado"

## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES\e[33m[2/5]\e[0m"
echo ""
sleep 1

## Verifica se tem postgres, se sim pega a senha e cria um banco nele, se não instala, pega a senha e cria o banco
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "n8n_quepasa${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "n8n_quepasa${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO REDIS \e[33m[3/5]\e[0m"
echo ""
sleep 1

## Verifica/instala o Redis
verificar_container_redis
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Redis já instalado"
    echo ""
else
    ferramenta_redis
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO N8N \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
encryption_key=$(openssl rand -hex 16)

## Criando a stack n8n_quepasa.yaml
cat > n8n_quepasa${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  n8n_quepasa${1:+_$1}_editor:
    image: deividms/n8n-quepasa:latest ## Versão do N8N
    command: start

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      ## Dados do postgres
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_quepasa${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres

      ## Dados do Quepasa
      ### Fluxos IDS
      - C8Q_QUEPASAINBOXCONTROL=1001
      - C8Q_GETCHATWOOTCONTACTS=1002
      - C8Q_QUEPASACHATCONTROL=1003
      - C8Q_CHATWOOTPROFILEUPDATE=1004
      - C8Q_POSTTOWEBCALLBACK=1005
      - C8Q_POSTTOCHATWOOT=1006
      - C8Q_CHATWOOTTOQUEPASAGREETINGS=1007
      - C8Q_TOCHATWOOTTRANSCRIPT=pi4APHD9F05Dv6FR
      - C8Q_TOCHATWOOTTRANSCRIPTRESUME=true
      - C8Q_GETVALIDCONVERSATION=qjdP01sHPfaPFUq1
      - C8Q_WF_CHATWOOTEXTRA=t1o1WDo9E7C5EmJC
      - C8Q_WF_TOTYPEBOT=JSpCXQiF7TT1zUgp
      - C8Q_WF_QUEPASAINBOXCONTROL_TYPEBOT=BvfU3kc7i0j68IpZ
      - C8Q_WF_QUEPASAINBOXCONTROL_SOC=wtn1ZvAUTFwKCHfK 
      - C8Q_WF_QUEPASAINBOXCONTROL_WEBHOOK=Zj197aISsaIkZP2Z

      ### Config Gerais
      - C8Q_SINGLETHREAD=false
      - C8Q_MSGFOR_NO_CSAT=
      - C8Q_SUPERUSER_NAME=$user_padrao
      - C8Q_SUPERUSER_TOKEN=$user_padrao_token
      - C8Q_SUPERUSER_ID=$user_padrao_id
      - C8Q_CW_PUBLIC_URL=$dominio_chatwoot
      - C8Q_QP_DEFAULT_USER=$email_quepasa
      - C8Q_QP_BOTTITLE=$nome_servidor
      - C8Q_QP_CONTACT=$email_quepasa
      - C8Q_CW_HOST=https://$dominio_chatwoot
      - C8Q_N8N_HOST=https://$url_editorn8n
      - C8Q_N8N_WEBHOOK=https://$url_webhookn8n
      - C8Q_QUEPASA_HOST=https://$dominio_quepasa
      - C8Q_QP_HOST=https://$dominio_quepasa
      - C8Q_MSGFOR_UNKNOWN_CONTENT=! "Algum EMOJI" ou "Alguma Reação que o sistema não entende ainda ..."
      - C8Q_MSGFOR_EDITED_CONTENT=⚠️ **Essa mensagem foi editada !**
      - C8Q_MSGFOR_ATTACHERROR_CONTENT=** Falha ao baixar anexo !
      - C8Q_MSGFOR_LOCALIZATION_CONTENT=* Localização *
      - C8Q_MSGFOR_REVOKED_CONTENT=❌ Essa mensagem foi apagada !!!
      - C8Q_MSGFOR_CALL_CONTENT=⚠️ O usuário requisitou uma chamada de voz !
      - C8Q_MSGFOR_REJECT_CALL=Não aceitamos Ligação - MSG configurada na Stack
      - C8Q_QP_DEFAULT_CALL=true

      ### Typebot
      # - C8Q_TYPEBOT_HOST=url_web_typebot
      # - C8Q_TYPEBOT_TOKEN=API-Token

      ## Encryption Key
      - N8N_ENCRYPTION_KEY=$encryption_key

      ## Url do N8N
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https

      ## Modo do Node
      - NODE_ENV=production
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true

      ## Modo de execução (deletar caso deseje em modo regular)
      - EXECUTIONS_MODE=queue

      ## Dados do Redis
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

      ## Timezone
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.5"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.n8n_quepasa${1:+_$1}_editor.rule=Host(\`$url_editorn8n\`)
        - traefik.http.routers.n8n_quepasa${1:+_$1}_editor.entrypoints=websecure
        - traefik.http.routers.n8n_quepasa${1:+_$1}_editor.priority=1
        - traefik.http.routers.n8n_quepasa${1:+_$1}_editor.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n_quepasa${1:+_$1}_editor.service=n8n_quepasa${1:+_$1}_editor
        - traefik.http.services.n8n_quepasa${1:+_$1}_editor.loadbalancer.server.port=5678
        - traefik.http.services.n8n_quepasa${1:+_$1}_editor.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

  n8n_quepasa${1:+_$1}_webhook:
    image: deividms/n8n-quepasa:latest ## Versão do N8N
    command: webhook

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      ## Dados do postgres
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_quepasa${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres

      ## Dados do Quepasa
      ### Fluxos IDS
      - C8Q_QUEPASAINBOXCONTROL=1001
      - C8Q_GETCHATWOOTCONTACTS=1002
      - C8Q_QUEPASACHATCONTROL=1003
      - C8Q_CHATWOOTPROFILEUPDATE=1004
      - C8Q_POSTTOWEBCALLBACK=1005
      - C8Q_POSTTOCHATWOOT=1006
      - C8Q_CHATWOOTTOQUEPASAGREETINGS=1007
      - C8Q_TOCHATWOOTTRANSCRIPT=pi4APHD9F05Dv6FR
      - C8Q_TOCHATWOOTTRANSCRIPTRESUME=true
      - C8Q_GETVALIDCONVERSATION=qjdP01sHPfaPFUq1
      - C8Q_WF_CHATWOOTEXTRA=t1o1WDo9E7C5EmJC
      - C8Q_WF_TOTYPEBOT=JSpCXQiF7TT1zUgp
      - C8Q_WF_QUEPASAINBOXCONTROL_TYPEBOT=BvfU3kc7i0j68IpZ
      - C8Q_WF_QUEPASAINBOXCONTROL_SOC=wtn1ZvAUTFwKCHfK 
      - C8Q_WF_QUEPASAINBOXCONTROL_WEBHOOK=Zj197aISsaIkZP2Z

      ### Config Gerais
      - C8Q_SINGLETHREAD=false
      - C8Q_MSGFOR_NO_CSAT=
      - C8Q_SUPERUSER_NAME=$user_padrao
      - C8Q_SUPERUSER_TOKEN=$user_padrao_token
      - C8Q_SUPERUSER_ID=$user_padrao_id
      - C8Q_CW_PUBLIC_URL=$dominio_chatwoot
      - C8Q_QP_DEFAULT_USER=$email_quepasa
      - C8Q_QP_BOTTITLE=$nome_servidor
      - C8Q_QP_CONTACT=$email_quepasa
      - C8Q_CW_HOST=https://$dominio_chatwoot
      - C8Q_N8N_HOST=https://$url_editorn8n
      - C8Q_N8N_WEBHOOK=https://$url_webhookn8n
      - C8Q_QUEPASA_HOST=https://$dominio_quepasa
      - C8Q_QP_HOST=https://$dominio_quepasa
      - C8Q_MSGFOR_UNKNOWN_CONTENT=! "Algum EMOJI" ou "Alguma Reação que o sistema não entende ainda ..."
      - C8Q_MSGFOR_EDITED_CONTENT=⚠️ **Essa mensagem foi editada !**
      - C8Q_MSGFOR_ATTACHERROR_CONTENT=** Falha ao baixar anexo !
      - C8Q_MSGFOR_LOCALIZATION_CONTENT=* Localização *
      - C8Q_MSGFOR_REVOKED_CONTENT=❌ Essa mensagem foi apagada !!!
      - C8Q_MSGFOR_CALL_CONTENT=⚠️ O usuário requisitou uma chamada de voz !
      - C8Q_MSGFOR_REJECT_CALL=Não aceitamos Ligação - MSG configurada na Stack
      - C8Q_QP_DEFAULT_CALL=true

      ### Typebot
      # - C8Q_TYPEBOT_HOST=url_web_typebot
      # - C8Q_TYPEBOT_TOKEN=API-Token

      ## Encryption Key
      - N8N_ENCRYPTION_KEY=$encryption_key

      ## Url do N8N
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https

      ## Modo do Node
      - NODE_ENV=production
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true

      ## Modo de execução (deletar caso deseje em modo regular)
      - EXECUTIONS_MODE=queue

      ## Dados do Redis
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

      ## Timezone
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.5"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.n8n_quepasa${1:+_$1}_webhook.rule=(Host(\`$url_webhookn8n\`))
        - traefik.http.routers.n8n_quepasa${1:+_$1}_webhook.entrypoints=websecure
        - traefik.http.routers.n8n_quepasa${1:+_$1}_webhook.priority=1
        - traefik.http.routers.n8n_quepasa${1:+_$1}_webhook.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n_quepasa${1:+_$1}_webhook.service=n8n_quepasa${1:+_$1}_webhook
        - traefik.http.services.n8n_quepasa${1:+_$1}_webhook.loadbalancer.server.port=5678
        - traefik.http.services.n8n_quepasa${1:+_$1}_webhook.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

  n8n_quepasa${1:+_$1}_worker:
    image: deividms/n8n-quepasa:latest ## Versão do N8N
    command: worker --concurrency=10

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      ## Dados do postgres
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_quepasa${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres

      ## Dados do Quepasa
      ### Fluxos IDS
      - C8Q_QUEPASAINBOXCONTROL=1001
      - C8Q_GETCHATWOOTCONTACTS=1002
      - C8Q_QUEPASACHATCONTROL=1003
      - C8Q_CHATWOOTPROFILEUPDATE=1004
      - C8Q_POSTTOWEBCALLBACK=1005
      - C8Q_POSTTOCHATWOOT=1006
      - C8Q_CHATWOOTTOQUEPASAGREETINGS=1007
      - C8Q_TOCHATWOOTTRANSCRIPT=pi4APHD9F05Dv6FR
      - C8Q_TOCHATWOOTTRANSCRIPTRESUME=true
      - C8Q_GETVALIDCONVERSATION=qjdP01sHPfaPFUq1
      - C8Q_WF_CHATWOOTEXTRA=t1o1WDo9E7C5EmJC
      - C8Q_WF_TOTYPEBOT=JSpCXQiF7TT1zUgp
      - C8Q_WF_QUEPASAINBOXCONTROL_TYPEBOT=BvfU3kc7i0j68IpZ
      - C8Q_WF_QUEPASAINBOXCONTROL_SOC=wtn1ZvAUTFwKCHfK 
      - C8Q_WF_QUEPASAINBOXCONTROL_WEBHOOK=Zj197aISsaIkZP2Z

      ### Config Gerais
      - C8Q_SINGLETHREAD=false
      - C8Q_MSGFOR_NO_CSAT=
      - C8Q_SUPERUSER_NAME=$user_padrao
      - C8Q_SUPERUSER_TOKEN=$user_padrao_token
      - C8Q_SUPERUSER_ID=$user_padrao_id
      - C8Q_CW_PUBLIC_URL=$dominio_chatwoot
      - C8Q_QP_DEFAULT_USER=$email_quepasa
      - C8Q_QP_BOTTITLE=$nome_servidor
      - C8Q_QP_CONTACT=$email_quepasa
      - C8Q_CW_HOST=https://$dominio_chatwoot
      - C8Q_N8N_HOST=https://$url_editorn8n
      - C8Q_N8N_WEBHOOK=https://$url_webhookn8n
      - C8Q_QUEPASA_HOST=https://$dominio_quepasa
      - C8Q_QP_HOST=https://$dominio_quepasa
      - C8Q_MSGFOR_UNKNOWN_CONTENT=! "Algum EMOJI" ou "Alguma Reação que o sistema não entende ainda ..."
      - C8Q_MSGFOR_EDITED_CONTENT=⚠️ **Essa mensagem foi editada !**
      - C8Q_MSGFOR_ATTACHERROR_CONTENT=** Falha ao baixar anexo !
      - C8Q_MSGFOR_LOCALIZATION_CONTENT=* Localização *
      - C8Q_MSGFOR_REVOKED_CONTENT=❌ Essa mensagem foi apagada !!!
      - C8Q_MSGFOR_CALL_CONTENT=⚠️ O usuário requisitou uma chamada de voz !
      - C8Q_MSGFOR_REJECT_CALL=Não aceitamos Ligação - MSG configurada na Stack
      - C8Q_QP_DEFAULT_CALL=true

      ### Typebot
      # - C8Q_TYPEBOT_HOST=url_web_typebot
      # - C8Q_TYPEBOT_TOKEN=API-Token

      ## Encryption Key
      - N8N_ENCRYPTION_KEY=$encryption_key

      ## Url do N8N
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https

      ## Modo do Node
      - NODE_ENV=production
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true

      ## Modo de execução (deletar caso deseje em modo regular)
      - EXECUTIONS_MODE=queue

      ## Dados do Redis
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

      ## Timezone
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##


networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do N8N Quepasa"
fi
STACK_NAME="n8n_quepasa${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c n8n_quepasa.yaml n8n_quepasa > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do N8N Quepasa"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull deividms/n8n-quepasa:latest

## Usa o serviço wait_n8n para verificar se o serviço esta online
wait_stack n8n_quepasa${1:+_$1}_n8n_quepasa${1:+_$1}_editor n8n_quepasa${1:+_$1}_n8n_quepasa${1:+_$1}_webhook n8n_quepasa${1:+_$1}_n8n_quepasa${1:+_$1}_worker

telemetria "N8N & Quepasa" "finalizado"

cd dados_vps

cat > dados_n8n_quepasa${1:+_$1} <<EOL
[ N8N QUEPASA ]

Dominio do N8N: https://$url_editorn8n

Dominio do N8N: https://$url_webhookn8n

Email: Precisa criar no primeiro acesso do N8N

Senha: Precisa criar no primeiro acesso do N8N
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ N8N QUEPASA ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_editorn8n\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa criar no primeiro acesso do N8N\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do N8N\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}


##  ██████╗ ██╗   ██╗███████╗██████╗  █████╗ ███████╗ █████╗ 
## ██╔═══██╗██║   ██║██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗
## ██║   ██║██║   ██║█████╗  ██████╔╝███████║███████╗███████║
## ██║▄▄ ██║██║   ██║██╔══╝  ██╔═══╝ ██╔══██║╚════██║██╔══██║
## ╚██████╔╝╚██████╔╝███████╗██║     ██║  ██║███████║██║  ██║
##  ╚══▀▀═╝  ╚═════╝ ╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝

ferramenta_quepasa() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_quepasa

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Quepasa (ex: quepasa.oriondesign.art.br): \e[0m" && read -r url_quepasa
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_quepasa
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do quepasa
    echo -e "\e[33mDominio do Quepasa:\e[97m $url_quepasa\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO QUEPASA \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Quepasa iniciado

## NADA


## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES\e[33m[2/5]\e[0m"
echo ""
sleep 1

## Verifica se tem postgres, se sim pega a senha e cria um banco nele, se não instala, pega a senha e cria o banco
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "quepasa${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "quepasa${1:+_$1}"
fi


## Mensagem de Passo
echo -e "\e[97m• INSTALANDO QUEPASA \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack

key_quepasa=$(openssl rand -hex 16)
masterkey_quepasa=$(openssl rand -hex 16)

## Criando a stack quepasa.yaml
cat > quepasa${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  quepasa${1:+_$1}:
    image: codeleaks/quepasa:latest ## Imagem/versão do Quepasa
      
    volumes:
      - quepasa${1:+_$1}_volume:/opt/quepasa

    networks:
      - $nome_rede_interna

    environment:
    ## 🔧 Configurações do Quepasa
      - DOMAIN=$url_quepasa  # Usado pelo Traefik (labels)
      - MASTERKEY=$masterkey_quepasa
      - WEBSERVER_PORT=31000

    ## 🔐 Ativar/Desativar conta de setup
      - ACCOUNTSETUP=true ## Após criar a conta, desative para não permitir novos acessos.

    ## 📱 Titulo no celular
      - APP_TITLE=OrionDesign ## Mude aqui o nome que vai aparecer no celular.

    ## 🕒 TimeZone (opcional, mas útil para logs)
      - TZ=America/Sao_Paulo

    ## 🗄️ Banco de dados
      - DBDRIVER=postgres
      - DBHOST=postgres
      - DBDATABASE=quepasa${1:+_$1}
      - DBPORT=5432
      - DBUSER=postgres
      - DBPASSWORD=$senha_postgres
      - DBSSLMODE=disable

    ## 📱 Configurações para o WhatsApp
      - GROUPS=true
      - BROADCASTS=false
      - READRECEIPTS=forcedfalse
      - CALLS=true
      - READUPDATE=false

    ## 🔐 Configurações quepasa
      - WEBSOCKETSSL=true
      - REMOVEDIGIT9=true
      - SIGNING_SECRET=$masterkey_quepasa

    ## 🔄 Logging
      - LOGLEVEL=DEBUG
      - WHATSMEOW_LOGLEVEL=WARN
      - WHATSMEOW_DBLOGLEVEL=WARN
      - HTTPLOGS=false

    ## 🔧 Configurações gerais
      - SYNOPSISLENGTH=500
      - MIGRATIONS=/builder/migrations

    deploy:
      mode: replicated
      replicas: 1
      placement:
          constraints:
          - node.role == manager
      resources:
          limits:
              cpus: "2"
              memory: 2096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.quepasa${1:+_$1}.rule=Host(\`$url_quepasa\`)
        - traefik.http.routers.quepasa${1:+_$1}.tls=true
        - traefik.http.routers.quepasa${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.quepasa${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.quepasa${1:+_$1}.service=quepasa${1:+_$1}
        - traefik.http.routers.quepasa${1:+_$1}.priority=1      
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.SSLRedirect=true
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.STSSeconds=315360000
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.browserXSSFilter=true
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.contentTypeNosniff=true
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.forceSTSHeader=true
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.SSLHost=$url_quepasa
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.STSIncludeSubdomains=true
        - traefik.http.middlewares.quepasa${1:+_$1}.headers.STSPreload=true
        - traefik.http.services.quepasa${1:+_$1}.loadbalancer.server.port=31000
        - traefik.http.services.quepasa${1:+_$1}.loadbalancer.passHostHeader=true              

## --------------------------- ORION --------------------------- ##

volumes:
  quepasa${1:+_$1}_volume:
    external: true
    name: quepasa${1:+_$1}_volume

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL

if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Quepasa"
fi
STACK_NAME="quepasa${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c quepasa.yaml quepasa > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Quepasa"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull deividms/quepasa:latest

## Usa o serviço wait_quepasa para verificar se o serviço esta online
wait_stack quepasa${1:+_$1}_quepasa${1:+_$1}

telemetria Quepasa finalizado

cd dados_vps

cat > dados_quepasa${1:+_$1} <<EOL
[ QUEPASA ]

Dominio do Quepasa: https://$url_quepasa

Email: $email_quepasa

Usuario: Precisa de criar ao entrar no /setup

Senha: Precisa de criar ao entrar no /setup
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ QUEPASA ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_quepasa\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar ao entrar no setup\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar ao entrar no setup\e[0m"
echo ""

echo -e "\e[97mObservação:\e[33m Depois que criar sua conta no /setup, digite \e[97mquepasa.setup.off \e[0m"
echo -e "\e[33mpara desativar o /setup do quepasa.\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗  ██████╗██╗   ██╗███████╗███████╗ █████╗ ██╗     
## ██╔══██╗██╔═══██╗██╔════╝██║   ██║██╔════╝██╔════╝██╔══██╗██║     
## ██║  ██║██║   ██║██║     ██║   ██║███████╗█████╗  ███████║██║     
## ██║  ██║██║   ██║██║     ██║   ██║╚════██║██╔══╝  ██╔══██║██║     
## ██████╔╝╚██████╔╝╚██████╗╚██████╔╝███████║███████╗██║  ██║███████╗
## ╚═════╝  ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝
                                                                  
ferramenta_docuseal() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_docuseal

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o dominio para o Docuseal (ex: docuseal.oriondesign.art.br): \e[0m" && read -r url_docuseal
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite a Email SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_docuseal
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_docuseal
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP (ex: @Senha123_): \e[0m" && read -r senha_smtp_docuseal
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_docuseal
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a Porta SMTP (ex: 465): \e[0m" && read -r porta_smtp_docuseal
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_docuseal
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do docuseal
    echo -e "\e[33mDominio do docuseal:\e[97m $url_docuseal\e[0m"
    echo ""

    ## Informação sobre URL do docuseal
    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_docuseal\e[0m"
    echo ""

    ## Informação sobre URL do docuseal
    echo -e "\e[33mUser SMTP:\e[97m $user_smtp_docuseal\e[0m"
    echo ""    

    ## Informação sobre URL do docuseal
    echo -e "\e[33mSenha SMTP:\e[97m $senha_smtp_docuseal\e[0m"
    echo ""

    ## Informação sobre URL do docuseal
    echo -e "\e[33mHost SMTP:\e[97m $host_smtp_docuseal\e[0m"
    echo ""

    ## Informação sobre URL do docuseal
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_docuseal\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_docuseal

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO DOCUSEAL \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Docuseal iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "docuseal${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "docuseal${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO DOCUSEAL \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Pegar o dominio do email
dominio_smtp_docuseal="${email_smtp_docuseal}"

key_docuseal=$(openssl rand -hex 16)
key_docuseal2=$(openssl rand -hex 16)


## Criando a stack docuseal.yaml
cat > docuseal${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  docuseal${1:+_$1}:
    image: docuseal/docuseal:latest

    volumes:
      - docuseal${1:+_$1}_data:/data

    networks:
      - $nome_rede_interna

    environment:
    ## 🌐 Dados de Acesso
      - HOST=$url_docuseal
      - FORCE_SSL=true

    ## 🔐 Secret Key
      - SECRET_KEY_BASE=$key_docuseal

    ## 🗄️ Dados do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/docuseal${1:+_$1}

    ## 📧 Dados SMTP
      - SMTP_USERNAME=$user_smtp_docuseal
      - SMTP_PASSWORD=$senha_smtp_docuseal
      - SMTP_ADDRESS=$host_smtp_docuseal
      - SMTP_PORT=$porta_smtp_docuseal
      - SMTP_FROM=$email_smtp_docuseal
      - SMTP_DOMAIN=$dominio_smtp_docuseal
      - SMTP_AUTHENTICATION=login

    ## 📦 Dados do S3
      ##- AWS_ACCESS_KEY_ID=
      ##- AWS_SECRET_ACCESS_KEY=
      ##- S3_ATTACHMENTS_BUCKET=
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.docuseal${1:+_$1}.rule=Host(\`$url_docuseal\`)
        - traefik.http.services.docuseal${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.docuseal${1:+_$1}.service=docuseal${1:+_$1}
        - traefik.http.routers.docuseal${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.docuseal${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.docuseal${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  docuseal${1:+_$1}_data:
    external: true
    name: docuseal${1:+_$1}_data

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do docuseal"
fi
STACK_NAME="docuseal${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c docuseal.yaml docuseal > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do docuseal"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull docuseal/docuseal:latest

## Usa o serviço wait_docuseal para verificar se o serviço esta online
wait_stack docuseal${1:+_$1}_docuseal${1:+_$1}

telemetria Docuseal finalizado

cd dados_vps

cat > dados_docuseal${1:+_$1} <<EOL
[ DOCUSEAL ]

Dominio do docuseal: https://$url_docuseal

Usuario: Precisa de criar ao fazer o primeiro login

Senha: Precisa de criar ao fazer o primeiro login

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ DOCUSEAL ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_docuseal\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar ao fazer o primeiro login\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar ao fazer o primeiro login\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗  █████╗ ███████╗ █████╗ ███╗   ██╗ █████╗ 
## ██╔════╝ ██╔══██╗██╔══██╗██╔════╝██╔══██╗████╗  ██║██╔══██╗
## ██║  ███╗██████╔╝███████║█████╗  ███████║██╔██╗ ██║███████║
## ██║   ██║██╔══██╗██╔══██║██╔══╝  ██╔══██║██║╚██╗██║██╔══██║
## ╚██████╔╝██║  ██║██║  ██║██║     ██║  ██║██║ ╚████║██║  ██║
##  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝

ferramenta_monitor() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_monitor

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/4\e[0m"
    echo -en "\e[33mDigite o Dominio para o Grafana (ex: grafana.oriondesign.art.br): \e[0m" && read -r url_grafana
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 2/4\e[0m"
    echo -en "\e[33mDigite o Dominio para o Prometheus (ex: prometheus.oriondesign.art.br): \e[0m" && read -r url_prometheus
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 3/4\e[0m"
    echo -en "\e[33mDigite o Dominio para o cAdvisor (ex: cadvisor.oriondesign.art.br): \e[0m" && read -r url_cadvisor
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    echo -en "\e[33mDigite o Dominio para o NodeExporter (ex: node.oriondesign.art.br): \e[0m" && read -r url_nodeexporter
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_monitor
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do Grafana:\e[97m $url_grafana\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mDominio do Prometheus:\e[97m $url_prometheus\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mDominio do Cadvisor:\e[97m $url_cadvisor\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mDominio do NodeExporter:\e[97m $url_nodeexporter\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_monitor

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO GRAFANA + PROMETHEUS + CADVISOR \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Grafana iniciado

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• BAIXANDO RECURSOS \e[33m[2/4]\e[0m"
echo ""
sleep 1

mkdir blablabla
cd blablabla

git clone https://github.com/oriondesign2015/SetupOrion.git > /dev/null 2>&1

if [ -d "/opt/monitor-orion" ]; then
  sudo rm -r /opt/monitor-orion
fi
sudo mv /root/blablabla/SetupOrion/Extras/Grafana/monitor-orion /opt

cd

rm -r blablabla

cd

cd

## Criando arquivo datasource
cat > datasource.yml <<EOL
apiVersion: 1
datasources:
- name: Prometheus
  type: prometheus
  url: https://$url_prometheus
  isDefault: true
  access: proxy
  editable: true
EOL
if [ $? -eq 0 ]; then
    echo "1/4 - [ OK ] - Criando datasource.yml"
else
    echo "1/4 - [ OFF ] - Criando datasource.ym"
    echo "Não foi possivel criar o datasource"
fi


cp /root/datasource.yml /opt/monitor-orion/grafana/
if [ $? -eq 0 ]; then
    echo "2/6 - [ OK ] - Movendo datasource.yml para o diretório /opt/monitor-orion/grafana/"
else
    echo "2/6 - [ OFF ] - Movendo datasource.yml para o diretório /opt/monitor-orion/grafana/"
    echo "Não foi possivel copiar o datasource para o diretório opt"
fi

cp /root/datasource.yml /opt/monitor-orion/grafana/provisioning/datasources/
if [ $? -eq 0 ]; then
    echo "3/6 - [ OK ] - Movendo datasource.yml para o diretório /opt/monitor-orion/grafana/provisioning/datasources/"
else
    echo "3/6 - [ OFF ] - Movendo datasource.yml para o diretório /opt/monitor-orion/grafana/provisioning/datasources/"
    echo "Não foi possivel copiar o datasource para o diretório opt"
fi

rm /root/datasource.yml
if [ $? -eq 0 ]; then
    echo "4/6 - [ OK ] - Removendo datasource.yml do /root/"
else
    echo "4/6 - [ OFF ] - Removendo datasource.yml do /root/"
    echo "Não foi possivel deletar o datasource para o diretório opt"
fi

cd

## Criando arquivo prometheus yml
cat > prometheus.yml <<EOL
global:
  scrape_interval: 15s
  scrape_timeout: 10s
  evaluation_interval: 15s
alerting:
  alertmanagers:
  - static_configs:
    - targets: []
    scheme: http
    timeout: 10s
    api_version: v2
scrape_configs:
- job_name: prometheus
  honor_timestamps: true
  scrape_interval: 15s
  scrape_timeout: 10s
  metrics_path: /metrics
  scheme: http
  static_configs:
  - targets: ['$url_prometheus','$url_cadvisor','$url_nodeexporter']

EOL
if [ $? -eq 0 ]; then
    echo "5/6 - [ OK ] - Criando arquivo prometheus.yml"
else
    echo "5/6 - [ OFF ] - Criando arquivo prometheus.yml"
    echo "Não foi possivel criar o prometheus"
fi

mv /root/prometheus.yml /opt/monitor-orion/prometheus/
if [ $? -eq 0 ]; then
    echo "6/6 - [ OK ] - Movendo arquivo prometheus.yml para /opt/monitor-orion/prometheus/"
else
    echo "6/6 - [ OFF ] - Movendo arquivo prometheus.yml para /opt/monitor-orion/prometheus/"
    echo "Não foi possivel copiar o datasource para o diretório opt"
fi

cd
cd
echo ""

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO GRAFANA + PROMETHEUS + CADVISOR \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação das ferramentas

## Criando a stack monitor.yaml ou grafana.yaml
cat > monitor.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  prometheus:
    image: prom/prometheus:latest

    volumes:
      - /opt/monitor-orion/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml

    networks:
      - $nome_rede_interna

    ports:
      - "9191:9090"

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager    
      labels:
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.prometheus.rule=Host(\`$url_prometheus\`) ## Dominio para aplicação
        - traefik.http.routers.prometheus.entrypoints=websecure
        - traefik.http.routers.prometheus.priority=1
        - traefik.http.routers.prometheus.tls.certresolver=letsencryptresolver
        - traefik.http.routers.prometheus.service=prometheus
        - traefik.http.services.prometheus.loadbalancer.server.port=9090

## --------------------------- ORION --------------------------- ##

  grafana:
    image: grafana/grafana:latest

    volumes:
      - /opt/monitor-orion/grafana/grafana.ini:/etc/grafana/grafana.ini
      - /opt/monitor-orion/grafana/provisioning/datasources:/etc/grafana/provisioning/datasources
      - /opt/monitor-orion/grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards
      - /opt/monitor-orion/grafana/dashboards:/etc/grafana/dashboards

    networks:
      - $nome_rede_interna

    ports:
      - "3111:3000"

    links:
      - prometheus
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.grafana.rule=Host(\`$url_grafana\`) ## Dominio para aplicação
        - traefik.http.routers.grafana.entrypoints=websecure
        - traefik.http.routers.grafana.priority=1
        - traefik.http.routers.grafana.tls.certresolver=letsencryptresolver
        - traefik.http.routers.grafana.service=grafana
        - traefik.http.services.grafana.loadbalancer.server.port=3000

## --------------------------- ORION --------------------------- ##

  node-exporter:
    image: prom/node-exporter:latest
    restart: unless-stopped

    networks:
      - $nome_rede_interna

    ports:
      - "9100:9100"

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.node-exporter.rule=Host(\`$url_nodeexporter\`) ## Dominio para aplicação
        - traefik.http.routers.node-exporter.entrypoints=websecure
        - traefik.http.routers.node-exporter.priority=1
        - traefik.http.routers.node-exporter.tls.certresolver=letsencryptresolver
        - traefik.http.routers.node-exporter.service=node-exporter
        - traefik.http.services.node-exporter.loadbalancer.server.port=9100

## --------------------------- ORION --------------------------- ##

  cadvisor:
    image: gcr.io/cadvisor/cadvisor
    restart: unless-stopped

    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /sys/fs/cgroup:/sys/fs/cgroup
      - /var/lib/docker/:/var/lib/docker:ro

    networks:
      - $nome_rede_interna

    ports:
      - "8181:8080"

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager     
      labels:
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.cadvisor.rule=Host(\`$url_cadvisor\`) ## Dominio para aplicação
        - traefik.http.routers.cadvisor.entrypoints=websecure
        - traefik.http.routers.cadvisor.priority=1
        - traefik.http.routers.cadvisor.tls.certresolver=letsencryptresolver
        - traefik.http.routers.cadvisor.service=cadvisor
        - traefik.http.services.cadvisor.loadbalancer.server.port=8080

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Monitor"
fi
STACK_NAME="monitor"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c monitor.yaml monitor > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Monitor"
#fi

echo ""
sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull prom/prometheus:latest grafana/grafana:latest prom/node-exporter:latest gcr.io/cadvisor/cadvisor

## Usa o serviço wait_monitor para verificar se o serviço esta online
wait_stack monitor_prometheus monitor_grafana monitor_node-exporter monitor_cadvisor

telemetria Grafana finalizado

cd dados_vps

cat > dados_monitor <<EOL
[ MONITOR ]

Dominio Grafana: https://$url_grafana

Dominio Prometheus: https://$url_prometheus

Dominio cAdvisor: https://$url_cadvisor

Dominio NodeExporter: https://$url_nodeexporter

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ GRAFANA + PROMETHEUS + CADVISOR ]\e[0m"
echo ""

echo -e "\e[97mDominio Grafana:\e[33m https://$url_grafana\e[0m"
echo ""

echo -e "\e[97mUsuario Grafana:\e[33m admin\e[0m"
echo ""

echo -e "\e[97mSenha Grafana:\e[33m admin\e[0m"
echo -e "\e[97mDepois do primeiro login, será solicitado que você altere a senha.\e[0m"
echo ""

echo -e "\e[97mDominio Prometheus:\e[33m https://$url_prometheus\e[0m"
echo ""

echo -e "\e[97mDominio cAdvisor:\e[33m https://$url_cadvisor\e[0m"
echo ""

echo -e "\e[97mDominio NodeExporter:\e[33m https://$url_nodeexporter\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗ ██╗███████╗██╗   ██╗ █████╗ ██╗
## ██╔══██╗██║██╔════╝╚██╗ ██╔╝██╔══██╗██║
## ██║  ██║██║█████╗   ╚████╔╝ ███████║██║
## ██║  ██║██║██╔══╝    ╚██╔╝  ██╔══██║██║
## ██████╔╝██║██║        ██║██╗██║  ██║██║
## ╚═════╝ ╚═╝╚═╝        ╚═╝╚═╝╚═╝  ╚═╝╚═╝

ferramenta_dify() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_dify

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do Dify AI
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o Dify AI (ex: dify.oriondesign.art.br): \e[0m" && read -r url_dify
    echo ""

    ##Pergunta o Dominio do Dify AI
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite o dominio para o API do Dify AI (ex: api-dify.oriondesign.art.br): \e[0m" && read -r url_dify_api
    echo ""

    ##Pergunta o Dominio do Qdrant
    #read -r ip _ <<<$(hostname -I)
    #echo -e "\e[97mPasso$amarelo 2/10\e[0m"
    #echo -en "\e[33mDigite o dominio do Qdrant (ex: http://$ip  ou http://qdrant.oriondesign.art.br): \e[0m" && read -r url_quedrant
    #echo ""

    ##Pergunta a Api Key do Qdrant
    #key_dify_rand=$(openssl rand -hex 16)
    #echo -e "\e[97mPasso$amarelo 3/10\e[0m"
    #echo -en "\e[33mDigite a Api Key do Qdrant (ex: $key_dify_rand): \e[0m" && read -r apikey_qdrant
    #echo ""

   ###Pergunta o Email SMTP
   #echo -e "\e[97mPasso$amarelo 3/7\e[0m"
   #echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_dify
   #echo ""
    

    ###Pergunta o usuário do Email SMTP
    #echo -e "\e[97mPasso$amarelo 4/7\e[0m"
    #echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    #echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_email_dify
    #echo ""
#
    ### Pergunta a senha do SMTP
    #echo -e "\e[97mPasso$amarelo 5/7\e[0m"
    #echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    #echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_dify
    #echo ""
#
    ### Pergunta o Host SMTP do email
    #echo -e "\e[97mPasso$amarelo 6/7\e[0m"
    #echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_dify
    #echo ""
#
    ### Pergunta a porta SMTP do email
    #echo -e "\e[97mPasso$amarelo 7/7\e[0m"
    #echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_dify
    #echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_dify
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Builder
    echo -e "\e[33mDominio do Dify AI:\e[97m $url_dify\e[0m"
    echo ""

    ## Informação sobre URL do API do Dify AI
    echo -e "\e[33mDominio do API do Dify AI:\e[97m $url_dify_api\e[0m"
    echo ""

    ## Informação sobre URL do Viewer
    #echo -e "\e[33mDominio do Qdrant:\e[97m $url_quedrant\e[0m"
    #echo ""

    ## Informação sobre a versão da ferramenta
    #echo -e "\e[33mApi Key Qdrant:\e[97m $apikey_qdrant\e[0m"
    #echo ""    

    ### Informação sobre Email
    #echo -e "\e[33mEmail do SMTP:\e[97m $email_dify\e[0m"
    #echo ""
#
    ### Informação sobre UserSMTP
    #echo -e "\e[33mUser do SMTP:\e[97m $user_email_dify\e[0m"
    #echo ""
#
    ### Informação sobre Senha do Email
    #echo -e "\e[33mSenha do Email:\e[97m $senha_email_dify\e[0m"
    #echo ""
#
    ### Informação sobre Host SMTP
    #echo -e "\e[33mHost SMTP do Email:\e[97m $smtp_email_dify\e[0m"
    #echo ""
#
    ### Informação sobre Porta SMTP
    #echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_dify\e[0m"
    #echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_dify

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO DIFY \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria Dify iniciado

cd

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/5]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "dify${1:+_$1}"
    criar_banco_postgres_da_stack "dify${1:+_$1}_plugin"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "dify${1:+_$1}"
    criar_banco_postgres_da_stack "dify${1:+_$1}_plugin"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[3/5]\e[0m"
echo ""
sleep 1

pegar_senha_minio

minio.bucket dify${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi
echo ""

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO DIFY \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
secret_key=$(openssl rand -hex 16)
sandbox_api_key=$(openssl rand -hex 16)
token_weaviate=$(openssl rand -hex 16)
token_apikey_plugins=$(openssl rand -hex 16)
token_deamon=$(openssl rand -hex 16)
sandbox_key=$(openssl rand -hex 16)
cookie_domain="$(echo "$url_dify_api" | sed 's/^[^.]\+//')"

## Criando a stack dify.yaml
cat > dify${1:+_$1}.yaml <<EOL
version: '3.7'
services:

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_api:
    image: langgenius/dify-api:latest

    volumes:
      - dify${1:+_$1}_storage:/app/api/storage

    networks:
      - $nome_rede_interna
      - dify${1:+_$1}_ssrf_proxy_network

    environment:
      ## 🌐 URLs e Endpoints
      - CONSOLE_API_URL=https://$url_dify_api/console/api
      - CONSOLE_WEB_URL=https://$url_dify
      - SERVICE_API_URL=https://$url_dify_api/service/api
      - TRIGGER_URL=https://$url_dify_api/triggers
      - APP_API_URL=https://$url_dify_api/api
      - APP_WEB_URL=https://$url_dify
      - FILES_URL=https://$url_dify_api/files
      - INTERNAL_FILES_URL=http://dify${1:+_$1}_api:5001/files
      - CHECK_UPDATE_URL=https://updates.dify.ai
      - OPENAI_API_BASE=https://api.openai.com/v1

      ## 🌍 Localização e Idioma
      - LANG=en_US.UTF-8
      - LC_ALL=en_US.UTF-8
      - PYTHONIOENCODING=utf-8

      ## 📝 Logging
      - LOG_LEVEL=INFO
      - LOG_FILE=/app/logs/server.log
      - LOG_FILE_MAX_SIZE=20
      - LOG_FILE_BACKUP_COUNT=5
      - LOG_DATEFORMAT=%Y-%m-%d %H:%M:%S
      - LOG_TZ=UTC
      - DEBUG=false
      - FLASK_DEBUG=false
      - ENABLE_REQUEST_LOGGING=False

      ## 🔐 Segurança e Autenticação
      - SECRET_KEY=$secret_key
      - ACCESS_TOKEN_EXPIRE_MINUTES=60
      - REFRESH_TOKEN_EXPIRE_DAYS=30

      ## ⚙️ Configuração do Servidor
      - DEPLOY_ENV=PRODUCTION
      - DIFY_BIND_ADDRESS=0.0.0.0
      - DIFY_PORT=5001
      - SERVER_WORKER_AMOUNT=1
      - SERVER_WORKER_CLASS=gevent
      - SERVER_WORKER_CONNECTIONS=10
      - GUNICORN_TIMEOUT=360
      - MIGRATION_ENABLED=true
      - FILES_ACCESS_TIMEOUT=300
      - APP_DEFAULT_ACTIVE_REQUESTS=0
      - APP_MAX_ACTIVE_REQUESTS=0
      - APP_MAX_EXECUTION_TIME=1200
      - RESPECT_XFORWARD_HEADERS_ENABLED=true

      ## 🔄 Celery e Workers
      - CELERY_WORKER_CLASS=
      - CELERY_WORKER_AMOUNT=
      - CELERY_AUTO_SCALE=false
      - CELERY_MAX_WORKERS=
      - CELERY_MIN_WORKERS=

      ## 🛠️ API Tools
      - API_TOOL_DEFAULT_CONNECT_TIMEOUT=10
      - API_TOOL_DEFAULT_READ_TIMEOUT=60

      ## 🌐 Website Crawlers
      - ENABLE_WEBSITE_JINAREADER=true
      - ENABLE_WEBSITE_FIRECRAWL=true
      - ENABLE_WEBSITE_WATERCRAWL=true

      ## 📄 Frontend
      - NEXT_PUBLIC_ENABLE_SINGLE_DOLLAR_LATEX=false

      ## 🗄️ Banco de Dados (PostgreSQL)
      - DB_TYPE=postgresql
      - DB_USERNAME=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_DATABASE=dify${1:+_$1}
      - SQLALCHEMY_POOL_SIZE=30
      - SQLALCHEMY_MAX_OVERFLOW=10
      - SQLALCHEMY_POOL_RECYCLE=3600
      - SQLALCHEMY_ECHO=false
      - SQLALCHEMY_POOL_PRE_PING=false
      - SQLALCHEMY_POOL_USE_LIFO=false
      - SQLALCHEMY_POOL_TIMEOUT=30

      ## 🚀 Redis
      - REDIS_HOST=dify${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_USERNAME=
      - REDIS_PASSWORD=
      - REDIS_USE_SSL=false
      - REDIS_DB=0
      - CELERY_BROKER_URL=redis://dify${1:+_$1}_redis:6379/1
      - CELERY_BACKEND=redis

      ## 🍪 Cookies e CORS
      - WEB_API_CORS_ALLOW_ORIGINS=https://$url_dify
      - CONSOLE_CORS_ALLOW_ORIGINS=https://$url_dify
      - COOKIE_DOMAIN=$cookie_domain
      - NEXT_PUBLIC_COOKIE_DOMAIN=$cookie_domain

      ## 💾 Storage
      - STORAGE_TYPE=s3
      - S3_ENDPOINT=https://$url_s3
      - S3_BUCKET_NAME=dify${1:+-$1}
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_REGION=eu-south
      - S3_ADDRESS_STYLE=path
      - S3_USE_AWS_MANAGED_IAM=false

      ## 🔍 Vector Store (Weaviate)
      - VECTOR_STORE=weaviate
      - VECTOR_INDEX_NAME_PREFIX=Vector_index
      - WEAVIATE_ENDPOINT=http://dify${1:+_$1}_weaviate:8080
      - WEAVIATE_API_KEY=$token_weaviate
      - WEAVIATE_GRPC_ENDPOINT=grpc://dify${1:+_$1}_weaviate:50051
      - WEAVIATE_TOKENIZATION=word

      ## 🌐 Traefik
      - TRAEFIK_DOMAIN=$url_dify_api

      ## 🎯 Modo e Sentry
      - MODE=api
      - SENTRY_DSN=
      - SENTRY_TRACES_SAMPLE_RATE=1.0
      - SENTRY_PROFILES_SAMPLE_RATE=1.0

      ## 🔌 Plugins
      - PLUGIN_DAEMON_URL=http://dify${1:+_$1}_plugin_daemon:5002
      - PLUGIN_DAEMON_KEY=$token_deamon
      - PLUGIN_REMOTE_INSTALL_HOST=localhost
      - PLUGIN_REMOTE_INSTALL_PORT=5003
      - PLUGIN_MAX_PACKAGE_SIZE=52428800
      - INNER_API_KEY_FOR_PLUGIN=$token_apikey_plugins

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.dify${1:+_$1}_api.rule=Host(\`$url_dify_api\`) && !PathPrefix(\`/service/api\`)
        - traefik.http.routers.dify${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.dify${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.routers.dify${1:+_$1}_api.tls=true
        - traefik.http.routers.dify${1:+_$1}_api.service=dify${1:+_$1}_api
        - traefik.http.services.dify${1:+_$1}_api.loadbalancer.server.port=5001
        - traefik.http.services.dify${1:+_$1}_api.loadbalancer.passHostHeader=true
        - traefik.http.routers.dify${1:+_$1}_api_service.rule=Host(\`$url_dify_api\`) && PathPrefix(\`/service/api\`)
        - traefik.http.routers.dify${1:+_$1}_api_service.entrypoints=websecure
        - traefik.http.routers.dify${1:+_$1}_api_service.tls.certresolver=letsencryptresolver
        - traefik.http.routers.dify${1:+_$1}_api_service.tls=true
        - traefik.http.routers.dify${1:+_$1}_api_service.service=dify${1:+_$1}_api
        - traefik.http.routers.dify${1:+_$1}_api_service.priority=20
        - traefik.http.middlewares.dify${1:+_$1}_api_stripprefix.stripprefix.prefixes=/service/api
        - traefik.http.middlewares.dify${1:+_$1}_api_stripprefix.stripprefix.forceSlash=false
        - traefik.http.routers.dify${1:+_$1}_api_service.middlewares=dify${1:+_$1}_api_stripprefix

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_worker:
    image: langgenius/dify-api:latest

    volumes:
      - dify${1:+_$1}_storage:/app/api/storage

    networks:
      - $nome_rede_interna
      - dify${1:+_$1}_ssrf_proxy_network

    environment:
      ## 🌐 URLs e Endpoints
      - CONSOLE_API_URL=https://$url_dify_api/console/api
      - CONSOLE_WEB_URL=https://$url_dify
      - SERVICE_API_URL=https://$url_dify_api/service/api
      - TRIGGER_URL=https://$url_dify_api/triggers
      - APP_API_URL=https://$url_dify_api/api
      - APP_WEB_URL=https://$url_dify
      - FILES_URL=https://$url_dify_api/files
      - INTERNAL_FILES_URL=http://dify${1:+_$1}_api:5001/files
      - CHECK_UPDATE_URL=https://updates.dify.ai
      - OPENAI_API_BASE=https://api.openai.com/v1

      ## 🌍 Localização e Idioma
      - LANG=en_US.UTF-8
      - LC_ALL=en_US.UTF-8
      - PYTHONIOENCODING=utf-8

      ## 📝 Logging
      - LOG_LEVEL=INFO
      - LOG_FILE=/app/logs/server.log
      - LOG_FILE_MAX_SIZE=20
      - LOG_FILE_BACKUP_COUNT=5
      - LOG_DATEFORMAT=%Y-%m-%d %H:%M:%S
      - LOG_TZ=UTC
      - DEBUG=false
      - FLASK_DEBUG=false
      - ENABLE_REQUEST_LOGGING=False

      ## 🔐 Segurança e Autenticação
      - SECRET_KEY=$secret_key
      - ACCESS_TOKEN_EXPIRE_MINUTES=60
      - REFRESH_TOKEN_EXPIRE_DAYS=30

      ## ⚙️ Configuração do Servidor
      - DEPLOY_ENV=PRODUCTION
      - DIFY_BIND_ADDRESS=0.0.0.0
      - DIFY_PORT=5001
      - SERVER_WORKER_AMOUNT=1
      - SERVER_WORKER_CLASS=gevent
      - SERVER_WORKER_CONNECTIONS=10
      - GUNICORN_TIMEOUT=360
      - MIGRATION_ENABLED=true
      - FILES_ACCESS_TIMEOUT=300
      - APP_DEFAULT_ACTIVE_REQUESTS=0
      - APP_MAX_ACTIVE_REQUESTS=0
      - APP_MAX_EXECUTION_TIME=1200

      ## 🔄 Celery e Workers
      - CELERY_WORKER_CLASS=
      - CELERY_WORKER_AMOUNT=
      - CELERY_AUTO_SCALE=false
      - CELERY_MAX_WORKERS=
      - CELERY_MIN_WORKERS=

      ## 🛠️ API Tools
      - API_TOOL_DEFAULT_CONNECT_TIMEOUT=10
      - API_TOOL_DEFAULT_READ_TIMEOUT=60

      ## 🌐 Website Crawlers
      - ENABLE_WEBSITE_JINAREADER=true
      - ENABLE_WEBSITE_FIRECRAWL=true
      - ENABLE_WEBSITE_WATERCRAWL=true

      ## 📄 Frontend
      - NEXT_PUBLIC_ENABLE_SINGLE_DOLLAR_LATEX=false

      ## 🗄️ Banco de Dados (PostgreSQL)
      - DB_TYPE=postgresql
      - DB_USERNAME=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_DATABASE=dify${1:+_$1}
      - SQLALCHEMY_POOL_SIZE=30
      - SQLALCHEMY_MAX_OVERFLOW=10
      - SQLALCHEMY_POOL_RECYCLE=3600
      - SQLALCHEMY_ECHO=false
      - SQLALCHEMY_POOL_PRE_PING=false
      - SQLALCHEMY_POOL_USE_LIFO=false
      - SQLALCHEMY_POOL_TIMEOUT=30

      ## 🚀 Redis
      - REDIS_HOST=dify${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_USERNAME=
      - REDIS_PASSWORD=
      - REDIS_USE_SSL=false
      - REDIS_DB=0
      - CELERY_BROKER_URL=redis://dify${1:+_$1}_redis:6379/1
      - CELERY_BACKEND=redis

      ## 🍪 Cookies e CORS
      - WEB_API_CORS_ALLOW_ORIGINS=https://$url_dify
      - CONSOLE_CORS_ALLOW_ORIGINS=https://$url_dify
      - COOKIE_DOMAIN=$cookie_domain
      - NEXT_PUBLIC_COOKIE_DOMAIN=$cookie_domain

      ## 💾 Storage
      - STORAGE_TYPE=s3
      - S3_ENDPOINT=https://$url_s3
      - S3_BUCKET_NAME=dify${1:+-$1}
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_REGION=eu-south
      - S3_ADDRESS_STYLE=path
      - S3_USE_AWS_MANAGED_IAM=false

      ## 🔍 Vector Store (Weaviate)
      - VECTOR_STORE=weaviate
      - VECTOR_INDEX_NAME_PREFIX=vectorindex ## ou Vector_index
      - WEAVIATE_ENDPOINT=http://dify${1:+_$1}_weaviate:8080
      - WEAVIATE_API_KEY=$token_weaviate
      - WEAVIATE_GRPC_ENDPOINT=grpc://dify${1:+_$1}_weaviate:50051
      - WEAVIATE_TOKENIZATION=word

      ## 🎯 Modo e Sentry
      - MODE=worker
      - SENTRY_DSN=
      - SENTRY_TRACES_SAMPLE_RATE=1.0
      - SENTRY_PROFILES_SAMPLE_RATE=1.0

      ## 🔌 Plugins
      - PLUGIN_DAEMON_KEY=$token_deamon
      - PLUGIN_MAX_PACKAGE_SIZE=52428800
      - INNER_API_KEY_FOR_PLUGIN=$token_apikey_plugins

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_worker_beat:
    image: langgenius/dify-api:latest

    networks:
      - $nome_rede_interna
      - dify${1:+_$1}_ssrf_proxy_network

    environment:
      ## 🌐 URLs e Endpoints
      - CONSOLE_API_URL=https://$url_dify_api/console/api
      - CONSOLE_WEB_URL=https://$url_dify
      - SERVICE_API_URL=https://$url_dify_api/service/api
      - TRIGGER_URL=https://$url_dify_api/triggers
      - APP_API_URL=https://$url_dify_api/api
      - APP_WEB_URL=https://$url_dify
      - FILES_URL=https://$url_dify_api/files
      - INTERNAL_FILES_URL=http://dify${1:+_$1}_api:5001/files
      - CHECK_UPDATE_URL=https://updates.dify.ai
      - OPENAI_API_BASE=https://api.openai.com/v1

      ## 🌍 Localização e Idioma
      - LANG=en_US.UTF-8
      - LC_ALL=en_US.UTF-8
      - PYTHONIOENCODING=utf-8

      ## 📝 Logging
      - LOG_LEVEL=INFO
      - LOG_FILE=/app/logs/server.log
      - LOG_FILE_MAX_SIZE=20
      - LOG_FILE_BACKUP_COUNT=5
      - LOG_DATEFORMAT=%Y-%m-%d %H:%M:%S
      - LOG_TZ=UTC
      - DEBUG=false
      - FLASK_DEBUG=false
      - ENABLE_REQUEST_LOGGING=False

      ## 🔐 Segurança e Autenticação
      - SECRET_KEY=$secret_key
      - ACCESS_TOKEN_EXPIRE_MINUTES=60
      - REFRESH_TOKEN_EXPIRE_DAYS=30

      ## ⚙️ Configuração do Servidor
      - DEPLOY_ENV=PRODUCTION
      - DIFY_BIND_ADDRESS=0.0.0.0
      - DIFY_PORT=5001
      - SERVER_WORKER_AMOUNT=1
      - SERVER_WORKER_CLASS=gevent
      - SERVER_WORKER_CONNECTIONS=10
      - GUNICORN_TIMEOUT=360
      - MIGRATION_ENABLED=true
      - FILES_ACCESS_TIMEOUT=300
      - APP_DEFAULT_ACTIVE_REQUESTS=0
      - APP_MAX_ACTIVE_REQUESTS=0
      - APP_MAX_EXECUTION_TIME=1200

      ## 🔄 Celery e Workers
      - CELERY_WORKER_CLASS=
      - CELERY_WORKER_AMOUNT=
      - CELERY_AUTO_SCALE=false
      - CELERY_MAX_WORKERS=
      - CELERY_MIN_WORKERS=

      ## 🛠️ API Tools
      - API_TOOL_DEFAULT_CONNECT_TIMEOUT=10
      - API_TOOL_DEFAULT_READ_TIMEOUT=60

      ## 🌐 Website Crawlers
      - ENABLE_WEBSITE_JINAREADER=true
      - ENABLE_WEBSITE_FIRECRAWL=true
      - ENABLE_WEBSITE_WATERCRAWL=true

      ## 📄 Frontend
      - NEXT_PUBLIC_ENABLE_SINGLE_DOLLAR_LATEX=false

      ## 🗄️ Banco de Dados (PostgreSQL)
      - DB_TYPE=postgresql
      - DB_USERNAME=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_DATABASE=dify${1:+_$1}
      - SQLALCHEMY_POOL_SIZE=30
      - SQLALCHEMY_MAX_OVERFLOW=10
      - SQLALCHEMY_POOL_RECYCLE=3600
      - SQLALCHEMY_ECHO=false
      - SQLALCHEMY_POOL_PRE_PING=false
      - SQLALCHEMY_POOL_USE_LIFO=false
      - SQLALCHEMY_POOL_TIMEOUT=30

      ## 🚀 Redis
      - REDIS_HOST=dify${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_USERNAME=
      - REDIS_PASSWORD=
      - REDIS_USE_SSL=false
      - REDIS_DB=0
      - CELERY_BROKER_URL=redis://dify${1:+_$1}_redis:6379/1
      - CELERY_BACKEND=redis

      ## 🍪 Cookies e CORS
      - WEB_API_CORS_ALLOW_ORIGINS=https://$url_dify
      - CONSOLE_CORS_ALLOW_ORIGINS=https://$url_dify
      - COOKIE_DOMAIN=$cookie_domain
      - NEXT_PUBLIC_COOKIE_DOMAIN=$cookie_domain

      ## 💾 Storage
      - STORAGE_TYPE=s3
      - S3_ENDPOINT=https://$url_s3
      - S3_BUCKET_NAME=dify${1:+-$1}
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_REGION=eu-south
      - S3_ADDRESS_STYLE=path
      - S3_USE_AWS_MANAGED_IAM=false

      ## 🔍 Vector Store (Weaviate)
      - VECTOR_STORE=weaviate
      - VECTOR_INDEX_NAME_PREFIX=Vector_index
      - WEAVIATE_ENDPOINT=http://dify${1:+_$1}_weaviate:8080
      - WEAVIATE_API_KEY=$token_weaviate
      - WEAVIATE_GRPC_ENDPOINT=grpc://dify${1:+_$1}_weaviate:50051
      - WEAVIATE_TOKENIZATION=word

      ## 🎯 Modo
      - MODE=beat

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_web:
    image: langgenius/dify-web:latest

    networks:
      - $nome_rede_interna

    environment:
      ## 🌐 URLs e Endpoints
      - TRAEFIK_DOMAIN=$url_dify
      - CONSOLE_API_URL=https://$url_dify_api
      - APP_API_URL=https://$url_dify_api
      - NEXT_PUBLIC_API_PREFIX=https://$url_dify_api/console/api
      - NEXT_PUBLIC_PUBLIC_API_PREFIX=https://$url_dify_api/api
      - MARKETPLACE_API_URL=https://marketplace.dify.ai
      - MARKETPLACE_URL=https://marketplace.dify.ai

      ## 🍪 Cookies
      - NEXT_PUBLIC_COOKIE_DOMAIN=$cookie_domain

      ## 📊 Monitoramento e Observabilidade
      - SENTRY_DSN=
      - NEXT_TELEMETRY_DISABLED=0

      ## ⚙️ Configurações de Performance
      - TEXT_GENERATION_TIMEOUT_MS=60000
      - PM2_INSTANCES=2

      ## 🔒 Segurança e CSP
      - CSP_WHITELIST=
      - ALLOW_EMBED=false
      - ALLOW_UNSAFE_DATA_SCHEME=false

      ## 🛠️ Configurações de Workflow
      - TOP_K_MAX_VALUE=
      - INDEXING_MAX_SEGMENTATION_TOKENS_LENGTH=
      - LOOP_NODE_MAX_COUNT=100
      - MAX_TOOLS_NUM=10
      - MAX_PARALLEL_LIMIT=10
      - MAX_ITERATIONS_NUM=99
      - MAX_TREE_DEPTH=50

      ## 🌐 Website Crawlers
      - ENABLE_WEBSITE_JINAREADER=true
      - ENABLE_WEBSITE_FIRECRAWL=true
      - ENABLE_WEBSITE_WATERCRAWL=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        # Traefik labels para o frontend
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.dify${1:+_$1}_web.rule=Host(\`$url_dify\`)
        - traefik.http.routers.dify${1:+_$1}_web.entrypoints=websecure
        - traefik.http.routers.dify${1:+_$1}_web.tls.certresolver=letsencryptresolver
        - traefik.http.routers.dify${1:+_$1}_web.priority=10
        - traefik.http.services.dify${1:+_$1}_web.loadbalancer.server.port=3000

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_redis:
    image: redis:latest
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - dify${1:+_$1}_redis_data:/data

    networks:
      - $nome_rede_interna

    environment:
      ## 🚀 Configuração do Redis
      - REDISCLI_AUTH=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_weaviate:
    image: semitechnologies/weaviate:latest

    volumes:
      - dify${1:+_$1}_weaviate_data:/var/lib/weaviate

    networks:
      - $nome_rede_interna

    environment:
      ## 🔍 Configuração do Weaviate
      - PERSISTENCE_DATA_PATH=/var/lib/weaviate
      - QUERY_DEFAULTS_LIMIT=25
      - DEFAULT_VECTORIZER_MODULE=none
      - CLUSTER_HOSTNAME=node1
      - DISABLE_TELEMETRY=false

      ## 🔐 Autenticação e Autorização
      - AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED=false
      - AUTHENTICATION_APIKEY_ENABLED=true
      - AUTHENTICATION_APIKEY_ALLOWED_KEYS=$token_weaviate
      - AUTHENTICATION_APIKEY_USERS=hello@dify.ai
      - AUTHORIZATION_ADMINLIST_ENABLED=true
      - AUTHORIZATION_ADMINLIST_USERS=hello@dify.ai

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_sandbox:
    image: langgenius/dify-sandbox:latest

    volumes:
      - dify${1:+_$1}_sandbox_dependencies:/dependencies
      - dify${1:+_$1}_sandbox_conf:/conf

    networks:
      - dify${1:+_$1}_ssrf_proxy_network

    environment:
      ## 🔒 Configuração do Sandbox
      - API_KEY=$sandbox_api_key
      - GIN_MODE=release
      - WORKER_TIMEOUT=15
      - SANDBOX_PORT=8194

      ## 🌐 Rede e Proxy
      - ENABLE_NETWORK=true
      - HTTP_PROXY=http://dify${1:+_$1}_ssrf_proxy:3128
      - HTTPS_PROXY=http://dify${1:+_$1}_ssrf_proxy:3128

      ## 📦 Dependências Python
      - PIP_MIRROR_URL=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_plugin_daemon:
    image: langgenius/dify-plugin-daemon:latest-local

    volumes:
      - dify${1:+_$1}_plugin_daemon:/app/storage

    networks:
      - $nome_rede_interna

    environment:
      ## 🌐 URLs e Endpoints
      - CONSOLE_API_URL=https://$url_dify_api/console/api
      - CONSOLE_WEB_URL=https://$url_dify
      - SERVICE_API_URL=https://$url_dify_api/service/api
      - TRIGGER_URL=https://$url_dify_api/triggers
      - APP_API_URL=https://$url_dify_api/api
      - APP_WEB_URL=https://$url_dify
      - FILES_URL=https://$url_dify_api/files
      - INTERNAL_FILES_URL=http://dify${1:+_$1}_api:5001/files
      - CHECK_UPDATE_URL=https://updates.dify.ai
      - OPENAI_API_BASE=https://api.openai.com/v1

      ## 🌍 Localização e Idioma
      - LANG=en_US.UTF-8
      - LC_ALL=en_US.UTF-8
      - PYTHONIOENCODING=utf-8

      ## 📝 Logging
      - LOG_LEVEL=INFO
      - LOG_FILE=/app/logs/server.log
      - LOG_FILE_MAX_SIZE=20
      - LOG_FILE_BACKUP_COUNT=5
      - LOG_DATEFORMAT=%Y-%m-%d %H:%M:%S
      - LOG_TZ=UTC
      - DEBUG=false
      - FLASK_DEBUG=false
      - ENABLE_REQUEST_LOGGING=False

      ## 🔐 Segurança e Autenticação
      - SECRET_KEY=$secret_key
      - INIT_PASSWORD=
      - ACCESS_TOKEN_EXPIRE_MINUTES=60
      - REFRESH_TOKEN_EXPIRE_DAYS=30

      ## ⚙️ Configuração do Servidor
      - DEPLOY_ENV=PRODUCTION
      - DIFY_BIND_ADDRESS=0.0.0.0
      - DIFY_PORT=5001
      - SERVER_WORKER_AMOUNT=1
      - SERVER_WORKER_CLASS=gevent
      - SERVER_WORKER_CONNECTIONS=10
      - GUNICORN_TIMEOUT=360
      - MIGRATION_ENABLED=true
      - FILES_ACCESS_TIMEOUT=300
      - APP_DEFAULT_ACTIVE_REQUESTS=0
      - APP_MAX_ACTIVE_REQUESTS=0
      - APP_MAX_EXECUTION_TIME=1200

      ## 🔄 Celery e Workers
      - CELERY_WORKER_CLASS=
      - CELERY_WORKER_AMOUNT=
      - CELERY_AUTO_SCALE=false
      - CELERY_MAX_WORKERS=
      - CELERY_MIN_WORKERS=

      ## 🛠️ API Tools
      - API_TOOL_DEFAULT_CONNECT_TIMEOUT=10
      - API_TOOL_DEFAULT_READ_TIMEOUT=60

      ## 🌐 Website Crawlers
      - ENABLE_WEBSITE_JINAREADER=true
      - ENABLE_WEBSITE_FIRECRAWL=true
      - ENABLE_WEBSITE_WATERCRAWL=true

      ## 📄 Frontend
      - NEXT_PUBLIC_ENABLE_SINGLE_DOLLAR_LATEX=false

      ## 🗄️ Banco de Dados (PostgreSQL)
      - DB_TYPE=postgresql
      - DB_USERNAME=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_DATABASE=dify${1:+_$1}_plugin
      - SQLALCHEMY_POOL_SIZE=30
      - SQLALCHEMY_MAX_OVERFLOW=10
      - SQLALCHEMY_POOL_RECYCLE=3600
      - SQLALCHEMY_ECHO=false
      - SQLALCHEMY_POOL_PRE_PING=false
      - SQLALCHEMY_POOL_USE_LIFO=false
      - SQLALCHEMY_POOL_TIMEOUT=30

      ## 🚀 Redis
      - REDIS_HOST=dify${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_USERNAME=
      - REDIS_PASSWORD=
      - REDIS_USE_SSL=false
      - REDIS_DB=0
      - CELERY_BROKER_URL=redis://dify${1:+_$1}_redis:6379/1
      - CELERY_BACKEND=redis

      ## 🍪 Cookies e CORS
      - WEB_API_CORS_ALLOW_ORIGINS=https://$url_dify
      - CONSOLE_CORS_ALLOW_ORIGINS=https://$url_dify
      - COOKIE_DOMAIN=$cookie_domain
      - NEXT_PUBLIC_COOKIE_DOMAIN=$cookie_domain

      ## 💾 Storage
      - STORAGE_TYPE=s3
      - S3_ENDPOINT=https://$url_s3
      - S3_BUCKET_NAME=dify${1:+-$1}
      - S3_ACCESS_KEY=$S3_ACCESS_KEY
      - S3_SECRET_KEY=$S3_SECRET_KEY
      - S3_REGION=eu-south
      - S3_ADDRESS_STYLE=path
      - S3_USE_AWS_MANAGED_IAM=false

      ## 🔍 Vector Store (Weaviate)
      - VECTOR_STORE=weaviate
      - VECTOR_INDEX_NAME_PREFIX=Vector_index
      - WEAVIATE_ENDPOINT=http://dify${1:+_$1}_weaviate:8080
      - WEAVIATE_API_KEY=$token_weaviate
      - WEAVIATE_GRPC_ENDPOINT=grpc://dify${1:+_$1}_weaviate:50051
      - WEAVIATE_TOKENIZATION=word

      ## 🔌 Configuração do Plugin Daemon
      - SERVER_PORT=5002
      - SERVER_KEY=$token_deamon
      - MAX_PLUGIN_PACKAGE_SIZE=52428800
      - PPROF_ENABLED=false
      - DIFY_INNER_API_URL=http://dify${1:+_$1}_api:5001
      - DIFY_INNER_API_KEY=$token_apikey_plugins
      - PLUGIN_REMOTE_INSTALLING_HOST=0.0.0.0
      - PLUGIN_REMOTE_INSTALLING_PORT=5003
      - PLUGIN_WORKING_PATH=/app/storage/cwd
      - FORCE_VERIFYING_SIGNATURE=true
      - PYTHON_ENV_INIT_TIMEOUT=120
      - PLUGIN_MAX_EXECUTION_TIMEOUT=600
      - PLUGIN_STDIO_BUFFER_SIZE=1024
      - PLUGIN_STDIO_MAX_BUFFER_SIZE=5242880
      - PIP_MIRROR_URL=
      - PLUGIN_STORAGE_TYPE=local
      - PLUGIN_STORAGE_LOCAL_ROOT=/app/storage
      - PLUGIN_INSTALLED_PATH=plugin
      - PLUGIN_PACKAGE_CACHE_PATH=plugin_packages
      - PLUGIN_MEDIA_CACHE_PATH=assets

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.docker.network=$nome_rede_interna
        - traefik.http.routers.dify${1:+_$1}_plugin.rule=Host(\`$url_dify\`) && PathPrefix(\`/e/\`)
        - traefik.http.routers.dify${1:+_$1}_plugin.entrypoints=websecure
        - traefik.http.routers.dify${1:+_$1}_plugin.tls.certresolver=letsencryptresolver
        - traefik.http.services.dify${1:+_$1}_plugin.loadbalancer.server.port=5002

## --------------------------- ORION --------------------------- ##

  dify${1:+_$1}_ssrf_proxy:
    image: ubuntu/squid:latest

    networks:
      - $nome_rede_interna
      - dify${1:+_$1}_ssrf_proxy_network

    environment:
      ## 🔒 Configuração do SSRF Proxy
      - HTTP_PORT=3128
      - COREDUMP_DIR=/var/spool/squid
      - REVERSE_PROXY_PORT=8194

      ## 🎯 Sandbox
      - SANDBOX_HOST=dify${1:+_$1}_sandbox
      - SANDBOX_PORT=8194

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##

volumes:
  dify${1:+_$1}_storage:
    external: true
    name: dify${1:+_$1}_storage
  dify${1:+_$1}_postgres_data:
    external: true
    name: dify${1:+_$1}_postgres_data
  dify${1:+_$1}_redis_data:
    external: true
    name: dify${1:+_$1}_redis_data
  dify${1:+_$1}_weaviate_data:
    external: true
    name: dify${1:+_$1}_weaviate_data
  dify${1:+_$1}_sandbox_dependencies:
    external: true
    name: dify${1:+_$1}_sandbox_dependencies
  dify${1:+_$1}_sandbox_conf:
    external: true
    name: dify${1:+_$1}_sandbox_conf
  dify${1:+_$1}_plugin_daemon:
    external: true
    name: dify${1:+_$1}_plugin_daemon

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
  dify${1:+_$1}_ssrf_proxy_network:
    driver: overlay
    internal: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Dify Ai"
fi
STACK_NAME="dify${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c dify.yaml dify > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do Dify Ai"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest ubuntu/squid:latest langgenius/dify-api:latest langgenius/dify-web:latest semitechnologies/weaviate:latest langgenius/dify-sandbox:0.2.12 langgenius/dify-plugin-daemon:latest-local

## Usa o serviço wait_dify para verificar se o serviço esta online
wait_stack  dify${1:+_$1}_dify${1:+_$1}_api dify${1:+_$1}_dify${1:+_$1}_worker dify${1:+_$1}_dify${1:+_$1}_worker_beat dify${1:+_$1}_dify${1:+_$1}_web dify${1:+_$1}_dify${1:+_$1}_redis dify${1:+_$1}_dify${1:+_$1}_weaviate dify${1:+_$1}_dify${1:+_$1}_sandbox dify${1:+_$1}_dify${1:+_$1}_plugin_daemon dify${1:+_$1}_dify${1:+_$1}_ssrf_proxy

telemetria Dify finalizado

cd dados_vps

cat > dados_dify${1:+_$1} <<EOL
[ DIFY AI ]

Dominio do dify: https://$url_dify

Email: Precisa de criar na primeira vez que entrar no Dify AI

Senha: Precisa de criar na primeira vez que entrar no Dify AI
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ DIFY AI ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_dify\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa de criar na primeira vez que entrar no Dify AI.\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar na primeira vez que entrar no Dify AI.\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██╗     ██╗      █████╗ ███╗   ███╗ █████╗ 
## ██╔═══██╗██║     ██║     ██╔══██╗████╗ ████║██╔══██╗
## ██║   ██║██║     ██║     ███████║██╔████╔██║███████║
## ██║   ██║██║     ██║     ██╔══██║██║╚██╔╝██║██╔══██║
## ╚██████╔╝███████╗███████╗██║  ██║██║ ╚═╝ ██║██║  ██║
##  ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝

ferramenta_ollama() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_ollama

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o WebUI Ollama (ex: ollama.oriondesign.art.br): \e[0m" && read -r url_ollama
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite o dominio para a API Ollama (ex: apiollama.oriondesign.art.br): \e[0m" && read -r url_apiollama
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_ollama
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o WebUI Ollama:\e[97m $url_ollama\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mDominio para a API do Ollama:\e[97m $url_apiollama\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_ollama

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO OLLAMA \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Ollama iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO OLLAMA \e[33m[3/4]\e[0m"
echo ""
sleep 1

WEBUI_SECRET_KEY=$(openssl rand -hex 16)

## Criando a stack ollama.yaml
cat > ollama${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  ollama${1:+_$1}:
    image: ollama/ollama:latest

    volumes:
      - ollama${1:+_$1}_data:/root/.ollama

    networks:
      - $nome_rede_interna

    #ports:
    #  - 11434:11434

    environment:
    ## ⚙️ Ambiente do Ollama
      - OLLAMA_HOST=0.0.0.0

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.ollama${1:+_$1}.rule=Host(\`$url_apiollama\`)
        - traefik.http.routers.ollama${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.ollama${1:+_$1}.priority=1
        - traefik.http.routers.ollama${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.ollama${1:+_$1}.service=ollama${1:+_$1}
        - traefik.http.services.ollama${1:+_$1}.loadbalancer.server.port=11434
        - traefik.http.services.ollama${1:+_$1}.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

  openwebui${1:+_$1}:
    image: ghcr.io/open-webui/open-webui:main

    volumes:
      - open${1:+_$1}_webui:/app/backend/data

    networks:
      - $nome_rede_interna

    #ports:
    #  - 8085:8080

    environment:
    ## 🌐 Base URL da API
       - OLLAMA_BASE_URL=https://$url_apiollama
    
    ## 🔒 Secret Key
       - WEBUI_SECRET_KEY=$WEBUI_SECRET_KEY

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.openwebui${1:+_$1}.rule=Host(\`$url_ollama\`)
        - traefik.http.routers.openwebui${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.openwebui${1:+_$1}.priority=1
        - traefik.http.routers.openwebui${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.openwebui${1:+_$1}.service=openwebui${1:+_$1}
        - traefik.http.services.openwebui${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.services.openwebui${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  ollama${1:+_$1}_data:
    external: true
    name: ollama${1:+_$1}_data
  open${1:+_$1}_webui:
    external: true
    name: open${1:+_$1}_webui
  
networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Ollama"
fi
STACK_NAME="ollama${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c ollama.yaml ollama > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Ollama"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ollama/ollama:latest ghcr.io/open-webui/open-webui:main

## Usa o serviço wait_nocodb para verificar se o serviço esta online
wait_stack ollama${1:+_$1}_openwebui${1:+_$1} ollama${1:+_$1}_ollama${1:+_$1}

telemetria Ollama finalizado

cd dados_vps

cat > dados_ollama${1:+_$1} <<EOL
[ OLLAMA ]

Dominio do Open WebUI: https://$url_ollama

Dominio da API Ollama: https://$url_apiollama

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ OLLAMA ]\e[0m"
echo ""

echo -e "\e[33mOpen WebUI:\e[97m https://$url_ollama\e[0m"
echo ""

echo -e "\e[33mOllama API:\e[97m https://$url_apiollama\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗ ███████╗███████╗██╗███╗   ██╗███████╗
## ██╔══██╗██╔════╝██╔════╝██║████╗  ██║██╔════╝
## ███████║█████╗  █████╗  ██║██╔██╗ ██║█████╗  
## ██╔══██║██╔══╝  ██╔══╝  ██║██║╚██╗██║██╔══╝  
## ██║  ██║██║     ██║     ██║██║ ╚████║███████╗
## ╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚═╝  ╚═══╝╚══════╝

ferramenta_affine() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_affine

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o Affine (ex: affine.oriondesign.art.br): \e[0m" && read -r url_affine
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o Email de Admin (ex: contato@oriondesign.art.br): \e[0m" && read -r email_affine
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
    echo -en "\e[33mDigite a Senha de Admin (ex: @Senha123_): \e[0m" && read -r senha_affine
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_affine
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do affine
    echo -e "\e[33mDominio do Affine:\e[97m $url_affine\e[0m"
    echo ""

    ## Informação sobre URL do affine
    echo -e "\e[33mEmail de Admin:\e[97m $email_affine\e[0m"
    echo ""

    ## Informação sobre URL do affine
    echo -e "\e[33mSenha de Admin:\e[97m $senha_affine\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_affine

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO AFFINE \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Affine iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO PGVECTOR \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe PgVector e redis instalado
## Se tiver ele vai criar um banco de dados no PgVector ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container PgVector e cria banco no PgVector
verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - PgVector já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do PgVector"
    criar_banco_pgvector_da_stack "affine${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "affine${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO AFFINE \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack affine.yaml
cat > affine${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  affine${1:+_$1}_app:
    image: ghcr.io/toeverything/affine:stable
    
    volumes:
      - affine${1:+_$1}_storage:/root/.affine/storage
      - affine${1:+_$1}_config:/root/.affine/config
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 URL Externa (ajuste conforme seu domínio)
      - AFFINE_SERVER_EXTERNAL_URL=https://$url_affine
      - AFFINE_SERVER_HTTPS=true

    ## 🗄️ Banco do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_pgvector@pgvector:5432/affine${1:+_$1}?sslmode=disable
      
    ## ⚡ Configuração do Redis
      - REDIS_SERVER_HOST=affine${1:+_$1}_redis
      - REDIS_SERVER_PORT=6379
      - REDIS_SERVER_PASSWORD=
      
    # ⚙️ Configurações do Serviço
      - AFFINE_SERVER_HOST=0.0.0.0
      - AFFINE_SERVER_PORT=3010
      - NODE_ENV=production
      
    ## 💾 Armazenamento
      - STORAGE_PROVIDER=fs
      - STORAGE_PATH=/root/.affine/storage
      
    ## 🚀 Funcionalidades
      - AFFINE_INDEXER_ENABLED=true
      - AFFINE_ENABLE_OAUTH=false
      
    ## ✉️ Configurações de E-mail (SMTP)
      #- MAILER_FROM=
      #- MAILER_HOST=
      #- MAILER_PORT=
      #- MAILER_USER=
      #- MAILER_PASSWORD=
      #- MAILER_SECURE=false
      
    ## 🤖 Copilot
      - COPILOT_ENABLED=false
      
    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.affine${1:+_$1}_app.rule=Host(\`$url_affine\`)
        - traefik.http.services.affine${1:+_$1}_app.loadbalancer.server.port=3010
        - traefik.http.routers.affine${1:+_$1}_app.service=affine${1:+_$1}_app
        - traefik.http.routers.affine${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.affine${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.affine${1:+_$1}_app.tls=true
        - traefik.frontend.headers.STSPreload=true
        - traefik.frontend.headers.STSSeconds=31536000

## --------------------------- ORION --------------------------- ##

  affine${1:+_$1}_migration:
    image: ghcr.io/toeverything/affine:stable
    command: ['sh', '-c', 'node ./scripts/self-host-predeploy.js']
    
    volumes:
      - affine${1:+_$1}_storage:/root/.affine/storage
      - affine${1:+_$1}_config:/root/.affine/config
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🌐 URL Externa (ajuste conforme seu domínio)
      - AFFINE_SERVER_EXTERNAL_URL=https://$url_affine
      - AFFINE_SERVER_HTTPS=true

    ## 🗄️ Banco do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_pgvector@pgvector:5432/affine${1:+_$1}?sslmode=disable
      
    ## ⚡ Configuração do Redis
      - REDIS_SERVER_HOST=affine${1:+_$1}_redis
      - REDIS_SERVER_PORT=6379
      - REDIS_SERVER_PASSWORD=
      
    # ⚙️ Configurações do Serviço
      - AFFINE_SERVER_HOST=0.0.0.0
      - AFFINE_SERVER_PORT=3010
      - NODE_ENV=production
      
    ## 💾 Armazenamento
      - STORAGE_PROVIDER=fs
      - STORAGE_PATH=/root/.affine/storage
      
    ## 🚀 Funcionalidades
      - AFFINE_INDEXER_ENABLED=true
      - AFFINE_ENABLE_OAUTH=false
      
    ## ✉️ Configurações de E-mail (SMTP)
      #- MAILER_FROM=
      #- MAILER_HOST=
      #- MAILER_PORT=
      #- MAILER_USER=
      #- MAILER_PASSWORD=
      #- MAILER_SECURE=false
      
    ## 🤖 Copilot
      - COPILOT_ENABLED=false
    
    deploy:
      restart_policy:
        condition: none
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  affine${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - affine${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  affine${1:+_$1}_storage:
    external: true
    name: affine${1:+_$1}_storage
  affine${1:+_$1}_config:
    external: true
    name: affine${1:+_$1}_config
  affine${1:+_$1}_redis:
    external: true
    name: affine${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Affine"
fi
STACK_NAME="affine${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c affine.yaml affine > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Affine"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/toeverything/affine:stable

## Usa o serviço wait_stack "affine" para verificar se o serviço esta online
wait_stack affine${1:+_$1}_affine${1:+_$1}_redis affine${1:+_$1}_affine${1:+_$1}_app

telemetria Affine finalizado

cd dados_vps

cat > dados_affine${1:+_$1} <<EOL
[ AFFINE ]

Dominio do Affine: https://$url_affine

Usuario: $email_affine

Senha: $senha_affine

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ AFFINE ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_affine\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $email_affine\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $senha_affine\e[0m"
echo ""

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗ ██╗██████╗ ███████╗ ██████╗████████╗██╗   ██╗███████╗
## ██╔══██╗██║██╔══██╗██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔════╝
## ██║  ██║██║██████╔╝█████╗  ██║        ██║   ██║   ██║███████╗
## ██║  ██║██║██╔══██╗██╔══╝  ██║        ██║   ██║   ██║╚════██║
## ██████╔╝██║██║  ██║███████╗╚██████╗   ██║   ╚██████╔╝███████║
## ╚═════╝ ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚══════╝
                                                                  
ferramenta_directus() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_directus

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/7\e[0m"
    echo -en "\e[33mDigite o dominio para o Directus (ex: directus.oriondesign.art.br): \e[0m" && read -r url_directus
    echo ""

     ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/7\e[0m"
    echo -en "\e[33mDigite a Email de Admin (ex: contato@oriondesign.art.br): \e[0m" && read -r email_directus
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/7\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
    echo -en "\e[33mDigite a Senha para o Admin (ex: @Senha123_): \e[0m" && read -r senha_directus
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/7\e[0m"
    echo -en "\e[33mDigite a Email SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_directus
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 5/7\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP (ex: @Senha123_): \e[0m" && read -r senha_smtp_directus
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 6/7\e[0m"
    echo -en "\e[33mDigite o Host SMTP (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_directus
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 7/7\e[0m"
    echo -en "\e[33mDigite a Porta SMTP (ex: 465): \e[0m" && read -r porta_smtp_directus
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_directus
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do directus
    echo -e "\e[33mDominio do Directus:\e[97m $url_directus\e[0m"
    echo ""

    ## Informação sobre URL do directus
    echo -e "\e[33mEmail de Admin:\e[97m $email_directus\e[0m"
    echo ""

    ## Informação sobre URL do directus
    echo -e "\e[33mSenha de Admin:\e[97m $senha_directus\e[0m"
    echo ""

    ## Informação sobre URL do directus
    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_directus\e[0m"
    echo ""

    ## Informação sobre URL do directus
    echo -e "\e[33mSenha SMTP:\e[97m $senha_smtp_directus\e[0m"
    echo ""

    ## Informação sobre URL do directus
    echo -e "\e[33mHost SMTP:\e[97m $host_smtp_directus\e[0m"
    echo ""

    ## Informação sobre URL do directus
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_directus\e[0m"
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_directus" -eq 465 ]; then
    ssl_smtp_directus=true
    else
    ssl_smtp_directus=false
    fi
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_directus

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO DIRECTUS \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria Directus iniciado
## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/5]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "directus${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "directus${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[3/5]\e[0m"
echo ""
sleep 1

pegar_senha_minio
minio.bucket directus${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
    echo ""
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO DIRECTUS \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Gerar Secret Key
key_directus=$(openssl rand -hex 16)
key_directus2=$(openssl rand -hex 16)

## Criando a stack directus.yaml
cat > directus${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  directus${1:+_$1}_app:
    image: directus/directus:latest

    volumes:
      - directus${1:+_$1}_uploads:/directus/uploads
      - directus${1:+_$1}_data:/directus/database

    networks:
      - $nome_rede_interna

    environment:
    ## 🔗 Dados de acesso
      - ADMIN_EMAIL=$email_directus
      - ADMIN_PASSWORD=$senha_directus
      - PUBLIC_URL=https://$url_directus

    ## 📧 Dados SMTP
      - EMAIL_SMTP_USER=$email_smtp_directus
      - EMAIL_SMTP_PASSWORD=$senha_smtp_directus
      - EMAIL_SMTP_HOST=$host_smtp_directus
      - EMAIL_SMTP_PORT=$porta_smtp_directus
      - EMAIL_SMTP_SECURE=$ssl_smtp_directus

    ## 🗃️ Dados MinIO
      - STORAGE_s3_KEY=$S3_ACCESS_KEY
      - STORAGE_s3_SECRET=$S3_SECRET_KEY
      - STORAGE_s3_BUCKET=directus${1:+-$1}
      - STORAGE_s3_REGION=eu-south
      - STORAGE_s3_ENDPOINT=$url_s3

    ## 🔗 Redis
      - CACHE_ENABLED=true
      - CACHE_AUTO_PURGE=true
      - CACHE_STORE=redis
      - REDIS=redis://redis:6379

    ## 🔐 Secret Keys & Env
      - KEY=$key_directus
      - SECRET=$key_directus2
      - APP_ENV=production

    ## 🐘 Dados Postgres
      - DB_CLIENT=postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_DATABASE=directus${1:+_$1}
      - DB_USER=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_CONNECTION_STRING=postgresql://postgres:$senha_postgres@postgres:5432/directus${1:+_$1}
      - DB_PREFIX=drcts_

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.directus${1:+_$1}_app.rule=Host(\`$url_directus\`)
        - traefik.http.services.directus${1:+_$1}_app.loadbalancer.server.port=8055
        - traefik.http.routers.directus${1:+_$1}_app.service=directus${1:+_$1}_app
        - traefik.http.routers.directus${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.directus${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.directus${1:+_$1}_app.tls=true

## --------------------------- ORION --------------------------- ##

  directus${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - directus${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  directus${1:+_$1}_uploads:
    external: true
    name: directus${1:+_$1}_uploads
  directus${1:+_$1}_data:
    external: true
    name: directus${1:+_$1}_data
  directus${1:+_$1}_redis:
    external: true
    name: directus${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    attachable: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do directus"
fi
STACK_NAME="directus${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c directus.yaml directus > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do directus"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest directus/directus:latest

## Usa o serviço wait_tack "directus" para verificar se o serviço esta online
wait_stack directus${1:+_$1}_directus${1:+_$1}_redis directus${1:+_$1}_directus${1:+_$1}_app

telemetria Directus finalizado

cd dados_vps

cat > dados_directus${1:+_$1} <<EOL
[ DIRECTUS ]

Dominio do directus: https://$url_directus

Usuario: $email_directus

Senha: $senha_directus

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ DIRECTUS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_directus\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $email_directus\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $senha_directus\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗   ██╗ █████╗ ██╗   ██╗██╗  ████████╗██╗    ██╗ █████╗ ██████╗ ██████╗ ███████╗███╗   ██╗
## ██║   ██║██╔══██╗██║   ██║██║  ╚══██╔══╝██║    ██║██╔══██╗██╔══██╗██╔══██╗██╔════╝████╗  ██║
## ██║   ██║███████║██║   ██║██║     ██║   ██║ █╗ ██║███████║██████╔╝██║  ██║█████╗  ██╔██╗ ██║
## ╚██╗ ██╔╝██╔══██║██║   ██║██║     ██║   ██║███╗██║██╔══██║██╔══██╗██║  ██║██╔══╝  ██║╚██╗██║
##  ╚████╔╝ ██║  ██║╚██████╔╝███████╗██║   ╚███╔███╔╝██║  ██║██║  ██║██████╔╝███████╗██║ ╚████║
##   ╚═══╝  ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝    ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚═╝  ╚═══╝                                                                                    

ferramenta_vaultwarden() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_vaultwarden

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o VaultWarden (ex: vaultwarden.oriondesign.art.br): \e[0m" && read -r url_vaultwarden
    echo ""
    
    ## Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite um Email para o SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_vaultwarden
    echo ""

    ## Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_vaultwarden
    echo ""
    
    ## Pergunta a Senha SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do email (ex: @Senha123_): \e[0m" && read -r senha_vaultwarden
    echo ""
    
    ## Pergunta o Host SMTP
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do email (ex: smtp.hostinger.com): \e[0m" && read -r host_vaultwarden
    echo ""
    
    ## Pergunta a Porta SMTP 
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a Porta SMTP do email (ex: 465): \e[0m" && read -r porta_vaultwarden
    echo ""
    
    if [ "$porta_vaultwarden" -eq 465 ] || [ "$porta_vaultwarden" -eq 25 ]; then
        ssl_vaultwarden=force_tls
    else
        ssl_vaultwarden=starttls
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_vaultwarden
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio:\e[97m $url_vaultwarden\e[0m"
    echo ""
    
    ## Informação sobre Email
    echo -e "\e[33mEmail SMTP:\e[97m $email_vaultwarden\e[0m"
    echo ""

    ## Informação sobre Usuário do Email
    echo -e "\e[33mUsuário do Email:\e[97m $user_smtp_vaultwarden\e[0m"
    echo ""
    
    ## Informação sobre Senha
    echo -e "\e[33mSenha SMTP:\e[97m $senha_vaultwarden\e[0m"
    echo ""
    
    ## Informação sobre Host
    echo -e "\e[33mHost SMTP:\e[97m $host_vaultwarden\e[0m"
    echo ""
    
    ## Informação sobre Porta
    echo -e "\e[33mPorta SMTP:\e[97m $porta_vaultwarden\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_vaultwarden

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO VAULTWARDEN \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria VaultWarden iniciado

## Nada nada nada.. só para aparecer a mensagem de passo.

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "vaultwarden${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "vaultwarden${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1


## Mensagem de Passo
echo -e "\e[97m• INSTALANDO VAULTWARDEN \e[33m[3/4]\e[0m"
echo ""
sleep 1

token_admin=$(openssl rand -hex 16)

## Criando a stack vaultwarden.yaml
cat > vaultwarden${1:+_$1}.yaml <<-EOF
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  vaultwarden${1:+_$1}:
    image: vaultwarden/server:latest

    volumes:
      - vaultwarden${1:+_$1}_data:/data

    networks:
      - $nome_rede_interna

    #ports:
    #  - 1973:80

    environment:
    ## 🌐 Dominio do Dashboard
      - WEB_VAULT_ENABLED=true
      - DOMAIN=https://$url_vaultwarden
    
    ## 👁️‍🗨️ Configurações de Administrador
      - ADMIN_TOKEN=$token_admin
      - ADMIN_SESSION_LIFETIME=5

    ## 🔐 Permitir novos registros
      - SIGNUPS_ALLOWED=true ## true = permitir novos registros | false = não permitir novos registros

    ## 🐘 Dados do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/vaultwarden${1:+_$1}

    ## 📧 Dados do SMTP
      - SMTP_FROM=$email_vaultwarden
      - SMTP_USERNAME=$user_smtp_vaultwarden
      - SMTP_PASSWORD=$senha_vaultwarden
      - SMTP_HOST=$host_vaultwarden
      - SMTP_PORT=$porta_vaultwarden
      - SMTP_SECURITY=$ssl_vaultwarden

    ## 🔗 Configuração do Websocket
      - WEBSOCKET_ENABLED=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.vaultwarden${1:+_$1}.rule=Host(\`$url_vaultwarden\`)"
        - "traefik.http.routers.vaultwarden${1:+_$1}.service=vaultwarden${1:+_$1}"
        - "traefik.http.routers.vaultwarden${1:+_$1}.entrypoints=websecure"
        - "traefik.http.services.vaultwarden${1:+_$1}.loadbalancer.server.port=80"
        - "traefik.http.routers.vaultwarden${1:+_$1}.tls=true"
        - "traefik.http.routers.vaultwarden${1:+_$1}.tls.certresolver=letsencryptresolver"
        - "traefik.http.services.vaultwarden${1:+_$1}.loadbalancer.passHostHeader=true"
        - "traefik.http.routers.vaultwarden${1:+_$1}.middlewares=compresstraefik"
        - "traefik.http.middlewares.compresstraefik.compress=true"
        - "traefik.docker.network=$nome_rede_interna"

## --------------------------- ORION --------------------------- ##

volumes:
  vaultwarden${1:+_$1}_data:
    external: true
    name: vaultwarden${1:+_$1}_data

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOF
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do vaultwarden"
fi
STACK_NAME="vaultwarden${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c vaultwarden.yaml vaultwarden > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do vaultwarden"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull vaultwarden/server:latest

## Usa o serviço wait_vaultwarden para verificar se o serviço esta online
wait_stack vaultwarden${1:+_$1}_vaultwarden${1:+_$1}

telemetria VaultWarden finalizado

cd dados_vps

cat > dados_vaultwarden${1:+_$1} <<EOL
[ VAULTWARDEN ]

Dominio do vaultwarden: https://$url_vaultwarden

Token do /admin: $token_admin

Email: Precisa de criar dentro do vaultwarden

Senha: Precisa de criar dentro do vaultwarden
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ VAULTWARDEN ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_vaultwarden\e[0m"
echo ""

echo -e "\e[33mToken do /admin:\e[97m $token_admin\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa de criar dentro do VaultWarden\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar dentro do VaultWarden\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗███████╗██╗  ██╗████████╗ ██████╗██╗      ██████╗ ██╗   ██╗██████╗ 
## ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝██╔════╝██║     ██╔═══██╗██║   ██║██╔══██╗
## ██╔██╗ ██║█████╗   ╚███╔╝    ██║   ██║     ██║     ██║   ██║██║   ██║██║  ██║
## ██║╚██╗██║██╔══╝   ██╔██╗    ██║   ██║     ██║     ██║   ██║██║   ██║██║  ██║
## ██║ ╚████║███████╗██╔╝ ██╗   ██║   ╚██████╗███████╗╚██████╔╝╚██████╔╝██████╔╝
## ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝    ╚═════╝╚══════╝ ╚═════╝  ╚═════╝ ╚═════╝ 

ferramenta_nextcloud() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_nextcloud

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o NextCloud (ex: nextcloud.oriondesign.art.br): \e[0m" && read -r url_nextcloud
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o Usuario para o NextCloud (ex: orion): \e[0m" && read -r user_nextcloud
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Minimo 8 caracteres. Use Letras MAIUSCULAS e minusculas, numero e um caractere especial @ ou _"
    echo -en "\e[33mDigite o Senha o Usuario (ex: @Senha123_): \e[0m" && read -r pass_nextcloud
    echo ""


    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_nextcloud
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do nextcloud
    echo -e "\e[33mDominio do NextCloud:\e[97m $url_nextcloud\e[0m"
    echo ""

    ## Informação sobre URL do nextcloud
    echo -e "\e[33mUsuario do NextCloud:\e[97m $user_nextcloud\e[0m"
    echo ""

    ## Informação sobre URL do nextcloud
    echo -e "\e[33mSenha do NextCloud:\e[97m $pass_nextcloud\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO NEXTCLOUD \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria NextCloud iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "nextcloud${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "nextcloud${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO NEXTCLOUD \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack nextcloud.yaml
cat > nextcloud${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  nextcloud${1:+_$1}_app:
    image: nextcloud:latest

    volumes:
      - nextcloud${1:+_$1}_data:/var/www/html

    networks:
      - $nome_rede_interna

    #ports:
    #  - 8282:80

    environment:
    ## 🔐 Dados de acesso:
      - NEXTCLOUD_ADMIN_USER=$user_nextcloud
      - NEXTCLOUD_ADMIN_PASSWORD=$pass_nextcloud

    ## 🐘 Dados do Postgres
      - POSTGRES_HOST=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_DB=nextcloud${1:+_$1}
      - POSTGRES_PASSWORD=$senha_postgres

    ## 🔗 Dados do Redis
      - REDIS_HOST=nextcloud${1:+_$1}_redis

    ## 🌐 Configurações para HTTPS
      - OVERWRITEPROTOCOL=https
      - TRUSTED_PROXIES=127.0.0.1

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.nextcloud${1:+_$1}_app.rule=Host(\`$url_nextcloud\`)
        - traefik.http.services.nextcloud${1:+_$1}_app.loadbalancer.server.port=80
        - traefik.http.routers.nextcloud${1:+_$1}_app.service=nextcloud${1:+_$1}_app
        - traefik.http.routers.nextcloud${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.nextcloud${1:+_$1}_app.entrypoints=web,websecure
        - traefik.http.routers.nextcloud${1:+_$1}_app.tls=true
        - traefik.http.routers.nextcloud${1:+_$1}_app.middlewares=nextcloud${1:+_$1}_app_redirectregex
        - traefik.http.middlewares.nextcloud${1:+_$1}_app_redirectregex.redirectregex.permanent=true
        - traefik.http.middlewares.nextcloud${1:+_$1}_app_redirectregex.redirectregex.regex=https://(.*)/.well-known/(?:card|cal)dav
        - traefik.http.middlewares.nextcloud${1:+_$1}_app_redirectregex.redirectregex.replacement=https://$$1/remote.php/dav

## --------------------------- ORION --------------------------- ##

  nextcloud${1:+_$1}_cron:
    image: nextcloud:latest
    entrypoint: /cron.sh

    volumes:
      - nextcloud${1:+_$1}_data:/var/www/html

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  nextcloud${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - nextcloud${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  nextcloud${1:+_$1}_data:
    external: true
    name: nextcloud${1:+_$1}_data
  nextcloud${1:+_$1}_redis:
    external: true
    name: nextcloud${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do nextcloud"
fi
STACK_NAME="nextcloud${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c nextcloud.yaml nextcloud > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do nextcloud"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull nextcloud:latest


## Usa o serviço wait_nextcloud para verificar se o serviço esta online
wait_stack nextcloud${1:+_$1}_nextcloud${1:+_$1}_redis nextcloud${1:+_$1}_nextcloud${1:+_$1}_app nextcloud${1:+_$1}_nextcloud${1:+_$1}_cron

telemetria NextCloud finalizado

cd dados_vps

# Caminho do arquivo onde a substituição será feita
wait_30_sec
arquivo_next_cloud="/var/lib/docker/volumes/nextcloud${1:+_$1}_data/_data/config/config.php"

# Comando sed para substituir a linha, utilizando a variável
sed -i "s/0 => 'localhost'/0 => '$url_nextcloud'/" "$arquivo_next_cloud"
sleep 5
## Só por garantia
sed -i "s/0 => 'localhost'/0 => '$url_nextcloud'/" "$arquivo_next_cloud"
sleep 5
sed -i "/'maintenance' => false,/a \  'overwriteprotocol' => 'https',\n  'trusted_proxies' => ['127.0.0.1']," "$arquivo_next_cloud"
sleep 5

cat > dados_nextcloud${1:+_$1} <<EOL
[ NEXTCLOUD ]

Dominio do NextCloud: https://$url_nextcloud

Usuario: $user_nextcloud

Senha: $pass_nextcloud
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ NEXTCLOUD ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_nextcloud\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_nextcloud\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_nextcloud\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗████████╗██████╗  █████╗ ██████╗ ██╗
## ██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██║
## ███████╗   ██║   ██████╔╝███████║██████╔╝██║
## ╚════██║   ██║   ██╔══██╗██╔══██║██╔═══╝ ██║
## ███████║   ██║   ██║  ██║██║  ██║██║     ██║
## ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝
                                                           
ferramenta_strapi() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_strapi

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Strapi (ex: strapi.oriondesign.art.br): \e[0m" && read -r url_strapi
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_strapi
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o strapi:\e[97m $url_strapi\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_strapi

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO STRAPI \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Strapi iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "strapi${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "strapi${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO STRAPI \e[33m[3/4]\e[0m"
echo ""
sleep 1

jwt_secret=$(openssl rand -hex 16)

admin_jwt=$(openssl rand -hex 16)

app_key=$(openssl rand -hex 16)

senha_mysql=$(openssl rand -hex 16)

## Criando a stack strapi.yaml
cat > strapi${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  strapi${1:+_$1}:
    image: strapi/strapi:latest

    volumes:
      - strapi${1:+_$1}_data:/srv/app

    networks:
      - $nome_rede_interna

    environment:
    ## 🐘 Dados Postgres
      - DATABASE_CLIENT=pg
      - DATABASE_HOST=postgres
      - DATABASE_NAME=strapi${1:+_$1}
      - DATABASE_PORT=5432
      - DATABASE_USERNAME=postgres
      - DATABASE_PASSWORD=$senha_postgres

    ## 🔐 Secret Keys
      - JWT_SECRET=$jwt_secret
      - ADMIN_JWT_SECRET=$admin_jwt
      - APP_KEYS=$app_key

    ## 🌐 Outros dados
      - NODE_ENV=production
      - STRAPI_TELEMETRY_DISABLED=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.strapi${1:+_$1}.rule=Host(\`$url_strapi\`)
        - traefik.http.routers.strapi${1:+_$1}.entrypoints=web,websecure
        - traefik.http.routers.strapi${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.strapi${1:+_$1}.service=strapi${1:+_$1}
        - traefik.http.services.strapi${1:+_$1}.loadbalancer.server.port=1337
        - traefik.http.services.strapi${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  strapi${1:+_$1}_data:
    external: true
    name: strapi${1:+_$1}_data

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Strapi"
fi
STACK_NAME="strapi${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c strapi.yaml strapi #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do Strapi"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull strapi/strapi:latest

## Usa o serviço wait_stack "strapi" para verificar se o serviço esta online
wait_stack strapi${1:+_$1}_strapi${1:+_$1}

wait_30_sec
wait_30_sec

telemetria Strapi finalizado

cd dados_vps

cat > dados_strapi${1:+_$1} <<EOL
[ STRAPI ]

Dominio do Strapi: https://$url_strapi

Usuario: Precisa criar no primeiro acesso do Strapi

Senha: Precisa criar no primeiro acesso do Strapi
EOL

cd
cd

## Espera 30 segundos
wait_30_sec
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ STRAPI ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_strapi\e[0m"
echo ""

echo -e "\e[33mSetup Inicial:\e[97m https://$url_strapi/admin\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do strapi\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do strapi\e[0m"
echo ""

echo "> Aguarde aproximadamente 5 minutos antes de acessar devido à migração em andamento."

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗ ██╗  ██╗██████╗     ███╗   ███╗██╗   ██╗     █████╗ ██████╗ ███╗   ███╗██╗███╗   ██╗
## ██╔══██╗██║  ██║██╔══██╗    ████╗ ████║╚██╗ ██╔╝    ██╔══██╗██╔══██╗████╗ ████║██║████╗  ██║
## ██████╔╝███████║██████╔╝    ██╔████╔██║ ╚████╔╝     ███████║██║  ██║██╔████╔██║██║██╔██╗ ██║
## ██╔═══╝ ██╔══██║██╔═══╝     ██║╚██╔╝██║  ╚██╔╝      ██╔══██║██║  ██║██║╚██╔╝██║██║██║╚██╗██║
## ██║     ██║  ██║██║         ██║ ╚═╝ ██║   ██║       ██║  ██║██████╔╝██║ ╚═╝ ██║██║██║ ╚████║
## ╚═╝     ╚═╝  ╚═╝╚═╝         ╚═╝     ╚═╝   ╚═╝       ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝
                                                                                                                                               
ferramenta_phpmyadmin() {

## Verifica os recursos
recursos 1 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_phpmyadmin

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o PhpMyAdmin (ex: phpmyadmin.oriondesign.art.br): \e[0m" && read -r url_phpmyadmin
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite o Host MySQL (ex: mysql ou 1.111.111.11:3306): \e[0m" && read -r host_phpmyadmin
    echo ""
    if [[ "$host_phpmyadmin" == *:* ]]; then
      PORTA_MYSQL_PMA=$(echo "$host_phpmyadmin" | cut -d':' -f2)
      HOST_MYSQL_PMA=$(echo "$host_phpmyadmin" | cut -d':' -f1)
    else
      PORTA_MYSQL_PMA=3306
      HOST_MYSQL_PMA=$host_phpmyadmin
    fi

    ##Pergunta o Dominio para a ferramenta
    #echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    #echo -en "\e[33mDigite o Usuario MySQL  (ex: oriondesign): \e[0m" && read -r user_phpmyadmin
    #echo ""

    ##Pergunta o Dominio para a ferramenta
    #echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    #echo -e "$amarelo--> Sem caracteres especiais: \!#$"
    #echo -en "\e[33mDigite a Senha MySQL (ex: @Senha123_): \e[0m" && read -r pass_phpmyadmin
    #echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_phpmyadmin
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o PhpMyAdmin:\e[97m $url_phpmyadmin\e[0m"
    echo ""

    ##Informação do Dominio
    echo -e "\e[33mHost MySQL:\e[97m $host_phpmyadmin\e[0m"
    echo ""

    ###Informação do Dominio
    #echo -e "\e[33mUsuario MySQL:\e[97m $user_phpmyadmin\e[0m"
    #echo ""

    ###Informação do Dominio
    #echo -e "\e[33mSenha MYSQL:\e[97m $pass_phpmyadmin\e[0m"
    #echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_phpmyadmin

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PHPMYADMIN \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria PhpMyAdmin iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO PHPMYADMIN \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack phpmyadmin.yaml
cat > phpmyadmin${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  phpmyadmin${1:+_$1}:
    image: phpmyadmin/phpmyadmin:latest
    command: ["apache2-foreground"]

    networks:
      - $nome_rede_interna

    environment:
    ## 🐘 Dados do MySQL
      - PMA_HOSTS=$HOST_MYSQL_PMA
      - PMA_PORT=$PORTA_MYSQL_PMA
      
    ## 🔐 Dado de acesso
      #- PMA_USER=
      #- PMA_PASSWORD=
      - PMA_ABSOLUTE_URI=https://$url_phpmyadmin
      
    ## 📤 Limite de Upload
      - UPLOAD_LIMIT=10M

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M
      labels:
        - traefik.enable=true
        - traefik.http.routers.phpmyadmin${1:+_$1}.rule=Host(\`$url_phpmyadmin\`)
        - traefik.http.routers.phpmyadmin${1:+_$1}.entrypoints=web,websecure
        - traefik.http.routers.phpmyadmin${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.phpmyadmin${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.phpmyadmin${1:+_$1}.service=phpmyadmin${1:+_$1}

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do phpmyadmin"
fi
STACK_NAME="phpmyadmin${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c phpmyadmin.yaml phpmyadmin #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do phpmyadmin"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull phpmyadmin/phpmyadmin:latest

## Usa o serviço wait_stack "phpmyadmin" para verificar se o serviço esta online
wait_stack phpmyadmin${1:+_$1}_phpmyadmin${1:+_$1}

telemetria PhpMyAdmin finalizado

cd
cd dados_vps

cat > dados_phpmyadmin${1:+_$1} <<EOL
[ PHPMYADMIN ]

Dominio do phpmyadmin: https://$url_phpmyadmin

Usuario: Os mesmos do seu MySQL

Senha: Os mesmos do seu MySQL
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PHPMYADMIN ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_phpmyadmin\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Os mesmos do seu MySQL\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Os mesmos do seu MySQL\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗   ██╗██████╗  █████╗ ██████╗  █████╗ ███████╗███████╗
## ██╔════╝██║   ██║██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝
## ███████╗██║   ██║██████╔╝███████║██████╔╝███████║███████╗█████╗  
## ╚════██║██║   ██║██╔═══╝ ██╔══██║██╔══██╗██╔══██║╚════██║██╔══╝  
## ███████║╚██████╔╝██║     ██║  ██║██████╔╝██║  ██║███████║███████╗
## ╚══════╝ ╚═════╝ ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝
                                                                 
ferramenta_supabase() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_supabase

## Mostra mensagem para preencher informações
preencha_as_info

generate_jwt_tokens() {
    # Verificar a disponibilidade dos comandos necessários e instalá-los se necessário
    if ! command -v openssl &> /dev/null; then
        echo "O comando 'openssl' não está disponível. Tentando instalar..."
        if [[ "$(uname)" == "Darwin" ]]; then
            # macOS
            brew install openssl
        elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]]; then
            # Linux
            if [[ -f /etc/redhat-release ]]; then
                # Red Hat, CentOS, Fedora
                sudo yum install -y openssl
            elif [[ -f /etc/debian_version ]]; then
                # Debian, Ubuntu
                sudo apt-get install -y openssl
            else
                echo "Não foi possível identificar a distribuição Linux. Por favor, instale o OpenSSL manualmente."
                return 1
            fi
        else
            echo "Sistema operacional não suportado. Por favor, instale o OpenSSL manualmente."
            return 1
        fi
    fi

    if ! command -v jq &> /dev/null; then
        echo "O comando 'jq' não está disponível. Tentando instalar..."
        if [[ "$(uname)" == "Darwin" ]]; then
            # macOS
            brew install jq
        elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]]; then
            # Linux
            if [[ -f /etc/redhat-release ]]; then
                # Red Hat, CentOS, Fedora
                sudo yum install -y jq
            elif [[ -f /etc/debian_version ]]; then
                # Debian, Ubuntu
                sudo apt-get install -y jq
            else
                echo "Não foi possível identificar a distribuição Linux. Por favor, instale o jq manualmente."
                return 1
            fi
        else
            echo "Sistema operacional não suportado. Por favor, instale o jq manualmente."
            return 1
        fi
    fi

# Definir os payloads dos JWTs
    payload_service_key=$(echo '{
      "role": "service_role",
      "iss": "supabase",
      "iat": 1715050800,
      "exp": 1872817200
    }' | jq .)

    
    payload_anon_key=$(echo '{
      "role": "anon",
      "iss": "supabase",
      "iat": 1715050800,
      "exp": 1872817200
    }' | jq .)

    # Gerar uma chave secreta aleatória e segura
    secret=$(openssl rand -hex 20)

    # Codificar o header em base64url
    header=$(echo -n '{"alg":"HS256","typ":"JWT"}' | openssl base64 | tr -d '=' | tr '+/' '-_' | tr -d '\n')
    
    # Codificar os payloads em base64url
    payload_service_key_base64=$(echo -n "$payload_service_key" | openssl base64 | tr -d '=' | tr '+/' '-_' | tr -d '\n')
    payload_anon_key_base64=$(echo -n "$payload_anon_key" | openssl base64 | tr -d '=' | tr '+/' '-_' | tr -d '\n')

    # Criar as assinaturas dos tokens usando a mesma chave secreta
    signature_service_key=$(echo -n "$header.$payload_service_key_base64" | openssl dgst -sha256 -hmac "$secret" -binary | openssl base64 | tr -d '=' | tr '+/' '-_' | tr -d '\n')
    signature_anon_key=$(echo -n "$header.$payload_anon_key_base64" | openssl dgst -sha256 -hmac "$secret" -binary | openssl base64 | tr -d '=' | tr '+/' '-_' | tr -d '\n')

    # Combinar as partes dos tokens
    token_service_key="$header.$payload_service_key_base64.$signature_service_key"
    token_anon_key="$header.$payload_anon_key_base64.$signature_anon_key"

    # Retornar os valores gerados como uma string separada por espaços
    echo "$secret $token_service_key $token_anon_key"
}

# Chamar a função e armazenar o retorno em uma variável
result=$(generate_jwt_tokens)

# Verificar se o resultado está vazio
if [[ -z "$result" ]]; then
    echo "A função retornou um resultado vazio. Verifique a configuração do ambiente e as dependências."
    exit 1
fi

# Extrair os valores individuais usando o comando 'read'
read secret token_service_key token_anon_key <<< "$result"


## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do Builder
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o Supabase (ex: supabase.oriondesign.art.br): \e[0m" && read -r url_supabase
    echo ""

    ##Pergunta o Dominio do Viewer
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o Usuario para o Supabase (ex: OrionDesign): \e[0m" && read -r user_supabase
    echo ""

    ##Pergunta a versão da ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Sem NENHUM caracteres especiais, tais como: @\!#$ entre outros"
    echo -en "\e[33mDigite a Senha do usuario para o Supabase (ex: Senha123): \e[0m" && read -r pass_supabase
    echo ""

    ###Pergunta o Email SMTP
    #echo -e "\e[97mPasso$amarelo 4/10\e[0m"
    #echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_supabase
    #echo ""

    ##Pergunta o usuário do Email SMTP
    #echo -e "\e[97mPasso$amarelo 5/10\e[0m"
    #echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    #echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_email_supabase
    #echo ""
    
    ## Pergunta a senha do SMTP
    #echo -e "\e[97mPasso$amarelo 6/10\e[0m"
    #echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    #echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_supabase
    #echo ""

    ## Pergunta o Host SMTP do email
    #echo -e "\e[97mPasso$amarelo 7/10\e[0m"
    #echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_supabase
    #echo ""

    ## Pergunta a porta SMTP do email
    #echo -e "\e[97mPasso$amarelo 8/10\e[0m"
    #echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_supabase
    #echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    #if [ "$porta_smtp_supabase" -eq 465 ]; then
    #smtp_secure_supabase=true
    #else
    #smtp_secure_supabase=false
    #fi

    ## Gera a JWT_Key
    JWT_Key="$secret"

    ## Gera a ANON_KEY
    ANON_KEY="$token_anon_key"

    ## Gera o SERVICE_KEY
    SERVICE_KEY="$token_service_key"

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_supabase
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Builder
    echo -e "\e[33mDominio do Supabase:\e[97m $url_supabase\e[0m"
    echo ""

    ## Informação sobre URL do Viewer
    echo -e "\e[33mUsuario:\e[97m $user_supabase\e[0m"
    echo ""

    ## Informação sobre a versão da ferramenta
    echo -e "\e[33mSenha:\e[97m $pass_supabase\e[0m"
    echo ""    

    ## Informação sobre Email
    #echo -e "\e[33mEmail do SMTP:\e[97m $email_supabase\e[0m"
    #echo ""

    ## Informação sobre Email
    #echo -e "\e[33mUsuário do SMTP:\e[97m $usuario_email_supabase\e[0m"
    #echo ""

    ## Informação sobre Senha do Email
    #echo -e "\e[33mSenha do Email:\e[97m $senha_email_supabase\e[0m"
    #echo ""

    ## Informação sobre Host SMTP
    #echo -e "\e[33mHost SMTP do Email:\e[97m $smtp_email_supabase\e[0m"
    #echo ""

    ## Informação sobre Porta SMTP
    #echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_supabase\e[0m"
    #echo ""

    ## Informação sobre Secure SMTP
    #echo -e "\e[33mSecure SMTP do Email:\e[97m $smtp_secure_supabase\e[0m"
    #echo ""

    ## Informação sobre JWT_Key
    echo -e "\e[33mJWT_Key:\e[97m $JWT_Key\e[0m"
    echo ""

    ## Informação sobre ANON_KEY
    echo -e "\e[33mAnon Key:\e[97m $ANON_KEY\e[0m"
    echo ""

    ## Informação sobre SERVICE_KEY
    echo -e "\e[33mService Key:\e[97m $SERVICE_KEY\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_supabase

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO SUPABASE \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Supabase iniciado

cd
if [ -d "/root/supabase${1:+_$1}" ]; then
  sudo rm -r /root/supabase${1:+_$1}
fi
mkdir supabase${1:+_$1}

mkdir temp${1:+_$1}

cd temp${1:+_$1}

#git clone --depth 1 https://github.com/oriondesign2015/SetupOrion > /dev/null 2>&1
git clone --depth 1 https://github.com/supabase/supabase.git > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Baixando Repositório do Supabase"
else
    echo "1/3 - [ OFF ] - Baixando Repositório do Supabase"
    echo "Não foi possivel Baixar."
fi
cd supabase
git checkout 3f6f8aa906f67dbc7674759e6b2560703e8c5201 > /dev/null 2>&1

#mv SetupOrion/Extras/Supabase /root/supabase${1:+_$1}
cd docker

rm -r dev .env.example .gitignore README.md docker-compose.s3.yml docker-compose.yml reset.sh

cd ..

mv docker /root/supabase${1:+_$1}/docker

cd
cd

rm -r temp${1:+_$1}

sudo mkdir -p /root/supabase${1:+_$1}/docker/volumes/db/data
if [ $? -eq 0 ]; then
    echo "2/3 - [ OK ] - Criando diretório 1"
else
    echo "2/3 - [ OFF ] - Criando diretório 1"
    echo "Não foi criar o diretório"
fi

#sudo mkdir -p /var/lib/postgresql/data
#if [ $? -eq 0 ]; then
#    echo "1/4 - [ OK ] - Criando diretório 2"
#else
#    echo "1/4 - [ OFF ] - Criando diretório 2"
#    echo "Não foi criar o diretório"
#fi

sudo mkdir -p /root/supabase${1:+_$1}/docker/volumes/storage
if [ $? -eq 0 ]; then
    echo "3/3 - [ OK ] - Criando diretório 2"
else
    echo "3/3 - [ OFF ] - Criando diretório 2"
    echo "Não foi criar o diretório"
fi

HASH=$(openssl rand -hex 6 | cut -c1-10)

cat > kong.yml <<EOL
_format_version: '2.1'
_transform: true

###
### Consumers / Users
###
consumers:
  - username: DASHBOARD
  - username: anon
    keyauth_credentials:
      - key: \$SUPABASE_ANON_KEY
  - username: service_role
    keyauth_credentials:
      - key: \$SUPABASE_SERVICE_KEY

###
### Access Control List
###
acls:
  - consumer: anon
    group: anon
  - consumer: service_role
    group: admin

###
### Dashboard credentials
###
basicauth_credentials:
  - consumer: DASHBOARD
    username: '\$DASHBOARD_USERNAME'
    password: '\$DASHBOARD_PASSWORD'

###
### API Routes
###
services:
  ## Open Auth routes
  - name: auth-v1-open
    url: http://supabase${1:+_$1}_auth:9999/verify
    routes:
      - name: auth-v1-open
        strip_path: true
        paths:
          - /auth/v1/verify
    plugins:
      - name: cors
  - name: auth-v1-open-callback
    url: http://supabase${1:+_$1}_auth:9999/callback
    routes:
      - name: auth-v1-open-callback
        strip_path: true
        paths:
          - /auth/v1/callback
    plugins:
      - name: cors
  - name: auth-v1-open-authorize
    url: http://supabase${1:+_$1}_auth:9999/authorize
    routes:
      - name: auth-v1-open-authorize
        strip_path: true
        paths:
          - /auth/v1/authorize
    plugins:
      - name: cors

  ## Secure Auth routes
  - name: auth-v1
    _comment: 'GoTrue: /auth/v1/* -> http://supabase${1:+_$1}_auth:9999/*'
    url: http://supabase${1:+_$1}_auth:9999/
    routes:
      - name: auth-v1-all
        strip_path: true
        paths:
          - /auth/v1/
    plugins:
      - name: cors
      - name: key-auth
        config:
          hide_credentials: false
      - name: acl
        config:
          hide_groups_header: true
          allow:
            - admin
            - anon

  ## Secure REST routes
  - name: rest-v1
    _comment: 'PostgREST: /rest/v1/* -> http://supabase${1:+_$1}_rest:3000/*'
    url: http://supabase${1:+_$1}_rest:3000/
    routes:
      - name: rest-v1-all
        strip_path: true
        paths:
          - /rest/v1/
    plugins:
      - name: cors
      - name: key-auth
        config:
          hide_credentials: true
      - name: acl
        config:
          hide_groups_header: true
          allow:
            - admin
            - anon

  ## Secure GraphQL routes
  - name: graphql-v1
    _comment: 'PostgREST: /graphql/v1/* -> http://supabase${1:+_$1}_rest:3000/rpc/graphql'
    url: http://supabase${1:+_$1}_rest:3000/rpc/graphql
    routes:
      - name: graphql-v1-all
        strip_path: true
        paths:
          - /graphql/v1
    plugins:
      - name: cors
      - name: key-auth
        config:
          hide_credentials: true
      - name: request-transformer
        config:
          add:
            headers:
              - Content-Profile:graphql_public
      - name: acl
        config:
          hide_groups_header: true
          allow:
            - admin
            - anon

  ## Secure Realtime routes
  - name: realtime-v1-ws
    _comment: 'Realtime: /realtime/v1/* -> ws://supabase${1:+_$1}_realtime:4000/socket/*'
    url: http://supabase${1:+_$1}_realtime:4000/socket
    protocol: ws
    routes:
      - name: realtime-v1-ws
        strip_path: true
        paths:
          - /realtime/v1/
    plugins:
      - name: cors
      - name: key-auth
        config:
          hide_credentials: false
      - name: acl
        config:
          hide_groups_header: true
          allow:
            - admin
            - anon
  - name: realtime-v1-rest
    _comment: 'Realtime: /realtime/v1/* -> ws://supabase${1:+_$1}_realtime:4000/socket/*'
    url: http://supabase${1:+_$1}_realtime:4000/api
    protocol: http
    routes:
      - name: realtime-v1-rest
        strip_path: true
        paths:
          - /realtime/v1/api
    plugins:
      - name: cors
      - name: key-auth
        config:
          hide_credentials: false
      - name: acl
        config:
          hide_groups_header: true
          allow:
            - admin
            - anon
  ## Storage routes: the storage server manages its own auth
  - name: storage-v1
    _comment: 'Storage: /storage/v1/* -> http://supabase${1:+_$1}_storage:5000/*'
    url: http://supabase${1:+_$1}_storage:5000/
    routes:
      - name: storage-v1-all
        strip_path: true
        paths:
          - /storage/v1/
    plugins:
      - name: cors

  ## Edge Functions routes
  - name: functions-v1
    _comment: 'Edge Functions: /functions/v1/* -> http://supabase${1:+_$1}_functions:9000/*'
    url: http://supabase${1:+_$1}_functions:9000/
    routes:
      - name: functions-v1-all
        strip_path: true
        paths:
          - /functions/v1/
    plugins:
      - name: cors

  ## Analytics routes
  - name: analytics-v1
    _comment: 'Analytics: /analytics/v1/* -> http://supabase${1:+_$1}_analytics:4000/*'
    url: http://supabase${1:+_$1}_analytics:4000/
    routes:
      - name: analytics-v1-all
        strip_path: true
        paths:
          - /analytics/v1/

  ## Secure Database routes
  - name: meta
    _comment: 'pg-meta: /pg/* -> http://supabase${1:+_$1}_meta:8080/*'
    url: http://supabase${1:+_$1}_meta:8080/
    routes:
      - name: meta-all
        strip_path: true
        paths:
          - /pg/
    plugins:
      - name: key-auth
        config:
          hide_credentials: false
      - name: acl
        config:
          hide_groups_header: true
          allow:
            - admin

  ## Block access to /api/mcp
  - name: mcp-blocker
    _comment: 'Block direct access to /api/mcp'
    url: http://supabase${1:+_$1}_studio:3000/api/mcp
    routes:
      - name: mcp-blocker-route
        strip_path: true
        paths:
          - /api/mcp
    plugins:
      - name: request-termination
        config:
          status_code: 403
          message: "Access is forbidden."

  - name: mcp
    _comment: 'MCP: /mcp/setuporion/$HASH -> http://supabase${1:+_$1}_studio:3000/api/mcp (public access)'
    url: http://supabase${1:+_$1}_studio:3000/api/mcp
    routes:
      - name: mcp
        strip_path: true
        paths:
          - /mcp/setuporion/$HASH
    plugins:
      - name: cors

  ## Protected Dashboard - catch all remaining routes
  - name: dashboard
    _comment: 'Studio: /* -> http://supabase${1:+_$1}_studio:3000/*'
    url: http://supabase${1:+_$1}_studio:3000/
    routes:
      - name: dashboard-all
        strip_path: true
        paths:
          - /
    plugins:
      - name: cors
      - name: basic-auth
        config:
          hide_credentials: true
EOL

rm /root/supabase${1:+_$1}/docker/volumes/api/kong.yml

mv kong.yml /root/supabase${1:+_$1}/docker/volumes/api/kong.yml

echo ""

## Mensagem de Passo
#echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[2/4]\e[0m"
#echo ""
#sleep 1
#
#pegar_senha_minio
#minio.bucket supabase${1:+-$1} > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
#else
#    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
#    echo ""
#fi
#
#echo ""
### Mensagem de Passo
echo -e "\e[97m• INSTALANDO SUPABASE \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando key Aleatórias
Senha_Postgres=$(openssl rand -hex 16)

Logflare_key=$(openssl rand -hex 16)

Logflare_key_public=$(openssl rand -hex 16)

SECRET_KEY_BASE=$(openssl rand -hex 32)

VAULT_ENC_KEY=$(openssl rand -base64 32 | tr -d '\n' | cut -c1-32)

MCP_API_KEY=$(openssl rand -hex 16)

PG_META_CRYPTO_KEY=$(openssl rand -hex 32)

## Criando a stack supabase.yaml
cat > supabase${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_studio:
    image: supabase/studio:2025.11.10-sha-5291fe3

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:     
    ## 🔗 Configuração do Supabase
      - HOSTNAME=0.0.0.0
      - SUPABASE_URL=http://supabase${1:+_$1}_kong:8000
      - SUPABASE_PUBLIC_URL=https://$url_supabase
      - SUPABASE_ANON_KEY=$ANON_KEY
      - SUPABASE_SERVICE_KEY=$SERVICE_KEY
      - AUTH_JWT_SECRET=$JWT_Key

    ## 🎨 Configuração de Branding
      - DEFAULT_ORGANIZATION_NAME=OrionAcademy
      - DEFAULT_PROJECT_NAME=SetupOrion

    ## 🐘 Configuração do Postgres (interno)
      - POSTGRES_DB=postgres
      - POSTGRES_HOST=supabase${1:+_$1}_db
      - POSTGRES_PORT=5432
      - POSTGRES_PASSWORD=$Senha_Postgres
      - PG_META_CRYPTO_KEY=$PG_META_CRYPTO_KEY

    ## 📊 Integração com Logflare
      - LOGFLARE_URL=http://supabase${1:+_$1}_analytics:4000
      - LOGFLARE_API_KEY=$Logflare_key
      - LOGFLARE_PUBLIC_ACCESS_TOKEN=$Logflare_key_public
      - LOGFLARE_PRIVATE_ACCESS_TOKEN=$Logflare_key
      - NEXT_PUBLIC_ENABLE_LOGS=true
      - NEXT_ANALYTICS_BACKEND_PROVIDER=postgres
      - DEBUG=next:*

    ## 🔍 Configuração do Meta
      - STUDIO_PG_META_URL=http://supabase${1:+_$1}_meta:8080

    ## 🤖 Configuração do OpenAI (opcional)
      # - OPENAI_API_KEY=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_kong:
    image: kong:2.8.1
    entrypoint: bash -c 'eval "echo \"\$\$(cat ~/temp.yml)\"" > ~/kong.yml && /docker-entrypoint.sh kong docker-start'

    volumes:
      - /root/supabase${1:+_$1}/docker/volumes/api/kong.yml:/home/kong/temp.yml:ro,z

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🧑‍💻 Configuração de usuário e senha do Dashboard
      - DASHBOARD_USERNAME=$user_supabase
      - DASHBOARD_PASSWORD=$pass_supabase

    ## 🔐 Configurações de Autenticação
      - JWT_SECRET=$JWT_Key
      - SUPABASE_ANON_KEY=$ANON_KEY
      - SUPABASE_SERVICE_KEY=$SERVICE_KEY

    ## 🗄️ Configuração do Banco de Dados
      - KONG_DATABASE=off
      - KONG_DECLARATIVE_CONFIG=/home/kong/kong.yml

    ## 🌐 Configuração de DNS
      - KONG_DNS_ORDER=LAST,A,CNAME

    ## 🧩 Configuração de Plugins
      - KONG_PLUGINS=request-transformer,cors,key-auth,acl,basic-auth,request-termination,ip-restriction

    ## 📦 Configurações de Buffers do NGINX
      - KONG_NGINX_PROXY_PROXY_BUFFER_SIZE=160k
      - KONG_NGINX_PROXY_PROXY_BUFFERS=64 160k

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager  
      labels:
        - traefik.enable=true
        - traefik.http.routers.supabase${1:+_$1}_kong.rule=Host(\`$url_supabase\`) && PathPrefix(\`/\`) ## Url do Supabase
        - traefik.http.services.supabase${1:+_$1}_kong.loadbalancer.server.port=8000
        - traefik.http.routers.supabase${1:+_$1}_kong.service=supabase${1:+_$1}_kong
        - traefik.http.routers.supabase${1:+_$1}_kong.entrypoints=websecure
        - traefik.http.routers.supabase${1:+_$1}_kong.tls.certresolver=letsencryptresolver
        - traefik.http.routers.supabase${1:+_$1}_kong.tls=true

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_auth:
    image: supabase/gotrue:v2.182.1

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configuração Geral da API Auth
      - GOTRUE_API_HOST=0.0.0.0
      - GOTRUE_API_PORT=9999
      - API_EXTERNAL_URL=https://$url_supabase

    ## 🗄️ Configuração do Banco de Dados
      - GOTRUE_DB_DRIVER=postgres
      - GOTRUE_DB_DATABASE_URL=postgres://supabase_auth_admin:$Senha_Postgres@supabase${1:+_$1}_db:5432/postgres ## Troque a senha do postgres

    ## 🔗 Configurações de URL e Permissões
      - GOTRUE_SITE_URL=https://$url_supabase
      - GOTRUE_URI_ALLOW_LIST=
      - GOTRUE_DISABLE_SIGNUP=false

    ## 🔐 Configurações de JWT
      - GOTRUE_JWT_ADMIN_ROLES=service_role
      - GOTRUE_JWT_AUD=authenticated
      - GOTRUE_JWT_DEFAULT_GROUP_NAME=authenticated
      - GOTRUE_JWT_EXP=31536000
      - GOTRUE_JWT_SECRET=$JWT_Key

    ## 📧 Configuração de email
      - GOTRUE_EXTERNAL_EMAIL_ENABLED=false
      - GOTRUE_EXTERNAL_ANONYMOUS_USERS_ENABLED=false
      - GOTRUE_MAILER_AUTOCONFIRM=true
      - GOTRUE_EXTERNAL_SKIP_NONCE_CHECK=true
      - GOTRUE_MAILER_SECURE_EMAIL_CHANGE_ENABLED=true
      - GOTRUE_SMTP_MAX_FREQUENCY=1s

    ## ✉️ Dados de SMTP (descomente para usar)
      #- GOTRUE_SMTP_SENDER_NAME=email@dominio.com # Nome do remetente SMTP
      #- GOTRUE_SMTP_ADMIN_EMAIL=email@dominio.com # Email administrador SMTP
      #- GOTRUE_SMTP_USER=email@dominio.com # Usuário SMTP
      #- GOTRUE_SMTP_PASS=senha # Senha SMTP
      #- GOTRUE_SMTP_HOST=smtp.dominio.com # Host SMTP
      #- GOTRUE_SMTP_PORT=587 # Porta SMTP

    ## 📱 Configurações de URL para Emails
      - GOTRUE_MAILER_URLPATHS_INVITE=/auth/v1/verify
      - GOTRUE_MAILER_URLPATHS_CONFIRMATION=/auth/v1/verify
      - GOTRUE_MAILER_URLPATHS_RECOVERY=/auth/v1/verify
      - GOTRUE_MAILER_URLPATHS_EMAIL_CHANGE=/auth/v1/verify

    ## Configurações de Hooks (descomente para usar)
      #- GOTRUE_HOOK_SEND_EMAIL_ENABLED=false
      #- GOTRUE_HOOK_SEND_EMAIL_URI=http://host.docker.internal:54321/functions/v1/email_sender
      #- GOTRUE_HOOK_SEND_EMAIL_SECRETS=v1,whsec_VGhpcyBpcyBhbiBleGFtcGxlIG9mIGEgc2hvcnRlciBCYXNlNjQgc3RyaW5n
    
    ## Configurações de SMS
      - GOTRUE_EXTERNAL_PHONE_ENABLED=false
      - GOTRUE_SMS_AUTOCONFIRM=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_rest:
    image: postgrest/postgrest:v13.0.7
    command:
      [
        "postgrest"
      ]
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do Banco de Dados
      - PGRST_DB_URI=postgres://authenticator:$Senha_Postgres@supabase${1:+_$1}_db:5432/postgres
      - PGRST_DB_SCHEMAS=public,storage,graphql_public
      - PGRST_DB_ANON_ROLE=anon

    ## 🔑 Configurações de JWT (JSON Web Tokens)
      - PGRST_JWT_SECRET=$JWT_Key
      - PGRST_APP_SETTINGS_JWT_SECRET=$JWT_Key
      - PGRST_APP_SETTINGS_JWT_EXP=31536000
    
    ## ⚙️ Outras Configurações
      - PGRST_DB_USE_LEGACY_GUCS=false
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_realtime:
    image: supabase/realtime:v2.63.0

    networks:
      - $nome_rede_interna ## Nome da rede interna
    dns:
      - 127.0.0.11

    environment:
    ## 🔔 Configuração da API Realtime
      - PORT=4000
      - API_JWT_SECRET=$JWT_Key
      - SECRET_KEY_BASE=$SECRET_KEY_BASE
      - APP_NAME=realtime

      - DB_HOST=supabase${1:+_$1}_db
      - DB_PORT=5432
      - DB_USER=supabase_admin
      - DB_PASSWORD=$Senha_Postgres
      - DB_NAME=postgres
      - DB_AFTER_CONNECT_QUERY=SET search_path TO _realtime
      - DB_ENC_KEY=supabaserealtime

    ## 🌐 Configuração de Conexão e Rede
      - ERL_AFLAGS=-proto_dist inet_tcp
      - DNS_NODES="''"
      - RLIMIT_NOFILE=10000

    ## 🌱 Configuração do Ambiente
      - SEED_SELF_HOST=true
      - RUN_JANITOR=true
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_storage:
    image: supabase/storage-api:v1.29.0

    volumes:
      #- /root/supabase${1:+_$1}/docker/volumes/storage:/var/lib/storage:z
      - supabase${1:+_$1}_storage:/var/lib/storage:z
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔑 Configuração do PostgREST e JWT
      - ANON_KEY=$ANON_KEY
      - SERVICE_KEY=$SERVICE_KEY
      - POSTGREST_URL=http://supabase${1:+_$1}_rest:3000
      - PGRST_JWT_SECRET=$JWT_Key
      - DATABASE_URL=postgres://supabase_storage_admin:$Senha_Postgres@supabase${1:+_$1}_db:5432/postgres

    ## 🗂️ Configuração de Armazenamento de Arquivos MinIO
      - REQUEST_ALLOW_X_FORWARDED_PATH=true
      - FILE_SIZE_LIMIT=52428800
      - STORAGE_BACKEND=file ## file ou s3
      - GLOBAL_S3_BUCKET=supabase${1:+-$1} ## Nome da bucket
      #- GLOBAL_S3_ENDPOINT=https://s3.dominio.com ## URL S3 do MinIO
      #- GLOBAL_S3_PROTOCOL=https
      #- GLOBAL_S3_FORCE_PATH_STYLE=true
      #- AWS_ACCESS_KEY_ID=ACCESS_KEY ## Access Key
      #- AWS_SECRET_ACCESS_KEY=SECRET_KEY ## Secret Key
      #- AWS_DEFAULT_REGION=eu-south ## Região MinIO
      - FILE_STORAGE_BACKEND_PATH=/var/lib/storage

    ## 🌍 Configuração de Região e Identificação
      - REGION=eu-south
      - TENANT_ID=stub

    ## 🖼️ Configuração de Imagens
      - ENABLE_IMAGE_TRANSFORMATION=true
      - IMGPROXY_URL=http://supabase${1:+_$1}_imgproxy:5001

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_imgproxy:
    image: darthsim/imgproxy:v3.8.0

    volumes:
      - /root/supabase${1:+_$1}/docker/volumes/storage:/var/lib/storage:z

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 📷 Configuração do IMGPROXY
      - IMGPROXY_BIND=:5001
      - IMGPROXY_LOCAL_FILESYSTEM_ROOT=/
      - IMGPROXY_USE_ETAG=true
      - IMGPROXY_ENABLE_WEBP_DETECTION=true
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_meta:
    image: supabase/postgres-meta:v0.93.1

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do PG_META
      - PG_META_PORT=8080
      - PG_META_DB_HOST=supabase${1:+_$1}_db
      - PG_META_DB_PORT=5432
      - PG_META_DB_NAME=postgres
      - PG_META_DB_USER=supabase_admin
      - PG_META_DB_PASSWORD=$Senha_Postgres
      - CRYPTO_KEY=$PG_META_CRYPTO_KEY
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_functions:
    image: supabase/edge-runtime:v1.69.23
    command:
      [
        "start",
        "--main-service",
        "/home/deno/functions/main"
      ]

    volumes:
      - /root/supabase${1:+_$1}/docker/volumes/functions:/home/deno/functions:Z
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔑 Configuração de JWT e Supabase
      - VERIFY_JWT=false
      - JWT_SECRET=$JWT_Key
    
    ## 🔗 Configuração de Supabase
      - SUPABASE_URL=http://supabase${1:+_$1}_kong:8000
      - SUPABASE_ANON_KEY=$ANON_KEY
      - SUPABASE_SERVICE_ROLE_KEY=$SERVICE_KEY
    
    ## 🗄️ Configuração de Banco de Dados
      - SUPABASE_DB_URL=postgresql://postgres:$Senha_Postgres@supabase${1:+_$1}_db:5432/postgres

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_analytics:
    image: supabase/logflare:1.22.6

    networks:
      - $nome_rede_interna ## Nome da rede interna
    #ports:
    #  - 4000:4000

    environment:
    ## 🗄️ Configuração de Banco de Dados
      - DB_USERNAME=supabase_admin
      - DB_DATABASE=_supabase
      - DB_HOSTNAME=supabase${1:+_$1}_db
      - DB_PORT=5432
      - DB_PASSWORD=$Senha_Postgres
      - DB_SCHEMA=_analytics
      - POSTGRES_BACKEND_URL=postgresql://supabase_admin:$Senha_Postgres@supabase${1:+_$1}_db:5432/_supabase
      - POSTGRES_BACKEND_SCHEMA=_analytics
      - LOGFLARE_FEATURE_FLAG_OVERRIDE=multibackend=true

    ## 📊 Configuração do Logflare
      - LOGFLARE_NODE_HOST=127.0.0.1
      - LOGFLARE_PUBLIC_ACCESS_TOKEN=$Logflare_key_public
      - LOGFLARE_PRIVATE_ACCESS_TOKEN=$Logflare_key
      - LOGFLARE_SINGLE_TENANT=true
      - LOGFLARE_SUPABASE_MODE=true
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_db:
    image: supabase/postgres:15.8.1.085
    command:
      [
        "postgres",
        "-c",
        "config_file=/etc/postgresql/postgresql.conf",
        "-c",
        "log_min_messages=fatal"
      ]

    volumes:
      - /root/supabase${1:+_$1}/docker/volumes/db/realtime.sql:/docker-entrypoint-initdb.d/migrations/99-realtime.sql:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/webhooks.sql:/docker-entrypoint-initdb.d/init-scripts/98-webhooks.sql:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/roles.sql:/docker-entrypoint-initdb.d/init-scripts/99-roles.sql:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/jwt.sql:/docker-entrypoint-initdb.d/init-scripts/99-jwt.sql:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/data:/var/lib/postgresql/data:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/_supabase.sql:/docker-entrypoint-initdb.d/migrations/97-_supabase.sql:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/logs.sql:/docker-entrypoint-initdb.d/migrations/99-logs.sql:Z
      - /root/supabase${1:+_$1}/docker/volumes/db/pooler.sql:/docker-entrypoint-initdb.d/migrations/99-pooler.sql:Z
      - supabase${1:+_$1}_db_config:/etc/postgresql-custom

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do PostgreSQL
      - POSTGRES_HOST=/var/run/postgresql
      - PGPORT=5432
      - POSTGRES_PORT=5432
      - PGPASSWORD=$Senha_Postgres
      - POSTGRES_PASSWORD=$Senha_Postgres
      - POSTGRES_DB=postgres
      - PGDATABASE=postgres

    ## 🔑 Configuração de JWT
      - JWT_SECRET=$JWT_Key
      - JWT_EXP=31536000

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_vector:
    image: timberio/vector:0.28.1-alpine
    command:
      [
        "--config",
        "/etc/vector/vector.yml"
      ]

    volumes:
    - /root/supabase${1:+_$1}/docker/volumes/logs/vector.yml:/etc/vector/vector.yml:ro,z
    - /var/run/docker.sock:/var/run/docker.sock:ro,z
    security_opt:
      - "label=disable"
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 📊 Configuração do Logflare
      - LOGFLARE_PUBLIC_ACCESS_TOKEN=$Logflare_key_public

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  supabase${1:+_$1}_supavisor:
    image: supabase/supavisor:2.7.4
    command:
      [
        "/bin/sh",
        "-c",
        "/app/bin/migrate && /app/bin/supavisor eval \"\$\$(cat /etc/pooler/pooler.exs)\" && /app/bin/server"
      ]

    volumes:
      - /root/supabase${1:+_$1}/docker/volumes/pooler/pooler.exs:/etc/pooler/pooler.exs:ro,z

    networks:
      - $nome_rede_interna ## Nome da rede interna
    #ports:
    #  - 5432:5432
    #  - 6543:6543

    environment:
    ## 🗄️ Configuração do Banco de Dados
      - POSTGRES_PORT=5432
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=$Senha_Postgres
      - DATABASE_URL=ecto://supabase_admin:$Senha_Postgres@supabase${1:+_$1}_db:5432/_supabase
      - CLUSTER_POSTGRES=true

    ## 🔐 Configuração de Segurança
      - SECRET_KEY_BASE=$SECRET_KEY_BASE
      - VAULT_ENC_KEY=$VAULT_ENC_KEY

    ## 🔑 Configuração de JWT
      - API_JWT_SECRET=$JWT_Key
      - METRICS_JWT_SECRET=$JWT_Key

    ## 🌍 Configuração de Regionalização
      - REGION=local

    ## 🧠 Configuração de Erlang
      - ERL_AFLAGS=-proto_dist inet_tcp

    ## ⚡ Configuração do Pooler
      - POOLER_TENANT_ID=1
      - POOLER_DEFAULT_POOL_SIZE=20
      - POOLER_MAX_CLIENT_CONN=100
      - POOLER_POOL_MODE=transaction
      - DB_POOL_SIZE=5

    ## 🚪 Configuração de Porta
      - PORT=4000

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

volumes:
  supabase${1:+_$1}_db_config:
    external: true
    name: supabase${1:+_$1}_db_config
  supabase${1:+_$1}_storage:
    external: true
    name: supabase${1:+_$1}_storage

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do supabase"
fi
STACK_NAME="supabase${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c supabase.yaml supabase > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do supabase"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull supabase/studio:2025.11.10-sha-5291fe3 kong:2.8.1 supabase/gotrue:v2.182.1 postgrest/postgrest:v13.0.7 supabase/realtime:v2.63.0 supabase/storage-api:v1.29.0 darthsim/imgproxy:v3.8.0 supabase/postgres-meta:v0.93.1 supabase/edge-runtime:v1.69.23 supabase/logflare:1.22.6 supabase/postgres:15.8.1.085 timberio/vector:0.28.1-alpine supabase/supavisor:2.7.4 

## Usa o serviço wait_stack "supabase" para verificar se o serviço esta online
wait_stack supabase${1:+_$1}_supabase${1:+_$1}_db supabase${1:+_$1}_supabase${1:+_$1}_vector supabase${1:+_$1}_supabase${1:+_$1}_analytics supabase${1:+_$1}_supabase${1:+_$1}_meta supabase${1:+_$1}_supabase${1:+_$1}_rest supabase${1:+_$1}_supabase${1:+_$1}_auth supabase${1:+_$1}_supabase${1:+_$1}_realtime supabase${1:+_$1}_supabase${1:+_$1}_storage supabase${1:+_$1}_supabase${1:+_$1}_imgproxy supabase${1:+_$1}_supabase${1:+_$1}_kong supabase${1:+_$1}_supabase${1:+_$1}_functions supabase${1:+_$1}_supabase${1:+_$1}_supavisor supabase${1:+_$1}_supabase${1:+_$1}_studio 
telemetria Supabase finalizado

cd dados_vps

cat > dados_supabase${1:+_$1} <<EOL
[ SUPABASE ]

Dominio do Supabase: https://$url_supabase

Usuario: $user_supabase

Senha: $pass_supabase

JWT Key: $JWT_Key

Anon Key: $ANON_KEY

Service Key: $SERVICE_KEY

MCP URL: https://$url_supabase/mcp/setuporion/$HASH

Host do Postgres: supabase${1:+_$1}_db

Port: 5432

User: postgres

Pass: $Senha_Postgres
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ SUPABASE ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_supabase\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_supabase\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_supabase\e[0m"
echo ""

echo -e "\e[33mAnon key:\e[97m $ANON_KEY\e[0m"
echo ""

echo -e "\e[33mService key:\e[97m $SERVICE_KEY\e[0m"
echo ""

echo -e "\e[33mMCP URL:\e[97m https://$url_supabase/mcp/setuporion/$HASH\e[0m"
echo ""

echo -e "\e[33mHost do Postgres:\e[97m supabase${1:+_$1}_db\e[0m"
echo ""

echo -e "\e[33mPort:\e[97m 5432\e[0m"
echo ""

echo -e "\e[33mUser:\e[97m postgres\e[0m"
echo ""

echo -e "\e[33mPass:\e[97m $Senha_Postgres\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗████████╗███████╗██╗   ██╗
## ████╗  ██║╚══██╔══╝██╔════╝╚██╗ ██╔╝
## ██╔██╗ ██║   ██║   █████╗   ╚████╔╝ 
## ██║╚██╗██║   ██║   ██╔══╝    ╚██╔╝  
## ██║ ╚████║   ██║   ██║        ██║   
## ╚═╝  ╚═══╝   ╚═╝   ╚═╝        ╚═╝   
                                    
ferramenta_ntfy() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_ntfy

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o Ntfy (ex: ntfy.oriondesign.art.br): \e[0m" && read -r url_ntfy
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o Usuario (ex: oriondesign): \e[0m" && read -r user_ntfy
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite a Senha (ex: @Senha123_): \e[0m" && read -r pass_ntfy
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_ntfy
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio da Ntfy:\e[97m $url_ntfy\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUsuario do Ntfy:\e[97m $user_ntfy\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do Ntfy:\e[97m $pass_ntfy\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_ntfy

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO NTFY \e[33m[1/3]\e[0m"
echo ""
sleep 1

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO O NTFY \e[33m[2/3]\e[0m"
echo ""
sleep 1

telemetria Ntfy iniciado

## Gerando Hash
hashed_senha=$(htpasswd -nb $user_ntfy $pass_ntfy | sed -e s/\\$/\\$\\$/g)

## Gerando Base64
authentication=$(echo -n "$user_ntfy:$pass_ntfy" | base64)

## Criando a stack ntfy.yaml
cat > ntfy${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  ntfy${1:+_$1}:
    image: binwiederhier/ntfy:latest
    command:
      - serve

    volumes:
      - ntfy${1:+_$1}_cache:/var/cache/ntfy
      - ntfy${1:+_$1}_etc:/etc/ntfy

    networks:
      - $nome_rede_interna

    environment:
    ## 🕒 TimeZone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.ntfy${1:+_$1}.rule=Host(\`$url_ntfy\`)
        - traefik.http.services.ntfy${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.ntfy${1:+_$1}.service=ntfy${1:+_$1}
        - traefik.http.routers.ntfy${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.ntfy${1:+_$1}.entrypoints=websecure
        - traefik.http.middlewares.ntfy${1:+_$1}-auth.basicauth.users=$hashed_senha
        - traefik.http.routers.ntfy${1:+_$1}.middlewares=ntfy${1:+_$1}-auth
        - traefik.http.routers.ntfy${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  ntfy${1:+_$1}_cache:
    external: true
    name: ntfy${1:+_$1}_cache
  ntfy${1:+_$1}_etc:
    external: true
    name: ntfy${1:+_$1}_etc

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Ntfy"
fi
STACK_NAME="ntfy${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c ntfy.yaml ntfy > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Ntfy"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull binwiederhier/ntfy:latest

## Usa o serviço wait_ntfy para verificar se o serviço esta online
wait_stack ntfy${1:+_$1}_ntfy${1:+_$1}

telemetria Ntfy finalizado

cd dados_vps

cat > dados_ntfy${1:+_$1} <<EOL
[ NTFY ]

Link do Ntfy: https://$url_ntfy

Usuario: $user_ntfy

Senha: $pass_ntfy

Authorization: Basic $authentication
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ NTFY ]\e[0m"
echo ""

echo -e "\e[97mLink do Ntfy:\e[33m https://$url_ntfy\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m $user_ntfy\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m $pass_ntfy\e[0m"
echo ""

echo -e "\e[97mAuthorization:\e[33m Basic $authentication\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗      ██████╗ ██╗    ██╗ ██████╗ ██████╗ ██████╗ ███████╗██████╗ 
## ██║     ██╔═══██╗██║    ██║██╔════╝██╔═══██╗██╔══██╗██╔════╝██╔══██╗
## ██║     ██║   ██║██║ █╗ ██║██║     ██║   ██║██║  ██║█████╗  ██████╔╝
## ██║     ██║   ██║██║███╗██║██║     ██║   ██║██║  ██║██╔══╝  ██╔══██╗
## ███████╗╚██████╔╝╚███╔███╔╝╚██████╗╚██████╔╝██████╔╝███████╗██║  ██║
## ╚══════╝ ╚═════╝  ╚══╝╚══╝  ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝

ferramenta_lowcoder() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_lowcoder

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Lowcoder (ex: lowcoder.oriondesign.art.br): \e[0m" && read -r url_lowcoder
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 2/8\e[0m"
    echo -en "\e[33mDigite um email para o Super Admin (ex: contato@oriondesign.art.br): \e[0m" && read -r email_super_admin_lowcoder
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 3/8\e[0m"
    echo -en "\e[33mDigite a senha do Super Admin (ex: @Senha123_): \e[0m" && read -r pass_super_admin_lowcoder
    echo ""

    ## Pergunta o email SMTP
    echo -e "\e[97mPasso$amarelo 4/8\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_lowcoder
    echo ""

    ## Pergunta o Ususario SMTP
    echo -e "\e[97mPasso$amarelo 5/8\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuario para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_lowcoder
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 6/8\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_smtp_lowcoder
    echo ""
    
    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 7/8\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_lowcoder
    echo ""
    
    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 8/8\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_lowcoder
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_lowcoder
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    pegar_senha_mongodb

    ## Informação sobre URL
    echo -e "\e[33mDominio da lowcoder:\e[97m $url_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mEmail do Super Admin:\e[97m $email_super_admin_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do Super Admin:\e[97m $pass_super_admin_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUser SMTP:\e[97m $user_smtp_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha SMTP:\e[97m $senha_smtp_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mHost SMTP:\e[97m $host_smtp_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_lowcoder\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUsuario do MongoDB:\e[97m $user_mongo\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do MongoDB:\e[97m $pass_mongo\e[0m"
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_lowcoder" -eq 465 ]; then
    smtp_secure_lowcoder_ssl=true
    smtp_secure_lowcoder_startls=false
    else
    smtp_secure_lowcoder_ssl=false
    smtp_secure_lowcoder_startls=true
    fi

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_lowcoder

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO LOWCODER \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria LowCoder iniciado

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO O LOWCODER \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Gerando Encryption
encryption_key_lowcoder1=$(openssl rand -hex 16)
encryption_key_lowcoder2=$(openssl rand -hex 16)
encryption_key_lowcoder3=$(openssl rand -hex 32)
encryption_key_lowcoder4=$(openssl rand -hex 32)

## Pegando ip da vps
read -r ip _ <<<$(hostname -I)

## Criando a stack lowcoder.yaml
cat > lowcoder${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  lowcoder${1:+_$1}_api:
    image: lowcoderorg/lowcoder-ce-api-service:latest

    networks:
      - $nome_rede_interna

    environment:
    ## 👤 Dados do Super Admin
      - LOWCODER_SUPERUSER_USERNAME=$email_super_admin_lowcoder
      - LOWCODER_SUPERUSER_PASSWORD=$pass_super_admin_lowcoder
      - LOWCODER_EMAIL_SIGNUP_ENABLED=false ## true = permitir criar novas contas

    ## 🌐 Dominio
      - LOWCODER_PUBLIC_URL=https://$url_lowcoder/
      - LOWCODER_NODE_SERVICE_URL=http://lowcoder${1:+_$1}_node:6060

    ## 🍃 Dados MongoDB
      - LOWCODER_MONGODB_URL=mongodb://$user_mongo:$pass_mongo@mongodb:27017/lowcoder${1:+_$1}?authSource=admin&readPreference=primary&ssl=false&directConnection=true

    ## 🚀 Dados Redis
      - LOWCODER_REDIS_URL=redis://lowcoder${1:+-$1}-redis:6379

    ## ✉️ Dados SMTP
      - LOWCODER_ADMIN_SMTP_HOST=$host_smtp_lowcoder
      - LOWCODER_ADMIN_SMTP_PORT=$porta_smtp_lowcoder
      - LOWCODER_ADMIN_SMTP_USERNAME=$user_smtp_lowcoder
      - LOWCODER_ADMIN_SMTP_PASSWORD=$senha_smtp_lowcoder
      - LOWCODER_ADMIN_SMTP_AUTH=true
      - LOWCODER_ADMIN_SMTP_SSL_ENABLED=$smtp_secure_lowcoder_ssl
      - LOWCODER_ADMIN_SMTP_STARTTLS_ENABLED=$smtp_secure_lowcoder_startls
      - LOWCODER_ADMIN_SMTP_STARTTLS_REQUIRED=$smtp_secure_lowcoder_startls
      - LOWCODER_EMAIL_NOTIFICATIONS_SENDER=$email_smtp_lowcoder

    ## ⚙️ Configurações
      - LOWCODER_MAX_QUERY_TIMEOUT=120
      - LOWCODER_EMAIL_AUTH_ENABLED=true
      - LOWCODER_CREATE_WORKSPACE_ON_SIGNUP=true ## true = permitir criar novos workspaces
      - LOWCODER_WORKSPACE_MODE=SAAS

    ## 🔒 Encryption
      - LOWCODER_DB_ENCRYPTION_PASSWORD=$encryption_key_lowcoder1 ## hash Encryption
      - LOWCODER_DB_ENCRYPTION_SALT=$encryption_key_lowcoder2 ## hash Encryption
      - LOWCODER_API_KEY_SECRET=$encryption_key_lowcoder3 # hash Encryption
      - LOWCODER_NODE_SERVICE_SECRET=$encryption_key_lowcoder4
      - LOWCODER_NODE_SERVICE_SECRET_SALT=lowcoder.org

    ## 🧩 Outras configurações
      - LOWCODER_CORS_DOMAINS=*
      - LOWCODER_MAX_ORGS_PER_USER=100
      - LOWCODER_MAX_MEMBERS_PER_ORG=1000
      - LOWCODER_MAX_GROUPS_PER_ORG=100
      - LOWCODER_MAX_APPS_PER_ORG=1000
      - LOWCODER_MAX_DEVELOPERS=50
    
    ## 🔐 User ID e Group ID
      - LOWCODER_PUID=9001
      - LOWCODER_PGID=9001

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.lowcoder${1:+_$1}_api.rule=Host(\`$url_lowcoder\`) && PathPrefix(\`/api\`)
        - traefik.http.services.lowcoder${1:+_$1}_api.loadbalancer.server.port=8080
        - traefik.http.routers.lowcoder${1:+_$1}_api.service=lowcoder${1:+_$1}_api
        - traefik.http.routers.lowcoder${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.lowcoder${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.routers.lowcoder${1:+_$1}_api.tls=true

## --------------------------- ORION --------------------------- ##

  lowcoder${1:+_$1}_node:
    image: lowcoderorg/lowcoder-ce-node-service:latest

    networks:
      - $nome_rede_interna

    environment:
    ## 🔐 User ID e Group ID
      - LOWCODER_PUID=9001
      - LOWCODER_PGID=9001
    
    ## 🔗 API Service URL
      - LOWCODER_API_SERVICE_URL=http://lowcoder${1:+_$1}_api:8080

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.5"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  lowcoder${1:+_$1}_frontend:
    image: lowcoderorg/lowcoder-ce-frontend:latest

    volumes:
     - lowcoder${1:+_$1}_assets:/lowcoder/assets

    networks:
      - $nome_rede_interna

    environment:
    ## 🔗 URLs de Serviços Internos
      - LOWCODER_API_SERVICE_URL=http://lowcoder${1:+_$1}_api:8080
      - LOWCODER_NODE_SERVICE_URL=http://lowcoder${1:+_$1}_node:6060
    
    ## ⚙️ Configurações Gerais
      - LOWCODER_MAX_REQUEST_SIZE=20m
      - LOWCODER_MAX_QUERY_TIMEOUT=120
    
    ## 🔒 Segurança & Chaves
      - LOWCODER_NODE_SERVICE_SECRET=$encryption_key_lowcoder4
      - LOWCODER_NODE_SERVICE_SECRET_SALT=lowcoder.org

    ## 🔐 User ID e Group ID
      - LOWCODER_PUID=9001
      - LOWCODER_PGID=9001

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager  
      labels:
        - traefik.enable=true
        - traefik.http.routers.lowcoder${1:+_$1}_frontend.rule=Host(\`$url_lowcoder\`) && PathPrefix(\`/\`)
        - traefik.http.services.lowcoder${1:+_$1}_frontend.loadbalancer.server.port=3000
        - traefik.http.routers.lowcoder${1:+_$1}_frontend.service=lowcoder${1:+_$1}_frontend
        - traefik.http.routers.lowcoder${1:+_$1}_frontend.entrypoints=websecure
        - traefik.http.routers.lowcoder${1:+_$1}_frontend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.lowcoder${1:+_$1}_frontend.tls=true

## --------------------------- ORION --------------------------- ##

  lowcoder${1:+-$1}-redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - lowcoder${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  lowcoder${1:+_$1}_assets:
    external: true
    name: lowcoder${1:+_$1}_assets
  lowcoder${1:+_$1}_redis:
    external: true
    name: lowcoder${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Lowcoder"
fi
STACK_NAME="lowcoder${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c lowcoder.yaml lowcoder > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da lowcoder"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest lowcoderorg/lowcoder-ce-api-service:latest lowcoderorg/lowcoder-ce-node-service:latest lowcoderorg/lowcoder-ce-frontend:latest

## Usa o serviço wait_stack "lowcoder" para verificar se o serviço esta online
wait_stack lowcoder${1:+_$1}_lowcoder${1:+-$1}-redis lowcoder${1:+_$1}_lowcoder${1:+_$1}_api lowcoder${1:+_$1}_lowcoder${1:+_$1}_node lowcoder${1:+_$1}_lowcoder${1:+_$1}_frontend

telemetria LowCoder finalizado

cd dados_vps

cat > dados_lowcoder${1:+_$1} <<EOL
[ LOWCODER ]

Link do Lowcoder: https://$url_lowcoder

Usuario: $email_super_admin_lowcoder

Senha: $pass_super_admin_lowcoder

API_KEY: $encryption_key_lowcoder3
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ LOWCODER ]\e[0m"
echo ""

echo -e "\e[97mLink do Lowcoder:\e[33m https://$url_lowcoder\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m $email_super_admin_lowcoder\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m $pass_super_admin_lowcoder\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗      █████╗ ███╗   ██╗ ██████╗ ███████╗██╗      ██████╗ ██╗    ██╗
## ██║     ██╔══██╗████╗  ██║██╔════╝ ██╔════╝██║     ██╔═══██╗██║    ██║
## ██║     ███████║██╔██╗ ██║██║  ███╗█████╗  ██║     ██║   ██║██║ █╗ ██║
## ██║     ██╔══██║██║╚██╗██║██║   ██║██╔══╝  ██║     ██║   ██║██║███╗██║
## ███████╗██║  ██║██║ ╚████║╚██████╔╝██║     ███████╗╚██████╔╝╚███╔███╔╝
## ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝  ╚══╝╚══╝ 

ferramenta_langflow() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_langflow

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do Builder
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para LangFlow (ex: langflow.oriondesign.art.br): \e[0m" && read -r url_langflow
    echo ""

    ##Pergunta o Usuario para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -e "$amarelo--> Minimo 5 caracteres. Evite os caracteres especiais: \!#$ e/ou espaço"
    echo -en "\e[33mDigite um usuario para o LangFlow (ex: admin): \e[0m" && read -r user_langflow
    echo ""
    
    ##Pergunta a Senha para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma senha para o usuario do LangFlow (ex: @Senha123_): \e[0m" && read -r pass_langflow
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_langflow
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Builder
    echo -e "\e[33mDominio do Langflow:\e[97m $url_langflow\e[0m"
    echo ""

    ## Informação sobre URL do Builder
    echo -e "\e[33mUsuario:\e[97m $user_langflow\e[0m"
    echo ""

    ## Informação sobre URL do Builder
    echo -e "\e[33mSenha:\e[97m $pass_langflow\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_langflow

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO LANGFLOW \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Langflow iniciado

## Nada nada nada.. só para aparecer a mensagem de passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "langflow${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "langflow${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO LANGFLOW \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
key_langflow=$(python3 -c 'from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())')

## Criando a stack langflow.yaml
cat > langflow${1:+_$1}.yaml <<EOL
version: "3.8"
services:

## --------------------------- ORION --------------------------- ##

  langflow${1:+_$1}_app:
    image: langflowai/langflow:latest

    volumes:
      - langflow${1:+_$1}_data:/app/langflow

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de acesso
      - LANGFLOW_SUPERUSER=$user_langflow
      - LANGFLOW_SUPERUSER_PASSWORD=$pass_langflow
      - LANGFLOW_AUTO_LOGIN=false
      - BACKEND_URL=https://$url_langflow
      - LANGFLOW_HOST=0.0.0.0
      - LANGFLOW_PORT=7860

    ## 📁 Configuração do diretório de dados
      - LANGFLOW_CONFIG_DIR=/app/langflow

    ## 🔑 Secret Key
    ## Gere em: https://www.uuidgenerator.net/api/version1
      - LANGFLOW_SECRET_KEY=$key_langflow

    ## 🧑‍💻 Permitir novas incrições
      - LANGFLOW_NEW_USER_IS_ACTIVE=false ## false = Precisa autorizar novas inscrições

    ## 📊 Logging
      - LANGFLOW_LOG_LEVEL=INFO

    ## 🗄️ Dados do Postgres
      - LANGFLOW_DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/langflow${1:+_$1}
    
    ## 🚀 Dados do Redis
      - LANGFLOW_CACHE_TYPE=redis
      - LANGFLOW_REDIS_HOST=langflow${1:+_$1}_redis
      - LANGFLOW_REDIS_PORT=6379
      - LANGFLOW_REDIS_DB=0
      - LANGFLOW_REDIS_CACHE_EXPIRE=3600

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 2048M
      labels:
        - traefik.enable=true
        - traefik.http.routers.langflow${1:+_$1}_app.rule=Host(\`$url_langflow\`) ## Url da aplicação
        - traefik.http.services.langflow${1:+_$1}_app.loadBalancer.server.port=7860
        - traefik.http.routers.langflow${1:+_$1}_app.service=langflow${1:+_$1}_app
        - traefik.http.routers.langflow${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.langflow${1:+_$1}_app.tls.certresolver=letsencryptresolver

## --------------------------- ORION --------------------------- ##

  langflow${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - langflow${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  langflow${1:+_$1}_data:
    external: true
    name: langflow${1:+_$1}_data
  langflow${1:+_$1}_redis:
    external: true
    name: langflow${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do langflow"
fi
STACK_NAME="langflow${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c langflow.yaml langflow > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do langflow"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest langflowai/langflow:latest

sleep 5

## Ajustar o "DONO" do diretório
chown -R 1000:0 /var/lib/docker/volumes/langflow${1:+_$1}_data/_data

## Ajustar as "PERMISSÕES" do diretório
chmod -R 755 /var/lib/docker/volumes/langflow${1:+_$1}_data/_data

## Usa o serviço wait_stack "langflow" para verificar se o serviço esta online
wait_stack langflow${1:+_$1}_langflow${1:+_$1}_redis langflow${1:+_$1}_langflow${1:+_$1}

telemetria Langflow finalizado

cd dados_vps

cat > dados_langflow${1:+_$1} <<EOL
[ LANGFLOW ]

Dominio do langflow: https://$url_langflow

Usuario: $user_langflow

Senha: $pass_langflow
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ LANGFLOW ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_langflow\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_langflow\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_langflow\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗ ███████╗███╗   ██╗    ██████╗ ██████╗  ██████╗      ██╗███████╗ ██████╗████████╗
## ██╔═══██╗██╔══██╗██╔════╝████╗  ██║    ██╔══██╗██╔══██╗██╔═══██╗     ██║██╔════╝██╔════╝╚══██╔══╝
## ██║   ██║██████╔╝█████╗  ██╔██╗ ██║    ██████╔╝██████╔╝██║   ██║     ██║█████╗  ██║        ██║   
## ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║    ██╔═══╝ ██╔══██╗██║   ██║██   ██║██╔══╝  ██║        ██║   
## ╚██████╔╝██║     ███████╗██║ ╚████║    ██║     ██║  ██║╚██████╔╝╚█████╔╝███████╗╚██████╗   ██║   
##  ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝   

ferramenta_openproject() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_openproject

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o OpenProject (ex: openproject.oriondesign.art.br): \e[0m" && read -r url_openproject
    echo ""

    ## Limpa o terminal
    clear

    ## Mostra o nome da aplicação
    nome_openproject

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL do openproject
    echo -e "\e[33mDominio do OpenProject:\e[97m $url_openproject\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_minio

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO OPENPROJECT \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria OpenProject iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO OPENPROJECT \e[33m[2/3]\e[0m"
echo ""
sleep 1

key_openproject=$(openssl rand -hex 16)
senha_postgres_openproject=$(openssl rand -hex 16)

## Criando a stack
cat > openproject${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  openproject${1:+_$1}_app:
    image: openproject/openproject:16

    volumes:
      - openproject${1:+_$1}_pgdata:/var/openproject/pgdata
      - openproject${1:+_$1}_assets:/var/openproject/assets

    networks:
      - $nome_rede_interna

    environment:
    ## 🔑 Secret Key
      - OPENPROJECT_SECRET_KEY_BASE=$key_openproject

    ## 🌐 Dominio:
      - OPENPROJECT_HOST__NAME=$url_openproject
      - OPENPROJECT_HTTPS=true

    ## 🧱 Dados do Redis
      - OPENPROJECT_RAILS__CACHE__STORE=redis
      - OPENPROJECT_CACHE_REDIS_URL=redis://openproject${1:+_$1}_redis:6379

    ## 🐘 Dados do Postgres
      - OPENPROJECT_DATABASE_HOST=openproject${1:+_$1}_db
      - OPENPROJECT_DATABASE_PORT=5432
      - OPENPROJECT_DATABASE_NAME=openproject${1:+_$1}
      - OPENPROJECT_DATABASE_USERNAME=postgres
      - OPENPROJECT_DATABASE_PASSWORD=$senha_postgres_openproject

    ## ⚙️ Configurações
      - OPENPROJECT_DEFAULT__LANGUAGE=pt-BR

    ## ✉️ Dados SMTP
    ## Deixei comentado pois a environment da senha não esta funcionando como o esperado
      #- OPENPROJECT_EMAIL__DELIVERY__METHOD=smtp
      #- OPENPROJECT_MAIL__FROM=email@dominio.com
      #- OPENPROJECT_SMTP__USER__NAME=Usuario_do_Email
      #- OPENPROJECT_SMTP__DOMAIN=dominio.com
      #- OPENPROJECT_SMTP__PASSWORD=Senha_do_Email
      #- OPENPROJECT_SMTP__ADDRESS=smtp.dominio.com
      #- OPENPROJECT_SMTP__PORT=587
      #- OPENPROJECT_SMTP__ENABLE__STARTTLS__AUTO=true
      #- OPENPROJECT_SMTP__AUTHENTICATION=plain
      #- OPENPROJECT_SMTP__OPENSSL__VERIFY__MODE=peer 
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.openproject${1:+_$1}_app.rule=Host(\`$url_openproject\`)
        - traefik.http.routers.openproject${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.openproject${1:+_$1}_app.priority=1
        - traefik.http.routers.openproject${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.openproject${1:+_$1}_app.service=openproject${1:+_$1}_app
        - traefik.http.services.openproject${1:+_$1}_app.loadbalancer.server.port=8080
        - traefik.http.services.openproject${1:+_$1}_app.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  openproject${1:+_$1}_db:
    image: postgres:17 ## Versão do postgres
    command: >
      postgres
      -c max_connections=500
      -c shared_buffers=512MB
      -c timezone=America/Sao_Paulo

    volumes:
      - openproject${1:+_$1}_db:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 5432:5432

    environment:
    ## 🗄️ Nome da Database
      - POSTGRES_DB=openproject${1:+_$1}

    ## 🔑 Senha do Postgres 
      - POSTGRES_PASSWORD=$senha_postgres_openproject

    ## 🌎 Timezone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  openproject${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - openproject${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  openproject${1:+_$1}_pgdata:
    external: true
    name: openproject${1:+_$1}_pgdata
  openproject${1:+_$1}_assets:
    external: true
    name: openproject${1:+_$1}_assets
  openproject${1:+_$1}_db:
    external: true
    name: openproject${1:+_$1}_db
  openproject${1:+_$1}_redis:
    external: true
    name: openproject${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do OpenProject"
fi
STACK_NAME="openproject${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c openproject.yaml openproject > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do openproject"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull postgres:17 redis:latest openproject/openproject:16

## Usa o serviço wait_stack "openproject" para verificar se o serviço esta online
wait_stack openproject${1:+_$1}_openproject${1:+_$1}_db openproject${1:+_$1}_openproject${1:+_$1}_redis openproject${1:+_$1}_openproject${1:+_$1}_app

wait_30_sec
wait_30_sec

telemetria OpenProject finalizado

cd dados_vps

cat > dados_openproject${1:+_$1} <<EOL
[ OPENPROJECT ]

Dominio do openproject: https://$url_openproject

Usuario: admin

Senha: admin
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ OPENPROJECT ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_openproject\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m admin\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m admin\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ███████╗███████╗██████╗ 
##  ╚══███╔╝██╔════╝██╔══██╗
##    ███╔╝ █████╗  ██████╔╝
##   ███╔╝  ██╔══╝  ██╔═══╝ 
##  ███████╗███████╗██║     
##  ╚══════╝╚══════╝╚═╝                         

ferramenta_zep() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_zep

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos    
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/4\e[0m"
    echo -en "\e[33mDigite o Dominio para o Zep (ex: zep.oriondesign.art.br): \e[0m" && read -r url_zep
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 2/4\e[0m"
    echo -en "\e[33mDigite um usuario (ex: oriondesign): \e[0m" && read -r user_zep
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 3/4\e[0m"
    echo -en "\e[33mDigite a senha para o usuario (ex: @Senha123_): \e[0m" && read -r pass_zep
    echo ""

    ## Pergunta o nome do Usuario do Motor
    echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    echo -en "\e[33mApiKey OpenAI: \e[0m" && read -r apikey_openai_zep
    echo ""

    ## Criando uma Encryption Key Aleatória
    encryption_key_zep=$(openssl rand -hex 16)
    apikey_zep=$(openssl rand -hex 16)
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_zep
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre o dominio
    echo -e "\e[33mDominio do Zep:\e[97m $url_zep\e[0m"
    echo ""

    ## Informação sobre o usuario
    echo -e "\e[33mUsuario do Zep:\e[97m $user_zep\e[0m"
    echo ""

    ## Informação sobre a senha
    echo -e "\e[33mSenha do Zep:\e[97m $pass_zep\e[0m"
    echo ""

    ## Informação sobre o usuario
    echo -e "\e[33mApiKey da OpenAI:\e[97m $apikey_openai_zep\e[0m"
    echo ""

    ## Informação sobre a senha
    echo -e "\e[33mApiKey do Zep:\e[97m $apikey_zep\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_zep

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO ZEP \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Zep iniciado

cd
mkdir temp
cd temp

git clone --depth 1 https://github.com/oriondesign2015/setuporion > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/1 - [ OK ] - Baixando Repositório do Zep"
else
    echo "1/1 - [ OFF ] - Baixando Repositório do Zep"
    echo "Não foi possivel Baixar."
fi

mv setuporion/Extras/Zep /root/zep${1:+_$1}

cd
cd
rm -r temp
cd
echo ""

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES VECTOR \e[33m[2/4]\e[0m"
echo ""
sleep 1

dados
verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - PgVector já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do PgVector"
    criar_banco_pgvector_da_stack "zep${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "zep${1:+_$1}"
fi

sleep 5

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO ZEP \e[33m[3/4]\e[0m"
echo ""
sleep 1

hashed_senha_zep=$(htpasswd -nb $user_zep $pass_zep | sed -e s/\\$/\\$\\$/g)

## Criando a stack zep.yaml
cat > zep${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  zep${1:+_$1}_nlp:
    image: ghcr.io/getzep/zep-nlp-server:latest

    networks:
      - $nome_rede_interna

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

  zep${1:+_$1}_app:
    image: ghcr.io/getzep/zep:latest

    volumes:
      - /root/zep${1:+_$1}/config.yaml:/app/config.yaml

    networks:
      - $nome_rede_interna

    environment:
    ## 🐘 Dados Postgres
      - ZEP_STORE_TYPE=postgres
      - ZEP_STORE_POSTGRES_DSN=postgres://postgres:$senha_pgvector@pgvector:5432/zep${1:+_$1}?sslmode=disable

    ## 🔐 Dados de acesso:
      - ZEP_AUTH_SECRET=$apikey_zep

    ## 🤖 Dados OpenAI
      - ZEP_OPENAI_API_KEY=$apikey_openai_zep

    ## 🧠 Dados NLP
      - ZEP_NLP_SERVER_URL=http://zep${1:+_$1}_nlp:5557

    ## 📄 Configurações de extração
      - ZEP_EXTRACTORS_DOCUMENTS_EMBEDDINGS_SERVICE=openai
      - ZEP_EXTRACTORS_DOCUMENTS_EMBEDDINGS_DIMENSIONS=1536
      - ZEP_EXTRACTORS_MESSAGES_EMBEDDINGS_SERVICE=openai
      - ZEP_EXTRACTORS_MESSAGES_EMBEDDINGS_DIMENSIONS=1536
      - ZEP_EXTRACTORS_MESSAGES_SUMMARIZER_EMBEDDINGS_SERVICE=openai
      - ZEP_EXTRACTORS_MESSAGES_SUMMARIZER_EMBEDDINGS_DIMENSIONS=1536

    ## 🕸️ Configuração Graphiti
      - ZEP_GRAPHITI_URL=http://zep${1:+_$1}_graphiti:8003

    ## 🐞 Degub:
      - ZEP_LOG_LEVEL=debug

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        ## 🌐 Dominio da API
        - traefik.http.routers.zep${1:+_$1}.rule=Host(\`$url_zep\`)
        - traefik.http.routers.zep${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.zep${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.zep${1:+_$1}.loadbalancer.server.port=8000
        - traefik.http.services.zep${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.routers.zep${1:+_$1}.service=zep${1:+_$1}

        ## 🔐 Autenticação do /admin
        - traefik.http.routers.zep${1:+_$1}_api.rule=Host(\`$url_zep\`) && PathPrefix(\`/admin\`)
        - traefik.http.routers.zep${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.zep${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.services.zep${1:+_$1}_api.loadbalancer.server.port=8000
        - traefik.http.services.zep${1:+_$1}_api.loadbalancer.passHostHeader=true
        - traefik.http.routers.zep${1:+_$1}_api.service=zep${1:+_$1}_api
        - traefik.http.routers.zep${1:+_$1}_api.middlewares=authzep${1:+_$1}_api
        - traefik.http.middlewares.authzep${1:+_$1}_api.basicauth.users=$hashed_senha_zep

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Zep"
fi
STACK_NAME="zep${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c zep.yaml zep #> /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do zep"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""

## Baixando imagens:
pull ghcr.io/getzep/zep-nlp-server:latest ghcr.io/getzep/zep:latest

## Usa o serviço wait_zep para verificar se o serviço esta online
wait_stack zep${1:+_$1}_zep${1:+_$1}_nlp zep${1:+_$1}_zep${1:+_$1}_app

telemetria Zep finalizado

wait_30_sec

cd dados_vps

cat > dados_zep${1:+_$1} <<EOL
[ ZEP ]

Dominio do Zep: https://$url_zep/admin

Usuario do Zep: $user_zep

Senha do Zep: $pass_zep

ApiKey do Zep: $apikey_zep
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ZEP ]\e[0m"
echo ""

echo -e "\e[97mDominio:\e[33m https://$url_zep/admin\e[0m"
echo ""

echo -e "\e[97mUsuario do Zep:\e[33m $user_zep\e[0m"
echo ""

echo -e "\e[97mSenha do Zep:\e[33m $pass_zep\e[0m"
echo ""

echo -e "\e[97mApiKey do Zep:\e[33m $apikey_zep\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗  ██╗██╗   ██╗███╗   ███╗██╗  ██╗██╗   ██╗██████╗ 
## ██║  ██║██║   ██║████╗ ████║██║  ██║██║   ██║██╔══██╗
## ███████║██║   ██║██╔████╔██║███████║██║   ██║██████╔╝
## ██╔══██║██║   ██║██║╚██╔╝██║██╔══██║██║   ██║██╔══██╗
## ██║  ██║╚██████╔╝██║ ╚═╝ ██║██║  ██║╚██████╔╝██████╔╝
## ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ 
                                                     
ferramenta_humhub() {

## Verifica os recursos
recursos 1 1 && continue || return

# Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_humhub

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ## Pergunta o Dominio da ferramenta
    echo -e "\e[97mPasso$amarelo 1/10\e[0m"
    echo -en "\e[33mDigite o Dominio para o HumHub (ex: humhub.oriondesign.art.br): \e[0m" && read -r url_humhub
    echo ""

    ## Pergunta o usuario da ferramenta
    echo -e "\e[97mPasso$amarelo 2/10\e[0m"
    echo -e "$amarelo--> AutoConfig é uma função que pula as etapas de configurações pós instalação"
    echo -en "\e[33mUsar o AutoConfig do HumHub (exemplo: 0 para não ou 1 para sim): \e[0m" && read -r autoconfig_humhub_valor
    echo ""

    if [ "$autoconfig_humhub_valor" -eq 1 ]; then
      autoconfig_humhub="- HUMHUB_AUTO_INSTALL=1"
    elif [ "$autoconfig_humhub_valor" -eq 0 ]; then
      autoconfig_humhub="#- HUMHUB_AUTO_INSTALL=0"
    else
      echo "Erro ao receber resposta do AutoConfig. Resposta precisa ser 0 ou 1"
      echo "Definindo para 0"
      autoconfig_humhub_valor="0"
      autoconfig_humhub="#- HUMHUB_AUTO_INSTALL=0"
    fi

    ## Pergunta o usuario da ferramenta
    echo -e "\e[97mPasso$amarelo 3/10\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ e/ou espaços"
    echo -en "\e[33mDigite um Usuario Admin (ex: OrionDesign): \e[0m" && read -r user_humhub
    echo ""

    ## Pergunta o email da ferramenta
    echo -e "\e[97mPasso$amarelo 4/10\e[0m"
    echo -en "\e[33mDigite o Email do Admin: (ex: contato@oriondesign.art.br): \e[0m" && read -r email_humhub
    echo ""
    
    ## Pergunta o senha da ferramenta
    echo -e "\e[97mPasso$amarelo 5/10\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma Senha para o Admin (ex: @Senha123_): \e[0m" && read -r pass_humhub
    echo ""

    ## Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 6/10\e[0m"
    echo -en "\e[33mDigite um Email para o SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_humhub
    echo ""

    ## Pergunta o User SMTP
    echo -e "\e[97mPasso$amarelo 7/10\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuario do SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_humhub
    echo ""
    
    ## Pergunta a Senha SMTP
    echo -e "\e[97mPasso$amarelo 8/10\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do email (ex: @Senha123_): \e[0m" && read -r senha_smtp_humhub
    echo ""
    
    ## Pergunta o Host SMTP
    echo -e "\e[97mPasso$amarelo 9/10\e[0m"
    echo -en "\e[33mDigite o Host SMTP do email (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_humhub
    echo ""
    
    ## Pergunta a Porta SMTP 
    echo -e "\e[97mPasso$amarelo 10/10\e[0m"
    echo -en "\e[33mDigite a Porta SMTP do email (ex: 465): \e[0m" && read -r porta_smtp_humhub
    echo ""

    if [ "$porta_smtp_humhub" -eq 465 ] || [ "$porta_smtp_humhub" -eq 25 ]; then
        porta_smtp_humhub_conv=1
    else
        porta_smtp_humhub_conv=0
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_humhub
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do HumHub:\e[97m $url_humhub\e[0m"
    echo ""

    echo -e "\e[33mUsar AutoConfig:\e[97m $autoconfig_humhub\e[0m"
    echo ""

    ## Informação sobre Usuario Admin
    echo -e "\e[33mUsuario Admin:\e[97m $user_humhub\e[0m"
    echo ""

    ## Informação sobre Email Admin
    echo -e "\e[33mEmail do Admin:\e[97m $email_humhub\e[0m"
    echo ""    

    ## Informação sobre Senha Admin
    echo -e "\e[33mSenha do Admin:\e[97m $pass_humhub\e[0m"
    echo ""

    ## Informação sobre Senha Admin
    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_humhub\e[0m"
    echo ""

    ## Informação sobre Senha Admin
    echo -e "\e[33mUsuario SMTP:\e[97m $user_smtp_humhub\e[0m"
    echo ""

    ## Informação sobre Senha Admin
    echo -e "\e[33mSenha SMTP:\e[97m $senha_smtp_humhub\e[0m"
    echo ""

    ## Informação sobre Senha Admin
    echo -e "\e[33mHost SMTP:\e[97m $host_smtp_humhub\e[0m"
    echo ""

    ## Informação sobre Senha Admin
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_humhub\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_humhub

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO HUMHUB \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria HumHub iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/4]\e[0m"
echo ""
sleep 1

dados

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "humhub${1:+_$1}"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "humhub${1:+_$1}"
    fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO HUMHUB \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack
cat > humhub${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  humhub${1:+_$1}_app:
    image: mriedmann/humhub:latest

    volumes:
      - humhub${1:+_$1}_data:/var/www/localhost/htdocs/protected/modules
      - humhub${1:+_$1}_uploads:/var/www/localhost/htdocs/uploads
      - humhub${1:+_$1}_assets:/var/www/localhost/htdocs/assets
      - humhub${1:+_$1}_themes:/var/www/localhost/htdocs/themes
      
    networks:
      - $nome_rede_interna
      
    environment:
    ## 🔐 Dados de acesso
      - HUMHUB_ADMIN_USERNAME=$user_humhub
      - HUMHUB_ADMIN_PASSWORD=$pass_humhub
      - HUMHUB_EMAIL=$email_humhub
      - HUMHUB_EMAIL_NAME=$user_humhub
      - HUMHUB_ADMIN_EMAIL=$email_humhub

    ## ✉️ Dados SMTP
      - HUMHUB_MAILER_TRANSPORT_TYPE=smtp
      - HUMHUB_MAILER_SYSTEM_EMAIL_ADDRESS=$email_smtp_humhub
      - HUMHUB_MAILER_USERNAME=$user_smtp_humhub
      - HUMHUB_MAILER_PASSWORD=$senha_smtp_humhub
      - HUMHUB_MAILER_SYSTEM_EMAIL_NAME=Suporte
      - HUMHUB_MAILER_HOSTNAME=$host_smtp_humhub
      - HUMHUB_MAILER_PORT=$porta_smtp_humhub
      - HUMHUB_MAILER_ALLOW_SELF_SIGNED_CERTS=$porta_smtp_humhub_conv ## 0 = TLS | 1 = SSL
      
    ## 🐬 Dados do MySQL
      - HUMHUB_DB_HOST=mysql
      - HUMHUB_DB_USER=root
      - HUMHUB_DB_PASSWORD=$senha_mysql
      - HUMHUB_DB_NAME=humhub${1:+_$1}
      $autoconfig_humhub

    ## 🔥 Dados Redis
      - HUMHUB_REDIS_HOSTNAME=redis
      - HUMHUB_REDIS_PORT=6379
      - HUMHUB_CACHE_EXPIRE_TIME=3600
      - HUMHUB_CACHE_CLASS=yii\redis\Cache
      - HUMHUB_QUEUE_CLASS=humhub\modules\queue\driver\Redis
  
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.humhub${1:+_$1}.rule=Host(\`$url_humhub\`)
        - traefik.http.routers.humhub${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.humhub${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.humhub${1:+_$1}.service=humhub${1:+_$1}
        - traefik.http.services.humhub${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.services.humhub${1:+_$1}.loadbalancer.passHostHeader=true


## --------------------------- ORION --------------------------- ##

  humhub${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - humhub${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  humhub${1:+_$1}_data:
    external: true
    name: humhub${1:+_$1}_data
  humhub${1:+_$1}_uploads:
    external: true
    name: humhub${1:+_$1}_uploads
  humhub${1:+_$1}_themes:
    external: true
    name: humhub${1:+_$1}_themes
  humhub${1:+_$1}_assets:
    external: true
    name: humhub${1:+_$1}_assets
  humhub${1:+_$1}_redis:
    external: true
    name: humhub${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do HumHub"
fi
STACK_NAME="humhub${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c humhub.yaml humhub > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do humhub"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest mriedmann/humhub:latest

## Usa o serviço wait_calcom para verificar se o serviço esta online
wait_stack humhub${1:+_$1}_humhub${1:+_$1}_redis humhub${1:+_$1}_humhub${1:+_$1}_app

telemetria HumHub finalizado

cd dados_vps

cat > dados_humhub${1:+_$1} <<EOL
[ HUMHUB ]

Dominio do humhub: $url_humhub

Usuario: $user_humhub

Email: $email_humhub

Senha: $pass_humhub

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ HUMHUB ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_humhub\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_humhub\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_humhub\e[0m"
echo ""

echo -e "\e[33mHost MySQL:\e[97m mysql\e[0m"
echo ""

echo -e "\e[33mUsuario MySQL:\e[97m root\e[0m"
echo ""

echo -e "\e[33mSenha MySQL:\e[97m $senha_mysql\e[0m"
echo ""

echo -e "\e[33mBase de dados MySQL:\e[97m humhub\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗   ██╗ ██████╗ ██╗   ██╗██████╗ ██╗     ███████╗
## ╚██╗ ██╔╝██╔═══██╗██║   ██║██╔══██╗██║     ██╔════╝
##  ╚████╔╝ ██║   ██║██║   ██║██████╔╝██║     ███████╗
##   ╚██╔╝  ██║   ██║██║   ██║██╔══██╗██║     ╚════██║
##    ██║   ╚██████╔╝╚██████╔╝██║  ██║███████╗███████║
##    ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝

ferramenta_yourls() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_yourls

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o Yourls (ex: yourls.oriondesign.art.br): \e[0m" && read -r url_yourls
    echo ""
    
    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o Usuario (ex: oriondesign): \e[0m" && read -r user_yourls
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite a Senha do usuario (ex: @Senha123_): \e[0m" && read -r pass_yourls
    echo ""
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_yourls
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do yourls
    echo -e "\e[33mDominio do Yourls:\e[97m $url_yourls\e[0m"
    echo ""

    ## Informação sobre URL do yourls
    echo -e "\e[33mUsuario:\e[97m $user_yourls\e[0m"
    echo ""

    ## Informação sobre URL do yourls
    echo -e "\e[33mSenha:\e[97m $pass_yourls\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_yourls

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO YOURLS \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Yourls iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "yourls${1:+_$1}"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "yourls${1:+_$1}"
    fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO YOURLS \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack yourls.yaml
cat > yourls${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  yourls${1:+_$1}:
    image: yourls:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de acesso
      - YOURLS_SITE=https://$url_yourls ## Url da Aplicação
      - YOURLS_USER=$user_yourls
      - YOURLS_PASS=$pass_yourls
      
    ## 🐬 Dados do Mysql
      - YOURLS_DB_HOST=mysql
      - YOURLS_DB_NAME=yourls${1:+_$1}
      - YOURLS_DB_USER=root
      - YOURLS_DB_PASS=$senha_mysql

    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.yourls${1:+_$1}.rule=Host(\`$url_yourls\`) ## Url da aplicação
        - traefik.http.routers.yourls${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.yourls${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.yourls${1:+_$1}.service=yourls${1:+_$1}
        - traefik.http.services.yourls${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.routers.yourls.tls=true

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Yourls"
fi
STACK_NAME="yourls${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c yourls.yaml yourls > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do yourls"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull yourls:latest

## Usa o serviço wait_stack "yourls" para verificar se o serviço esta online
wait_stack yourls${1:+_$1}_yourls${1:+_$1}

telemetria Yourls finalizado

cd dados_vps

cat > dados_yourls${1:+_$1} <<EOL
[ YOURLS ]

Dominio do Yourls: https://$url_yourls/admin

Usuario: $user_yourls

Senha: $pass_yourls

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ YOURLS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_yourls/admin\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_yourls\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_yourls\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ████████╗██╗    ██╗███████╗███╗   ██╗████████╗██╗   ██╗ ██████╗██████╗ ███╗   ███╗
## ╚══██╔══╝██║    ██║██╔════╝████╗  ██║╚══██╔══╝╚██╗ ██╔╝██╔════╝██╔══██╗████╗ ████║
##    ██║   ██║ █╗ ██║█████╗  ██╔██╗ ██║   ██║    ╚████╔╝ ██║     ██████╔╝██╔████╔██║
##    ██║   ██║███╗██║██╔══╝  ██║╚██╗██║   ██║     ╚██╔╝  ██║     ██╔══██╗██║╚██╔╝██║
##    ██║   ╚███╔███╔╝███████╗██║ ╚████║   ██║      ██║   ╚██████╗██║  ██║██║ ╚═╝ ██║
##    ╚═╝    ╚══╝╚══╝ ╚══════╝╚═╝  ╚═══╝   ╚═╝      ╚═╝    ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝
                                                                                  

ferramenta_twentycrm() {

## Verifica os recursos
recursos 1 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_twentycrm

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o dominio para o TwentyCRM (ex: twentycrm.oriondesign.art.br): \e[0m" && read -r url_twentycrm
    echo ""

    ## Pergunta o email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_twentycrm
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r user_smtp_twentycrm
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r pass_smtp_twentycrm
    echo ""
    
    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_twentycrm
    echo ""
    
    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_twentycrm
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_twentycrm
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do twentycrm
    echo -e "\e[33mDominio do TwentyCRM:\e[97m $url_twentycrm\e[0m"
    echo ""

    ## Informação sobre URL do twentycrm
    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_twentycrm\e[0m"
    echo ""
    
    ## Informação sobre URL do twentycrm
    echo -e "\e[33mUsuario do SMTP:\e[97m $user_smtp_twentycrm\e[0m"
    echo ""

    ## Informação sobre URL do twentycrm
    echo -e "\e[33mSenha do Email SMTP:\e[97m $pass_smtp_twentycrm\e[0m"
    echo ""

    ## Informação sobre URL do twentycrm
    echo -e "\e[33mHost SMTP:\e[97m $host_smtp_twentycrm\e[0m"
    echo ""

    ## Informação sobre URL do twentycrm
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_twentycrm\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_twentycrm

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO TWENTYCRM \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria TwentyCRM iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO TWENTYCRM \e[33m[2/3]\e[0m"
echo ""
sleep 1

senha_postgres_twentycrm=$(openssl rand -hex 16)
Key_aleatoria_twentycrm_1=$(openssl rand -hex 16)
Key_aleatoria_twentycrm_2=$(openssl rand -hex 16)
Key_aleatoria_twentycrm_3=$(openssl rand -hex 16)
Key_aleatoria_twentycrm_4=$(openssl rand -hex 16)

## Criando a stack
cat > twentycrm${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  twentycrm${1:+_$1}_server:
    image: twentycrm/twenty:latest

    volumes:
      - twentycrm${1:+_$1}_data:/app/packages/twenty-server/.local-storage
      - twentycrm${1:+_$1}_docker:/app/docker-data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de acesso
      - PORT=3000
      - SERVER_URL=https://$url_twentycrm

    ## 🔥 Dados do Redis
      - REDIS_URL=redis://twentycrm${1:+_$1}_redis:6379

    ## 🐘 Dados do Postgres
      - PG_DATABASE_URL=postgres://postgres:$senha_postgres_twentycrm@twentycrm${1:+_$1}_db:5432/twentycrm${1:+_$1}

    ## 🗂️ Dados da Storage/s3
      - STORAGE_TYPE=local

    ## 🔑 Secret Keys
      - APP_SECRET=$Key_aleatoria_twentycrm_1
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 4192M
      labels:
        - traefik.enable=true
        - traefik.http.routers.twentycrm${1:+_$1}.rule=Host(\`$url_twentycrm\`) ## Url da aplicação
        - traefik.http.services.twentycrm${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.twentycrm${1:+_$1}.service=twentycrm${1:+_$1}
        - traefik.http.routers.twentycrm${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.twentycrm${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.twentycrm${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  twentycrm${1:+_$1}_worker:
    image: twentycrm/twenty:latest
    command: ["yarn", "worker:prod"]

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de acesso
      - PORT=3000
      - SERVER_URL=https://$url_twentycrm

    ## 🔥 Dados do Redis
      - REDIS_URL=redis://twentycrm${1:+_$1}_redis:6379

    ## 🐘 Dados do Postgres
      - PG_DATABASE_URL=postgres://postgres:$senha_postgres_twentycrm@twentycrm${1:+_$1}_db:5432/twentycrm${1:+_$1}
      - DISABLE_DB_MIGRATIONS=true

    ## 🗂️ Dados da Storage/s3
      - STORAGE_TYPE=local

    ## 🔑 Secret Keys
      - APP_SECRET=$Key_aleatoria_twentycrm_1

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
 
## --------------------------- ORION --------------------------- ##

  twentycrm${1:+_$1}_db:
    image: twentycrm/twenty-postgres-spilo:latest

    volumes:
      - twentycrm${1:+_$1}_db:/home/postgres/pgdata

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      - PGUSER_SUPERUSER=postgres
      - POSTGRES_DB=twentycrm${1:+_$1}
      - POSTGRESQL_PASSWORD=$senha_postgres_twentycrm
      - PGPASSWORD_SUPERUSER=$senha_postgres_twentycrm
      - ALLOW_NOSSL=true
      - SPILO_PROVIDER=local
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  twentycrm${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - twentycrm${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  twentycrm${1:+_$1}_data:
    external: true
    name: twentycrm${1:+_$1}_data
  twentycrm${1:+_$1}_docker:
    external: true
    name: twentycrm${1:+_$1}_docker
  twentycrm${1:+_$1}_db:
    external: true
    name: twentycrm${1:+_$1}_db
  twentycrm${1:+_$1}_redis:
    external: true
    name: twentycrm${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da sua rede interna
    name: $nome_rede_interna ## Nome da sua rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do twentycrm"
fi
STACK_NAME="twentycrm${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c twentycrm.yaml twentycrm > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do twentycrm"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull twentycrm/twenty:latest twentycrm/twenty-postgres-spilo:latest

##sleep 5

##docker exec -t "$(docker ps -q --filter "name=twentycrm${1:+_$1}_twentycrm${1:+_$1}_db")" psql -U postgres -c "CREATE DATABASE twentycrm${1:+_$1};"

## Usa o serviço wait_stack "twentycrm" para verificar se o serviço esta online
wait_stack twentycrm${1:+_$1}_twentycrm${1:+_$1}_server twentycrm${1:+_$1}_twentycrm${1:+_$1}_worker twentycrm${1:+_$1}_twentycrm${1:+_$1}_db
wait_30_sec
sudo chmod -R 755 /var/lib/docker/volumes/twentycrm${1:+_$1}_docker
sudo chown -R 1000:1000 /var/lib/docker/volumes/twentycrm${1:+_$1}_docker

sudo chmod -R 755 /var/lib/docker/volumes/twentycrm${1:+_$1}_data
sudo chown -R 1000:1000 /var/lib/docker/volumes/twentycrm${1:+_$1}_data

wait_30_sec

telemetria TwentyCRM finalizado

cd dados_vps

cat > dados_twentycrm${1:+_$1} <<EOL
[ TWENTYCRM ]

Dominio do TwentyCRM: https://$url_twentycrm

Usuario: Precisa criar no primeiro acesso do TwentyCRM

Senha: Precisa criar no primeiro acesso do TwentyCRM
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ TWENTYCRM ]\e[0m"
echo ""

echo -e "\e[33mDominio do TwentyCRM:\e[97m https://$url_twentycrm\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do TwentyCRM\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do TwentyCRM\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ███╗ █████╗ ████████╗████████╗███████╗██████╗ ███╗   ███╗ ██████╗ ███████╗████████╗
## ████╗ ████║██╔══██╗╚══██╔══╝╚══██╔══╝██╔════╝██╔══██╗████╗ ████║██╔═══██╗██╔════╝╚══██╔══╝
## ██╔████╔██║███████║   ██║      ██║   █████╗  ██████╔╝██╔████╔██║██║   ██║███████╗   ██║   
## ██║╚██╔╝██║██╔══██║   ██║      ██║   ██╔══╝  ██╔══██╗██║╚██╔╝██║██║   ██║╚════██║   ██║   
## ██║ ╚═╝ ██║██║  ██║   ██║      ██║   ███████╗██║  ██║██║ ╚═╝ ██║╚██████╔╝███████║   ██║   
## ╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝ ╚══════╝   ╚═╝   
                                                                                          

ferramenta_mattermost() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_mattermost

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Mattermost (ex: mattermost.oriondesign.art.br): \e[0m" && read -r url_mattermost
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_mattermost
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do mattermost
    echo -e "\e[33mDominio do Mattermost:\e[97m $url_mattermost\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_mattermost

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MATTERMOST \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Mattermost iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "mattermost${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "mattermost${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO MATTERMOST \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack mattermost.yaml
cat > mattermost${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  mattermost${1:+_$1}:
    image: mattermost/mattermost-team-edition:latest

    volumes:
      - mattermost${1:+_$1}_data:/mattermost/data
      - mattermost${1:+_$1}_config:/mattermost/config
      - mattermost${1:+_$1}_logs:/mattermost/logs
      - mattermost${1:+_$1}_plugins:/mattermost/plugins
      - mattermost${1:+_$1}_client_plugins:/mattermost/client/plugins

    networks:
      - $nome_rede_interna

    environment:
    ## 🔐 Dados de acesso
      - MM_SERVICESETTINGS_SITEURL=https://$url_mattermost

    ## 🐘 Dados do Postgres
      - MM_SQLSETTINGS_DRIVERNAME=postgres
      - MM_SQLSETTINGS_DATASOURCE=postgres://postgres:$senha_postgres@postgres:5432/mattermost${1:+_$1}?sslmode=disable&connect_timeout=10

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.mattermost${1:+_$1}.rule=Host(\`$url_mattermost\`)
        - traefik.http.routers.mattermost${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.mattermost${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.mattermost${1:+_$1}.service=mattermost${1:+_$1}
        - traefik.http.services.mattermost${1:+_$1}.loadbalancer.server.port=8065
        - traefik.http.services.mattermost${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.routers.mattermost${1:+_$1}.middlewares=sslheader

## --------------------------- ORION --------------------------- ##

volumes:
  mattermost${1:+_$1}_data:
    external: true
    name: mattermost${1:+_$1}_data
  mattermost${1:+_$1}_config:
    external: true
    name: mattermost${1:+_$1}_config
  mattermost${1:+_$1}_logs:
    external: true
    name: mattermost${1:+_$1}_logs
  mattermost${1:+_$1}_plugins:
    external: true
    name: mattermost${1:+_$1}_plugins
  mattermost${1:+_$1}_client_plugins:
    external: true
    name: mattermost${1:+_$1}_client_plugins

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do mattermost"
fi
STACK_NAME="mattermost${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c mattermost.yaml mattermost > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do mattermost"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull mattermost/mattermost-team-edition:latest

## Usa o serviço wait_stack "mattermost" para verificar se o serviço esta online
wait_stack mattermost${1:+_$1}_mattermost${1:+_$1}

telemetria Mattermost finalizado

cd dados_vps

cat > dados_mattermost${1:+_$1} <<EOL
[ MATTERMOST ]

Dominio do Mattermost: https://$url_mattermost

Usuario: Precisa criar no primeiro acesso do Mattermost

Senha: Precisa criar no primeiro acesso do Mattermost
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ MATTERMOST ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_mattermost\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Mattermost\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Mattermost\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##   ██████╗ ██╗   ██╗████████╗██╗     ██╗███╗   ██╗███████╗
##  ██╔═══██╗██║   ██║╚══██╔══╝██║     ██║████╗  ██║██╔════╝
##  ██║   ██║██║   ██║   ██║   ██║     ██║██╔██╗ ██║█████╗  
##  ██║   ██║██║   ██║   ██║   ██║     ██║██║╚██╗██║██╔══╝  
##  ╚██████╔╝╚██████╔╝   ██║   ███████╗██║██║ ╚████║███████╗
##   ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝╚═╝  ╚═══╝╚══════╝                                                                              

ferramenta_outline() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_outline

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/8\e[0m"
    echo -en "\e[33mDigite o dominio para o Outline (ex: outline.oriondesign.art.br): \e[0m" && read -r url_outline
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/8\e[0m"
    echo -e "$amarelo--> Caso não tiver crie em: https://console.cloud.google.com/welcome"
    echo -en "\e[33mDigite o seu ID do Cliente Google (ex: XXXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.apps.googleusercontent.com): \e[0m" && read -r id_google_outline
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/8\e[0m"
    echo -e "$amarelo--> Caso não tiver crie em: https://console.cloud.google.com/apis/credentials"
    echo -en "\e[33mDigite a sua Chave Secreta do Cliente Google (ex: XXXXXX-XXXXXXXXXXXXXXXXXXXXXXXX-XXX): \e[0m" && read -r key_google_outline
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 4/8\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_outline
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 5/8\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_email_outline
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 6/8\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_outline
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 7/8\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_outline
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 8/8\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_outline
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_outline" -eq 465 ]; then
    smtp_secure_outline=true
    else
    smtp_secure_outline=false
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_outline
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do outline
    echo -e "\e[33mDominio do Outline:\e[97m $url_outline\e[0m"
    echo ""

    ## Informação sobre URL do outline
    echo -e "\e[33mID do Cliente Google:\e[97m $id_google_outline\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mEmail do SMTP:\e[97m $email_outline\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mUsuário do SMTP:\e[97m $usuario_email_outline\e[0m"
    echo ""

    ## Informação sobre Senha do Email
    echo -e "\e[33mSenha do Email:\e[97m $senha_email_outline\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP do Email:\e[97m $smtp_email_outline\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_outline\e[0m"
    echo ""

    ## Informação sobre Secure SMTP
    echo -e "\e[33mSecure SMTP do Email:\e[97m $smtp_secure_outline\e[0m"
    echo ""
    
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_outline

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO OUTLINE \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Outline iniciado
## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "outline${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "outline${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO OUTLINE \e[33m[3/4]\e[0m"
echo ""
sleep 1

Key_aleatoria_outline_1=$(openssl rand -hex 32)
Key_aleatoria_outline_2=$(openssl rand -hex 32)

## Criando a stack outline.yaml
cat > outline${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  outline${1:+_$1}_app:
    image: outlinewiki/outline:latest

    volumes:
      - outline${1:+_$1}_uploads:/var/lib/outline/uploads

    networks:
      - $nome_rede_interna

    environment:
    ## 🔐 Dados de acesso
      - URL=https://$url_outline
      - PORT=3000
      - ENABLE_EMAIL_SIGNIN=true
      - FORCE_HTTPS=true

    ## 🔑 Secret Keys
      - SECRET_KEY=$Key_aleatoria_outline_1
      - UTILS_SECRET=$Key_aleatoria_outline_2

    ## 🐘 Dados do Postgres
      - DATABASE_URL=postgres://postgres:$senha_postgres@postgres:5432/outline${1:+_$1}?sslmode=disable

    ## 🔥 Dados do Redis
      - REDIS_URL=redis://outline${1:+_$1}_redis:6379

    ## 🗂️ Dados de armazenamento
      - FILE_STORAGE_UPLOAD_LOCAL=true
      #- AWS_S3_UPLOAD_BUCKET_URL=https://
      #- AWS_S3_UPLOAD_BUCKET_NAME=outline
      #- AWS_ACCESS_KEY_ID=
      #- AWS_SECRET_ACCESS_KEY=
      #- AWS_REGION=eu-south

    ## ✉️ Dados SMTP
      - SMTP_FROM_EMAIL=Outline <$email_outline>
      - SMTP_USERNAME=$usuario_email_outline
      - SMTP_PASSWORD=$senha_email_outline
      - SMTP_HOST=$smtp_email_outline
      - SMTP_PORT=$porta_smtp_outline
      - MAIL_SSL_ENABLE=$smtp_secure_outline

    ## 🌐 Confoigurações Globais
      - DEFAULT_LANGUAGE=pt_BR
      - WEB_CONCURRENCY=2

    ## 🔵 Dados Google
      - OIDC_CLIENT_ID=$id_google_outline
      - OIDC_CLIENT_SECRET=$key_google_outline
      - OIDC_AUTH_URI=https://accounts.google.com/o/oauth2/auth
      - OIDC_TOKEN_URI=https://accounts.google.com/o/oauth2/token
      - OIDC_USERINFO_URI=https://www.googleapis.com/oauth2/v3/userinfo
      - OIDC_USERNAME_CLAIM=preferred_username
      - OIDC_DISPLAY_NAME=Google
      - OIDC_SCOPES=email profile openid
      - OIDC_LOGOUT_URI=https://$url_outline

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.outline${1:+_$1}_app.rule=Host(\`$url_outline\`)
        - traefik.http.routers.outline${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.outline${1:+_$1}_app.tls=true
        - traefik.http.routers.outline${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.outline${1:+_$1}_app.service=outline${1:+_$1}_app
        - traefik.http.services.outline${1:+_$1}_app.loadbalancer.server.port=3000

## --------------------------- ORION --------------------------- ##

  outline${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - outline${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  outline${1:+_$1}_uploads:
    external: true
    name: outline${1:+_$1}_uploads
  outline${1:+_$1}_redis:
    external: true
    name: outline${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Outline"
fi
STACK_NAME="outline${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c outline.yaml outline > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do outline"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest outlinewiki/outline:latest

## Usa o serviço wait_stack "outline" para verificar se o serviço esta online
wait_stack outline${1:+_$1}_outline${1:+_$1}_redis outline${1:+_$1}_outline${1:+_$1}_app

telemetria Outline finalizado

cd dados_vps

cat > dados_outline${1:+_$1} <<EOL
[ OUTLINE ]

Dominio do Outline: https://$url_outline

Usuario: Login é feito com o Google

Senha: Login é feito com o Google
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ OUTLINE ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_outline\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Login é feito com o Google\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Login é feito com o Google\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗ ██████╗  ██████╗ █████╗ ██╗     ██████╗  ██████╗  █████╗ ██████╗ ██████╗ 
## ██╔════╝██╔═══██╗██╔════╝██╔══██╗██║     ██╔══██╗██╔═══██╗██╔══██╗██╔══██╗██╔══██╗
## █████╗  ██║   ██║██║     ███████║██║     ██████╔╝██║   ██║███████║██████╔╝██║  ██║
## ██╔══╝  ██║   ██║██║     ██╔══██║██║     ██╔══██╗██║   ██║██╔══██║██╔══██╗██║  ██║
## ██║     ╚██████╔╝╚██████╗██║  ██║███████╗██████╔╝╚██████╔╝██║  ██║██║  ██║██████╔╝
## ╚═╝      ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ 

ferramenta_focalboard() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_focalboard

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o FocalBoard (ex: focalboard.oriondesign.art.br): \e[0m" && read -r url_focalboard
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_focalboard
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do focalboard
    echo -e "\e[33mDominio do FocalBoard:\e[97m $url_focalboard\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_focalboard

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO FOCALBOARD \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Focalboard iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO FOCALBOARD \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack focalboard.yaml
cat > focalboard${1:+_$1}.yaml <<EOL
version: "3.8"
services:

## --------------------------- ORION --------------------------- ##

  focalboard${1:+_$1}:
    image: mattermost/focalboard:latest

    volumes:
      - focalboard${1:+_$1}_data:/opt/focalboard/data
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🔐 Dados de acesso
      - VIRTUAL_HOST=$url_focalboard ## Url da Aplicação
      - VIRTUAL_PORT=8000
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.focalboard${1:+_$1}.rule=Host(\`$url_focalboard\`) ## Url da Aplicação
        - traefik.http.services.focalboard${1:+_$1}.loadBalancer.server.port=8000
        - traefik.http.routers.focalboard${1:+_$1}.service=focalboard${1:+_$1}
        - traefik.http.routers.focalboard${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.focalboard${1:+_$1}.tls.certresolver=letsencryptresolver

## --------------------------- ORION --------------------------- ##

volumes:
  focalboard${1:+_$1}_data:
    external: true
    name: focalboard${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do focalboard"
fi
STACK_NAME="focalboard${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c focalboard.yaml focalboard > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do focalboard"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull mattermost/focalboard:latest

## Usa o serviço wait_focalboard para verificar se o serviço esta online
wait_stack focalboard${1:+_$1}_focalboard${1:+_$1}

telemetria Focalboard finalizado

cd dados_vps

cat > dados_focalboard${1:+_$1} <<EOL
[ FOCALBOARD ]

Dominio do FocalBoard: https://$url_focalboard

Usuario: Precisa criar no primeiro acesso do FocalBoard

Senha: Precisa criar no primeiro acesso do FocalBoard
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ FOCALBOARD ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_focalboard\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do FocalBoard\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do FocalBoard\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██╗     ██████╗ ██╗
## ██╔════╝ ██║     ██╔══██╗██║
## ██║  ███╗██║     ██████╔╝██║
## ██║   ██║██║     ██╔═══╝ ██║
## ╚██████╔╝███████╗██║     ██║
##  ╚═════╝ ╚══════╝╚═╝     ╚═╝

ferramenta_glpi() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_glpi

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o GLPI (ex: glpi.oriondesign.art.br): \e[0m" && read -r url_glpi
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_glpi
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do glpi
    echo -e "\e[33mDominio do GLPI:\e[97m $url_glpi\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_glpi

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO GLPI \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria GLPI iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "glpi${1:+_$1}"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "glpi${1:+_$1}"
    fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO GLPI \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack glpi.yaml
cat > glpi${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  glpi${1:+_$1}:
    image: diouxx/glpi:latest

    volumes:
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
      - glpi${1:+_$1}_glpi:/var/www/html/glpi

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🕒 Timezone
      - TIMEZONE=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.glpi${1:+_$1}.rule=Host(\`$url_glpi\`)
        - traefik.http.services.glpi${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.glpi${1:+_$1}.service=glpi${1:+_$1}
        - traefik.http.routers.glpi${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.glpi${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.glpi${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  glpi${1:+_$1}_glpi:
    external: true
    name: glpi${1:+_$1}_glpi

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do GLPI"
fi
STACK_NAME="glpi${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c glpi.yaml glpi > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do glpi"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull diouxx/glpi:latest

## Usa o serviço wait_stack "glpi" para verificar se o serviço esta online
wait_stack glpi${1:+_$1}_glpi${1:+_$1}

telemetria GLPI finalizado

cd dados_vps

cat > dados_glpi${1:+_$1} <<EOL
[ GLPI ]

Dominio do GLPI: https://$url_glpi

Usuario: glpi

Senha: glpi
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ GLPI ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_glpi\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m glpi\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m glpi\e[0m"
echo ""

echo -e "\e[33mEndereço do servidor SQL:\e[97m mysql\e[0m"
echo ""

echo -e "\e[33mUsuário SQL:\e[97m root\e[0m"
echo ""

echo -e "\e[33mSenha SQL:\e[97m $senha_mysql\e[0m"
echo ""

echo -e "\e[33mBanco de dados:\e[97m glpi${1:+_$1}\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗ ███╗   ██╗██╗   ██╗████████╗██╗  ██╗██╗███╗   ██╗ ██████╗     ██╗     ██╗     ███╗   ███╗
## ██╔══██╗████╗  ██║╚██╗ ██╔╝╚══██╔══╝██║  ██║██║████╗  ██║██╔════╝     ██║     ██║     ████╗ ████║
## ███████║██╔██╗ ██║ ╚████╔╝    ██║   ███████║██║██╔██╗ ██║██║  ███╗    ██║     ██║     ██╔████╔██║
## ██╔══██║██║╚██╗██║  ╚██╔╝     ██║   ██╔══██║██║██║╚██╗██║██║   ██║    ██║     ██║     ██║╚██╔╝██║
## ██║  ██║██║ ╚████║   ██║      ██║   ██║  ██║██║██║ ╚████║╚██████╔╝    ███████╗███████╗██║ ╚═╝ ██║
## ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝      ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝     ╚══════╝╚══════╝╚═╝     ╚═╝

ferramenta_anythingllm() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_anythingllm

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Anything LLM (ex: anythingllm.oriondesign.art.br): \e[0m" && read -r url_anythingllm
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_anythingllm
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do anythingllm
    echo -e "\e[33mDominio do Anything LLM:\e[97m $url_anythingllm\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_anythingllm

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO ANYTHING LLM \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria AnythingLLM iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO PGVECTOR \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_pgvector
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Pgvector já instalado"
    pegar_senha_pgvector > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do PgVector"
    criar_banco_pgvector_da_stack "anythingllm${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_pgvector
    pegar_senha_pgvector > /dev/null 2>&1
    criar_banco_pgvector_da_stack "anythingllm${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO ANYTHING LLM \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack anythingllm.yaml
cat > anythingllm${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  anythingllm${1:+_$1}:
    image: mintplexlabs/anythingllm:latest

    volumes:
      - anythingllm${1:+_$1}_storage:/app/server/storage
      - anythingllm${1:+_$1}_hotdir:/app/collector/hotdir
      - anythingllm${1:+_$1}_outputs:/app/collector/outputs

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações gerais
      - SERVER_PORT=3001
      - STORAGE_DIR=/app/server/storage
      - UID=1000
      - GID=1000

    ## 🧩 Dados do PgVector
      - VECTOR_DB=pgvector
      - PGVECTOR_CONNECTION_STRING=postgresql://postgres:$senha_pgvector@pgvector:5432/anythingllm${1:+_$1}

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.anythingllm${1:+_$1}.rule=Host(\`$url_anythingllm\`)
        - traefik.http.services.anythingllm${1:+_$1}.loadbalancer.server.port=3001
        - traefik.http.routers.anythingllm${1:+_$1}.service=anythingllm${1:+_$1}
        - traefik.http.routers.anythingllm${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.anythingllm${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.anythingllm${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  anythingllm${1:+_$1}_storage:
    external: true
    name: anythingllm${1:+_$1}_storage
  anythingllm${1:+_$1}_hotdir:
    external: true
    name: anythingllm${1:+_$1}_hotdir
  anythingllm${1:+_$1}_outputs:
    external: true
    name: anythingllm${1:+_$1}_outputs

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do anythingllm"
fi
STACK_NAME="anythingllm${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c anythingllm.yaml anythingllm > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do anythingllm"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull mintplexlabs/anythingllm:latest

## Usa o serviço wait_stack "anythingllm" para verificar se o serviço esta online
wait_stack anythingllm${1:+_$1}_anythingllm${1:+_$1}

telemetria AnythingLLM finalizado

cd dados_vps

cat > dados_anythingllm <<EOL
[ ANYTHING LLM ]

Dominio do Anything LLM: https://$url_anythingllm

Usuario: Precisa criar no primeiro acesso do Anything LLM

Senha: Precisa criar no primeiro acesso do Anything LLM

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ANYTHING LLM ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_anythingllm\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Anything LLM\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Anything LLM\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗  ██╗ ██████╗ █████╗ ██╗     ██╗██████╗ ██████╗  █████╗ ██╗    ██╗
## ██╔════╝╚██╗██╔╝██╔════╝██╔══██╗██║     ██║██╔══██╗██╔══██╗██╔══██╗██║    ██║
## █████╗   ╚███╔╝ ██║     ███████║██║     ██║██║  ██║██████╔╝███████║██║ █╗ ██║
## ██╔══╝   ██╔██╗ ██║     ██╔══██║██║     ██║██║  ██║██╔══██╗██╔══██║██║███╗██║
## ███████╗██╔╝ ██╗╚██████╗██║  ██║███████╗██║██████╔╝██║  ██║██║  ██║╚███╔███╔╝
## ╚══════╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚══╝╚══╝ 

ferramenta_excalidraw() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_excalidraw

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Excalidraw (ex: excalidraw.oriondesign.art.br): \e[0m" && read -r url_excalidraw
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_excalidraw
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do excalidraw
    echo -e "\e[33mDominio do Excalidraw:\e[97m $url_excalidraw\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_excalidraw

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO EXCALIDRAW \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Excalidraw iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO EXCALIDRAW \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack
cat > excalidraw${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  excalidraw${1:+_$1}:
    image: excalidraw/excalidraw:latest

    volumes:
      - excalidraw${1:+_$1}_data:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações gerais
      - EXCALIDRAW_PORT=80
      - NODE_ENV=development

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.excalidraw${1:+_$1}.rule=Host(\`$url_excalidraw\`)
        - traefik.http.services.excalidraw${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.excalidraw${1:+_$1}.service=excalidraw${1:+_$1}
        - traefik.http.routers.excalidraw${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.excalidraw${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.excalidraw${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  excalidraw${1:+_$1}_data:
    external: true
    name: excalidraw${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do excalidraw"
fi
STACK_NAME="excalidraw${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c excalidraw.yaml excalidraw > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do excalidraw"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull excalidraw/excalidraw:latest

## Usa o serviço wait_stack "excalidraw" para verificar se o serviço esta online
wait_stack excalidraw${1:+_$1}_excalidraw${1:+_$1}

telemetria Excalidraw finalizado

cd dados_vps

cat > dados_excalidraw${1:+_$1} <<EOL
[ EXCALIDRAW ]

Dominio do Excalidraw: https://$url_excalidraw

Usuario: Precisa criar no primeiro acesso do Excalidraw

Senha: Precisa criar no primeiro acesso do Excalidraw
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ EXCALIDRAW ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_excalidraw\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Excalidraw\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Excalidraw\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗ █████╗ ███████╗██╗   ██╗██╗                                                                 
## ██╔════╝██╔══██╗██╔════╝╚██╗ ██╔╝██║                                                                 
## █████╗  ███████║███████╗ ╚████╔╝ ██║                                                                 
## ██╔══╝  ██╔══██║╚════██║  ╚██╔╝  ╚═╝                                                                 
## ███████╗██║  ██║███████║   ██║   ██╗                                                                 
## ╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝                                                                 
##                                                                                                      
##  █████╗ ██████╗ ██████╗  ██████╗ ██╗███╗   ██╗████████╗███╗   ███╗███████╗███╗   ██╗████████╗███████╗
## ██╔══██╗██╔══██╗██╔══██╗██╔═══██╗██║████╗  ██║╚══██╔══╝████╗ ████║██╔════╝████╗  ██║╚══██╔══╝██╔════╝
## ███████║██████╔╝██████╔╝██║   ██║██║██╔██╗ ██║   ██║   ██╔████╔██║█████╗  ██╔██╗ ██║   ██║   ███████╗
## ██╔══██║██╔═══╝ ██╔═══╝ ██║   ██║██║██║╚██╗██║   ██║   ██║╚██╔╝██║██╔══╝  ██║╚██╗██║   ██║   ╚════██║
## ██║  ██║██║     ██║     ╚██████╔╝██║██║ ╚████║   ██║   ██║ ╚═╝ ██║███████╗██║ ╚████║   ██║   ███████║
## ╚═╝  ╚═╝╚═╝     ╚═╝      ╚═════╝ ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝

ferramenta_easyappointments() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_easyappointments

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Easy!Appointments (ex: easyappointments.oriondesign.art.br): \e[0m" && read -r url_easyappointments
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_easyappointments
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do easyappointments
    echo -e "\e[33mDominio do Easy!Appointments:\e[97m $url_easyappointments\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_easyappointments

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO EASY!APPOINTMENTS \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Easy!Appointments iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/4]\e[0m"
echo ""
sleep 1

dados

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "easyapointments${1:+_$1}"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "easyapointments${1:+_$1}"
    fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO EASY!APPOINTMENTS \e[33m[3/4]\e[0m"
echo ""
sleep 1


# Cria o arquivo com o conteúdo desejado
cat > apache-custom.conf << EOL
ServerName $url_easyappointments
EOL

# Cria o diretório, se ainda não existir
mkdir -p /root/easyappointments${1:+_$1} > /dev/null 2>&1

# Move o arquivo para o diretório de destino
sudo mv apache-custom.conf /root/easyappointments${1:+_$1}/apache-custom.conf

## Criando a stack
cat > easyappointments${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  easyapointments${1:+_$1}:
    image: alextselegidis/easyappointments:latest

    volumes:
      - easyapointments${1:+_$1}_data:/var/www/html
      - /root/easyappointments${1:+_$1}/apache-custom.conf:/etc/apache2/conf-enabled/custom.conf:ro

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de acesso
      - BASE_URL=https://$url_easyappointments
      - APACHE_SERVER_NAME=$url_easyappointments

    ## 🗄️ Dados do banco de dados
      - DB_HOST=mysql
      - DB_NAME=easyapointments${1:+_$1}
      - DB_USERNAME=root
      - DB_PASSWORD=$senha_mysql

    ## 📅 Dados Google Calendar
      - GOOGLE_SYNC_FEATURE=false
      - GOOGLE_PRODUCT_NAME=
      - GOOGLE_CLIENT_ID=
      - GOOGLE_CLIENT_SECRET=
      - GOOGLE_API_KEY=

    ## 🐞 Modo de Debug
      - DEBUG_MODE=TRUE

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.easyapointments${1:+_$1}.rule=Host(\`$url_easyappointments\`)
        - traefik.http.services.easyapointments${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.easyapointments${1:+_$1}.service=easyapointments${1:+_$1}
        - traefik.http.routers.easyapointments${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.easyapointments${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.easyapointments${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  easyapointments${1:+_$1}_data:
    external: true
    name: easyapointments${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Easy!Appointments"
fi
STACK_NAME="easyappointments${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c easyappointments.yaml easyappointments > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do easyappointments"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull alextselegidis/easyappointments:latest

## Usa o serviço wait_stack "easyappointments" para verificar se o serviço esta online
wait_stack easyappointments${1:+_$1}_easyapointments${1:+_$1}

telemetria Easy!Appointments finalizado

cd dados_vps

cat > dados_easyappointments${1:+_$1} <<EOL
[ EASY!APPOINTMENTS ]

Dominio do Easy!Appointments: https://$url_easyappointments

Usuario: Precisa criar no primeiro acesso do Easy!Appointments

Senha: Precisa criar no primeiro acesso do Easy!Appointments
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ EASY!APPOINTMENTS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_easyappointments\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do Easy!Appointments\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Easy!Appointments\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ██████╗  ██████╗  ██████╗██╗   ██╗███╗   ███╗███████╗███╗   ██╗███████╗ ██████╗ 
## ██╔══██╗██╔═══██╗██╔════╝██║   ██║████╗ ████║██╔════╝████╗  ██║██╔════╝██╔═══██╗
## ██║  ██║██║   ██║██║     ██║   ██║██╔████╔██║█████╗  ██╔██╗ ██║███████╗██║   ██║
## ██║  ██║██║   ██║██║     ██║   ██║██║╚██╔╝██║██╔══╝  ██║╚██╗██║╚════██║██║   ██║
## ██████╔╝╚██████╔╝╚██████╗╚██████╔╝██║ ╚═╝ ██║███████╗██║ ╚████║███████║╚██████╔╝
## ╚═════╝  ╚═════╝  ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ 

ferramenta_documenso() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_documenso

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio do Builder
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Builder do Documenso (ex: documenso.oriondesign.art.br): \e[0m" && read -r url_documenso
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_documenso
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_email_documenso
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_documenso
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_documenso
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_documenso
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_documenso" -eq 465 ]; then
    smtp_secure_documenso=true
    else
    smtp_secure_documenso=false
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_documenso
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do Builder
    echo -e "\e[33mDominio do Documenso:\e[97m $url_documenso\e[0m"
    echo "" 

    ## Informação sobre Email
    echo -e "\e[33mEmail do SMTP:\e[97m $email_documenso\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mUsuário do SMTP:\e[97m $usuario_email_documenso\e[0m"
    echo ""

    ## Informação sobre Senha do Email
    echo -e "\e[33mSenha do Email:\e[97m $senha_email_documenso\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP do Email:\e[97m $smtp_email_documenso\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_documenso\e[0m"
    echo ""

    ## Informação sobre Secure SMTP
    echo -e "\e[33mSecure SMTP do Email:\e[97m $smtp_secure_documenso\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_documenso

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done


## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO DOCUMENSO \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria Documenso iniciado

## Nada nada nada.. só para aparecer a mensagem de passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/5]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
## Verifica container postgres e cria banco no postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "documenso${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "documenso${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO BUCKET NO MINIO \e[33m[3/5]\e[0m"
echo ""
sleep 1

pegar_senha_minio
minio.bucket documenso${1:+-$1} > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo -e "1/1 - [ OK ] - Criando Bucket\e[33m $BUCKET\e[0m"
else
    echo "1/1 - [ OFF ] - Erro ao criar Bucket"
    echo ""
fi

echo ""
## Mensagem de Passo
echo -e "\e[97m• INSTALANDO DOCUMENSO \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
key_documenso1=$(openssl rand -hex 16)
key_documenso2=$(openssl rand -hex 16)
key_documenso3=$(openssl rand -hex 16)

## Criando a stack documenso.yaml
cat > documenso${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  documenso${1:+_$1}:
    image: documenso/documenso:latest

    volumes:
      - documenso${1:+_$1}_cert:/opt/documenso/cert.p12

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de Acesso
      - PORT=3000
      - NEXTAUTH_URL=https://$url_documenso
      - NEXT_PUBLIC_WEBAPP_URL=https://$url_documenso
      - NEXT_PUBLIC_MARKETING_URL=https://oriondesign.art.br

    ## 🔑 Secret Keys
      - NEXTAUTH_SECRET=$key_documenso1
      - NEXT_PRIVATE_ENCRYPTION_KEY=$key_documenso2
      - NEXT_PRIVATE_ENCRYPTION_SECONDARY_KEY=$key_documenso3

    ## ☁️ Dados do Google Cloud
      #- NEXT_PRIVATE_GOOGLE_CLIENT_ID=
      #- NEXT_PRIVATE_GOOGLE_CLIENT_SECRET=

    ## 🐘 Dados Postgres
      - NEXT_PRIVATE_DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/documenso${1:+_$1}
      - NEXT_PRIVATE_DIRECT_DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/documenso${1:+_$1}

    ## 🗄️ Configurações MinIO
      - NEXT_PUBLIC_UPLOAD_TRANSPORT=s3
      - NEXT_PRIVATE_UPLOAD_ENDPOINT=https://$url_s3
      - NEXT_PRIVATE_UPLOAD_FORCE_PATH_STYLE=true
      - NEXT_PRIVATE_UPLOAD_REGION=eu-south
      - NEXT_PRIVATE_UPLOAD_BUCKET=documenso${1:+-$1}
      - NEXT_PRIVATE_UPLOAD_ACCESS_KEY_ID=$S3_ACCESS_KEY
      - NEXT_PRIVATE_UPLOAD_SECRET_ACCESS_KEY=$S3_SECRET_KEY

    ## ✉️ Dados de SMTP
      - NEXT_PRIVATE_SMTP_TRANSPORT=smtp-auth
      - NEXT_PRIVATE_SMTP_FROM_ADDRESS=$email_documenso
      - NEXT_PRIVATE_SMTP_USERNAME=$usuario_email_documenso
      - NEXT_PRIVATE_SMTP_PASSWORD=$senha_email_documenso
      - NEXT_PRIVATE_SMTP_HOST=$smtp_email_documenso
      - NEXT_PRIVATE_SMTP_PORT=$porta_smtp_documenso
      - NEXT_PRIVATE_SMTP_SECURE=$smtp_secure_documenso
      - NEXT_PRIVATE_SMTP_FROM_NAME=Suporte

    ## ⚙️ Configurações
      - NEXT_PUBLIC_DOCUMENT_SIZE_UPLOAD_LIMIT=10
      - NEXT_PUBLIC_DISABLE_SIGNUP=false
      - NEXT_PRIVATE_SIGNING_LOCAL_FILE_PATH=/opt/documenso/cert.p12

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.documenso${1:+_$1}.rule=Host(\`$url_documenso\`)
        - traefik.http.services.documenso${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.documenso${1:+_$1}.service=documenso${1:+_$1}
        - traefik.http.routers.documenso${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.documenso${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.documenso${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  documenso${1:+_$1}_cert:
    external: true
    name: documenso${1:+_$1}_cert

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do documenso"
fi
STACK_NAME="documenso${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c documenso.yaml documenso > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack do documenso"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull documenso/documenso:latest

## Usa o serviço wait_stack "documenso" para verificar se o serviço esta online
wait_stack documenso${1:+_$1}_documenso${1:+_$1}

telemetria Documenso finalizado

cd dados_vps

cat > dados_documenso${1:+_$1} <<EOL
[ DOCUMENSO ]

Dominio do Documenso: https://$url_documenso

Email: Precisa criar no primeiro acesso do Documenso

Senha: Precisa criar no primeiro acesso do Documenso
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ DOCUMENSO ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_documenso\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m Precisa criar no primeiro acesso do Documenso\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do Documenso\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ███╗   ███╗ ██████╗  ██████╗ ██████╗ ██╗     ███████╗
## ████╗ ████║██╔═══██╗██╔═══██╗██╔══██╗██║     ██╔════╝
## ██╔████╔██║██║   ██║██║   ██║██║  ██║██║     █████╗  
## ██║╚██╔╝██║██║   ██║██║   ██║██║  ██║██║     ██╔══╝  
## ██║ ╚═╝ ██║╚██████╔╝╚██████╔╝██████╔╝███████╗███████╗
## ╚═╝     ╚═╝ ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝╚══════╝
#
#ferramenta_moodle() {
#
### Verifica os recursos
#recursos 1 1 && continue || return
#
### Limpa o terminal
#clear
#
### Ativa a função dados para pegar os dados da vps
#dados
#
### Mostra o nome da aplicação
#nome_moodle
#
### Mostra mensagem para preencher informações
#preencha_as_info
#
### Inicia um Loop até os dados estarem certos
#while true; do
#
#    ##Pergunta o Dominio para a ferramenta
#    echo -e "\e[97mPasso$amarelo 1/10\e[0m"
#    echo -en "\e[33mDigite o dominio para o Moodle (ex: moodle.oriondesign.art.br): \e[0m" && read -r url_moodle
#    echo ""
#
#    ##Pergunta o Dominio para a ferramenta
#    echo -e "\e[97mPasso$amarelo 2/10\e[0m"
#    echo -en "\e[33mDigite o nome para o projeto (ex: OrionDesign): \e[0m" && read -r project_name_moodle
#    echo ""
#
#    ##Pergunta o Dominio para a ferramenta
#    echo -e "\e[97mPasso$amarelo 3/10\e[0m"
#    echo -en "\e[33mDigite um Nome de Usuario (ex: oriondesign): \e[0m" && read -r user_moodle
#    echo ""
#
#    ##Pergunta o Dominio para a ferramenta
#    echo -e "\e[97mPasso$amarelo 4/10\e[0m"
#    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
#    echo -en "\e[33mDigite uma Senha para o Usuario (ex: @Senha123_): \e[0m" && read -r pass_moodle
#    echo ""
#
#    ##Pergunta o Dominio para a ferramenta
#    echo -e "\e[97mPasso$amarelo 5/10\e[0m"
#    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
#    echo -en "\e[33mDigite um Email para o Usuario (ex: contato@oriondesign.art.br): \e[0m" && read -r mail_moodle
#    echo ""
#
#    ##Pergunta o Email SMTP
#    echo -e "\e[97mPasso$amarelo 6/10\e[0m"
#    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_moodle
#    echo ""
#
#    ##Pergunta o usuário do Email SMTP
#    echo -e "\e[97mPasso$amarelo 7/10\e[0m"
#    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
#    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_smtp_moodle
#    echo ""
#    
#    ## Pergunta a senha do SMTP
#    echo -e "\e[97mPasso$amarelo 8/10\e[0m"
#    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
#    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_smtp_moodle
#    echo ""
#
#    ## Pergunta o Host SMTP do email
#    echo -e "\e[97mPasso$amarelo 9/10\e[0m"
#    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_moodle
#    echo ""
#
#    ## Pergunta a porta SMTP do email
#    echo -e "\e[97mPasso$amarelo 10/10\e[0m"
#    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_moodle
#    echo ""
#
#    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
#    if [ "$porta_smtp_typebot" -eq 465 ]; then
#    smtp_secure_smtp_moodle=ssl
#    else
#    smtp_secure_smtp_moodle=tls
#    fi
#
#    
#    ## Limpa o terminal
#    clear
#    
#    ## Mostra o nome da aplicação
#    nome_moodle
#    
#    ## Mostra mensagem para verificar as informações
#    conferindo_as_info
#    
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mDominio do Moodle:\e[97m $url_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mNome do Projeto:\e[97m $project_name_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mUsuario:\e[97m $user_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mSenha:\e[97m $pass_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mEmail:\e[97m $mail_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mUsuario SMTP:\e[97m $usuario_smtp_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mSenha SMTP:\e[97m $senha_smtp_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mHost SMTP\e[97m $host_smtp_moodle\e[0m"
#    echo ""
#
#    ## Informação sobre URL do moodle
#    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_moodle\e[0m"
#    echo ""
#    
#    ## Pergunta se as respostas estão corretas
#    read -p "As respostas estão corretas? (Y/N): " confirmacao
#    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then
#
#        ## Digitou Y para confirmar que as informações estão corretas
#
#        ## Limpar o terminal
#        clear
#
#        ## Mostrar mensagem de Instalando
#        instalando_msg
#
#        ## Sai do Loop
#        break
#    else
#
#        ## Digitou N para dizer que as informações não estão corretas.
#
#        ## Limpar o terminal
#        clear
#
#        ## Mostra o nome da ferramenta
#        nome_moodle
#
#        ## Mostra mensagem para preencher informações
#        preencha_as_info
#
#    ## Volta para o inicio do loop com as perguntas
#    fi
#done
#
### Mensagem de Passo
#echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MOODLE \e[33m[1/3]\e[0m"
#echo ""
#sleep 1
#
#telemetria Moodle iniciado
#
### Nadaaaaa
#
### Mensagem de Passo
#echo -e "\e[97m• INSTALANDO MOODLE \e[33m[2/3]\e[0m"
#echo ""
#sleep 1
#
#senha_marinadb=$(openssl rand -hex 16)
### Criando a stack moodle.yaml
#cat > moodle${1:+_$1}.yaml <<EOL
#version: "3.7"
#services:
#
### --------------------------- ORION --------------------------- ##
#
#  moodle${1:+_$1}_app:
#    image: moodlehq/moodleapp:latest
#
#    volumes:
#      - moodle${1:+_$1}_data:/bitnami/moodle
#      - moodle${1:+_$1}data_data:/bitnami/moodledata
#
#    networks:
#       - $nome_rede_interna ## Nome da rede interna
#
#    environment:
#    ## Dados do projeto
#      - MOODLE_SITE_NAME=$project_name_moodle
#
#    ## Dados de acesso
#      - MOODLE_HOST=$url_moodle
#      - MOODLE_USERNAME=$user_moodle
#      - MOODLE_PASSWORD=$pass_moodle
#      - MOODLE_EMAIL=$mail_moodle
#
#    ## Dados SMTP
#      - MOODLE_SMTP_USER=$usuario_smtp_moodle
#      - MOODLE_SMTP_PASSWORD=$senha_smtp_moodle
#      - MOODLE_SMTP_HOST=$host_smtp_moodle
#      - MOODLE_SMTP_PORT_NUMBER=$porta_smtp_moodle
#      - MOODLE_SMTP_PROTOCOL=$smtp_secure_smtp_moodle ## 587 = tls ou plain | 465 = ssl 
#
#    ## Idioma
#      - MOODLE_LANG=pt
#      
#    ## Dados MarinaDB
#      - MOODLE_DATABASE_HOST=moodle${1:+_$1}_mariadb
#      - MOODLE_DATABASE_PORT_NUMBER=3306
#      - MOODLE_DATABASE_USER=orion_moodle
#      - MOODLE_DATABASE_PASSWORD=$senha_marinadb
#      - MOODLE_DATABASE_NAME=orionbase_moodle
#      - ALLOW_EMPTY_PASSWORD=no
#
#    deploy:
#      mode: replicated
#      replicas: 1
#      placement:
#        constraints:
#          - node.role == manager
#      resources:
#        limits:
#          cpus: "1"
#          memory: 1024M
#      labels:
#        - traefik.enable=true
#        - traefik.http.routers.moodle${1:+_$1}.rule=Host(\`$url_moodle\`)
#        - traefik.http.services.moodle${1:+_$1}.loadbalancer.server.port=8080
#        - traefik.http.routers.moodle${1:+_$1}.service=moodle${1:+_$1}
#        - traefik.http.routers.moodle${1:+_$1}.tls.certresolver=letsencryptresolver
#        - traefik.http.routers.moodle${1:+_$1}.entrypoints=websecure
#        - traefik.http.routers.moodle${1:+_$1}.tls=true
#
### --------------------------- ORION --------------------------- ##
#
#  moodle${1:+_$1}_mariadb:
#    image: mariadb:latest
#
#    volumes:
#      - moodle${1:+_$1}_mariadb_data:/bitnami/mariadb
#
#    networks:
#       - $nome_rede_interna ## Nome da rede interna
#
#    environment:  
#    ## Dados MarinaDB
#      - MARIADB_USER=orion_moodle
#      - MARIADB_ROOT_PASSWORD=$senha_marinadb
#      - MARIADB_DATABASE=orionbase_moodle
#      - MARIADB_PASSWORD=$senha_marinadb
#      - MARIADB_CHARACTER_SET=utf8mb4
#      - MARIADB_COLLATE=utf8mb4_unicode_ci
#      - ALLOW_EMPTY_PASSWORD=no
#
#    deploy:
#      mode: replicated
#      replicas: 1
#      placement:
#        constraints:
#          - node.role == manager
#      resources:
#        limits:
#          cpus: "1"
#          memory: 1024M
#
### --------------------------- ORION --------------------------- ##
#
#volumes:
#  moodle${1:+_$1}_data:
#    external: true
#    name: moodle${1:+_$1}_data
#  moodle${1:+_$1}data_data:
#    external: true
#    name: moodle${1:+_$1}data_data
#  moodle${1:+_$1}_mariadb_data:
#    external: true
#    name: moodle${1:+_$1}_mariadb_data
#
#networks:
#  $nome_rede_interna: ## Nome da rede interna
#    name: $nome_rede_interna ## Nome da rede interna
#    external: true
#EOL
#if [ $? -eq 0 ]; then
#    echo "1/10 - [ OK ] - Criando Stack"
#else
#    echo "1/10 - [ OFF ] - Criando Stack"
#    echo "Não foi possivel criar a stack do Moodle"
#fi
#STACK_NAME="moodle${1:+_$1}"
#stack_editavel # > /dev/null 2>&1
##docker stack deploy --prune --resolve-image always -c moodle.yaml moodle > /dev/null 2>&1
##if [ $? -eq 0 ]; then
##    echo "2/2 - [ OK ] - Deploy Stack"
##else
##    echo "2/2 - [ OFF ] - Deploy Stack"
##    echo "Não foi possivel Subir a stack do moodle"
##fi
#
### Mensagem de Passo
#echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
#echo ""
#sleep 1
#
### Baixando imagens:
#pull moodlehq/moodleapp:latest mariadb:latest
#
### Usa o serviço wait_stack "moodle" para verificar se o serviço esta online
#wait_stack moodle${1:+_$1}_moodle${1:+_$1}_app moodle${1:+_$1}_moodle${1:+_$1}_mariadb
#sleep 120
#
#telemetria Moodle finalizado
#
#cd dados_vps
#
#cat > dados_moodle${1:+_$1} <<EOL
#[ MOODLE ]
#
#Dominio do moodle: https://$url_moodle
#
#Usuario: $user_moodle
#
#Senha: $pass_moodle
#
#EOL
#
#cd
#cd
#
### Espera 30 segundos
#wait_30_sec
#
### Mensagem de finalizado
#instalado_msg
#
### Mensagem de Guarde os Dados
#guarde_os_dados_msg
#
### Dados da Aplicação:
#echo -e "\e[32m[ MOODLE ]\e[0m"
#echo ""
#
#echo -e "\e[33mDominio:\e[97m https://$url_moodle\e[0m"
#echo ""
#
#echo -e "\e[33mUsuario:\e[97m $user_moodle\e[0m"
#echo ""
#
#echo -e "\e[33mSenha:\e[97m $pass_moodle\e[0m"
#echo ""
#
#echo -e "\e[97mObservação:\e[33m Esta é uma ferramenta que pode demorar para iniciar na primeira vez\e[0m"
#echo -e "\e[33mrecomendo aguardar alguns instantes antes de tentar abrir para não prejudicar\e[0m"
#echo -e "\e[33ma sua instalação que já foi realizado.\e[0m"
#
### Creditos do instalador
#creditos_msg
#
### Pergunta se deseja instalar outra aplicação
#requisitar_outra_instalacao
#
#}

## ████████╗ ██████╗  ██████╗ ██╗          ██╗███████╗████████╗
## ╚══██╔══╝██╔═══██╗██╔═══██╗██║          ██║██╔════╝╚══██╔══╝
##    ██║   ██║   ██║██║   ██║██║          ██║█████╗     ██║   
##    ██║   ██║   ██║██║   ██║██║     ██   ██║██╔══╝     ██║   
##    ██║   ╚██████╔╝╚██████╔╝███████╗╚█████╔╝███████╗   ██║   
##    ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝ ╚════╝ ╚══════╝   ╚═╝   

ferramenta_tooljet() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_tooljet

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para a ToolJet (ex: tooljet.oriondesign.art.br): \e[0m" && read -r url_tooljet
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_tooljet
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_smtp_tooljet
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_smtp_tooljet
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_tooljet
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_tooljet
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_tooljet
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio da ToolJet:\e[97m $url_tooljet\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_tooljet\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUser SMTP:\e[97m $usuario_smtp_tooljet\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha SMTP:\e[97m $senha_smtp_tooljet\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mHost SMTP:\e[97m $host_smtp_tooljet\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_tooljet\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_tooljet

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA TOOLJET \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria ToolJet iniciado

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "tooljet${1:+_$1}_app"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "tooljet${1:+_$1}_app"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A TOOLJET \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação da tooljet

## Criando uma Global Key Aleatória
master_key=$(openssl rand -hex 16)
secret_key=$(openssl rand -hex 16)
jwt_key=$(openssl rand -hex 16)

## Criando a stack tooljet.yaml
cat > tooljet${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  tooljet${1:+_$1}_app:
    image: tooljet/tooljet:ee-lts-latest
    command: npm run start:prod

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configuração básica
      - TOOLJET_HOST=https://$url_tooljet
      - SERVE_CLIENT=true
      - LANGUAGE=pt
      - PORT=80

    ## 🚫 Desativar novas inscrições
      - DISABLE_SIGNUPS=false

    ## ❓ Ativar perguntas no Onboarding
      - ENABLE_ONBOARDING_QUESTIONS_FOR_ALL_SIGN_UPS=true

    ## 🔐 Chaves de segurança
      - LOCKBOX_MASTER_KEY=$master_key
      - SECRET_KEY_BASE=$secret_key

    ## 🗄 Configuração do banco de dados principal
      - DATABASE_URL=postgres://postgres:$senha_postgres@postgres:5432/tooljet${1:+_$1}_app?sslmode=disable

    ## 🗃️ Configuração do banco interno do ToolJet
      - ENABLE_TOOLJET_DB=true
      - TOOLJET_DB=tooljet${1:+_$1}
      - TOOLJET_DB_USER=postgres
      - TOOLJET_DB_HOST=postgres
      - TOOLJET_DB_PASS=$senha_postgres

    ## 📡 Configuração do PostgREST
      - PGRST_HOST=tooljet_postgrest${1:+_$1}
      - PGRST_JWT_SECRET=$jwt_key

    ## 🚀 Configuração do Redis
      - REDIS_HOST=redis
      - REDIS_PORT=6379

    ## 🧠 Configurações do Chroma
      - CHROMA_DB_URL=http://tooljet${1:+_$1}_chroma:8000

    ## ✉️ Configuração do SMTP
      - DEFAULT_FROM_EMAIL=$email_smtp_tooljet
      - SMTP_USERNAME=$usuario_smtp_tooljet
      - SMTP_PASSWORD=$senha_smtp_tooljet
      - SMTP_DOMAIN=$host_smtp_tooljet
      - SMTP_PORT=$porta_smtp_tooljet

    ## 🧩 Features do ToolJet
      - COMMENT_FEATURE_ENABLE=true
      - ENABLE_MULTIPLAYER_EDITING=true
      - ENABLE_MARKETPLACE_FEATURE=true
      - DISABLE_TOOLJET_TELEMETRY=true

    ## ⌛ Atualizações e expiração de sessão
      - CHECK_FOR_UPDATES=false
      - USER_SESSION_EXPIRY=120

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.tooljet${1:+_$1}.rule=Host(\`$url_tooljet\`)
        - traefik.http.services.tooljet${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.tooljet${1:+_$1}.service=tooljet${1:+_$1}
        - traefik.http.routers.tooljet${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.tooljet${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.tooljet${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  tooljet${1:+_$1}_postgrest:
    image: postgrest/postgrest:v12.0.2

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      - PGRST_SERVER_PORT=80
      - PGRST_DB_URI=postgres://postgres:$senha_postgres@postgres:5432/tooljet${1:+_$1}_app?sslmode=disable
      - PGRST_DB_SCHEMA=public 
      - PGRST_DB_ANON_ROLE=anon 
      - PGRST_JWT_SECRET=$jwt_key
      - PGRST_JWT_AUD=tooljet${1:+_$1}

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  tooljet${1:+_$1}_chroma:
    image: chromadb/chroma:latest

    volumes:
      - tooljet_chromadb${1:+_$1}:/chroma

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      - CHROMA_HOST_PORT=8000
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M      

## --------------------------- ORION --------------------------- ##

  tooljet${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - tooljet${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  tooljet_chromadb${1:+_$1}:
    external: true
    name: tooljet_chromadb${1:+_$1}
  tooljet${1:+_$1}_redis:
    external: true
    name: tooljet${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da TOOLJET"
fi
STACK_NAME="tooljet${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c tooljet.yaml tooljet > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da tooljet"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest tooljet/tooljet:ee-lts-latest postgrest/postgrest:v12.0.2 chromadb/chroma:latest

## Usa o serviço wait_stack "tooljet" para verificar se o serviço esta online
wait_stack tooljet${1:+_$1}_tooljet${1:+_$1}_redis tooljet${1:+_$1}_tooljet${1:+_$1}_app tooljet${1:+_$1}_tooljet${1:+_$1}_postgrest tooljet${1:+_$1}_tooljet${1:+_$1}_chroma

telemetria ToolJet finalizado

cd dados_vps

cat > dados_tooljet${1:+_$1} <<EOL
[ TOOLJET ]

Dominio: https://$url_tooljet

Usuario: Precisa de criar no primeiro acesso ao ToolJet

Senha: Precisa de criar no primeiro acesso ao ToolJet
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ TOOLJET ]\e[0m"
echo ""

echo -e "\e[97mDominio:\e[33m https://$url_tooljet\e[0m"
echo ""

echo -e "\e[97mUsuario:\e[33m Precisa de criar no primeiro acesso ao ToolJet\e[0m"
echo ""

echo -e "\e[97mSenha:\e[33m Precisa de criar no primeiro acesso ao ToolJet\e[0m"
echo ""

echo "> Aguarde aproximadamente 5 minutos antes de acessar devido à migração em andamento."

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ███████╗████████╗██╗██████╗ ██╗     ██╗███╗   ██╗ ██████╗     ██████╗ ██████╗ ███████╗
## ██╔════╝╚══██╔══╝██║██╔══██╗██║     ██║████╗  ██║██╔════╝     ██╔══██╗██╔══██╗██╔════╝
## ███████╗   ██║   ██║██████╔╝██║     ██║██╔██╗ ██║██║  ███╗    ██████╔╝██║  ██║█████╗  
## ╚════██║   ██║   ██║██╔══██╗██║     ██║██║╚██╗██║██║   ██║    ██╔═══╝ ██║  ██║██╔══╝  
## ███████║   ██║   ██║██║  ██║███████╗██║██║ ╚████║╚██████╔╝    ██║     ██████╔╝██║     
## ╚══════╝   ╚═╝   ╚═╝╚═╝  ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝ ╚═════╝     ╚═╝     ╚═════╝ ╚═╝     
                                                                                      
ferramenta_stirlingpdf() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_stirlingpdf

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o Stirling PDF (ex: stirlingpdf.oriondesign.art.br): \e[0m" && read -r url_stirlingpdf
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o nome para o App (ex: OrionPDF): \e[0m" && read -r name_stirlingpdf
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite uma descrição para o App (ex: Meu app de PDF): \e[0m" && read -r desc_stirlingpdf
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_stirlingpdf
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do stirlingpdf
    echo -e "\e[33mDominio do Stirling PDF:\e[97m $url_stirlingpdf\e[0m"
    echo ""

    ## Informação sobre URL do stirlingpdf
    echo -e "\e[33mNome do App:\e[97m $name_stirlingpdf\e[0m"
    echo ""

    ## Informação sobre URL do stirlingpdf
    echo -e "\e[33mDescrição do App:\e[97m $desc_stirlingpdf\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_stirlingpdf

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO STIRLING PDF \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria StirlingPDF iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO STIRLING PDF \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack stirlingpdf.yaml
cat > stirlingpdf${1:+_$1}.yaml <<EOL
version: "3.7"

services:

## --------------------------- ORION --------------------------- ##

  stirlingpdf${1:+_$1}_backend:
    image: stirlingtools/stirling-pdf:latest ## Versão da aplicação
    
    volumes:
      - stirlingpdf${1:+_$1}_backend_data:/usr/share/tessdata
      - stirlingpdf${1:+_$1}_backend_config:/configs
      - stirlingpdf${1:+_$1}_backend_logs:/logs
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🛡️ Segurança e Autenticação
      - SECURITY_ENABLELOGIN=true
      - DOCKER_ENABLE_SECURITY=false
      - DISABLE_ADDITIONAL_FEATURES=false
      
    ## 🎨 Branding e Interface
      - UI_APPNAME=$name_stirlingpdf
      - UI_APPNAMENAVBAR=$name_stirlingpdf
      - UI_HOMEDESCRIPTION=$desc_stirlingpdf
      # - UI_LOGOSTYLE=classic
      # - UI_LANGUAGES=
      
    ## ⚙️ Configurações do Sistema
      - SYSTEM_DEFAULTLOCALE=pt_BR
      - SYSTEM_MAXFILESIZE=100
      - SYSTEM_GOOGLEVISIBILITY=false
      - METRICS_ENABLED=true
      
    ## 🌐 Idiomas e OCR
      - LANGS=en_GB,en_US,ar_AR,de_DE,fr_FR,es_ES,zh_CN,zh_TW,ca_CA,it_IT,sv_SE,pl_PL,ro_RO,ko_KR,pt_BR,ru_RU,el_GR,hi_IN,hu_HU,tr_TR,id_ID
      # - TESSERACT_LANGS=eng,por,spa,fra,deu
      
    ## 🐳 Docker e Permissões
      - PUID=1000
      - PGID=1000
      - UMASK=022
      
    ## 📧 Dados do SMTP (opicional)
      - MAIL_ENABLED=false
      - MAIL_ENABLEINVITES=false
      - MAIL_HOST=smtp.example.com
      - MAIL_PORT=587
      - MAIL_USERNAME=
      - MAIL_PASSWORD=
      - MAIL_FROM=
      
    ## ⭐ Premium/Enterprise
      # - PREMIUM_KEY=
      # - PREMIUM_ENABLED=false
      # - PREMIUM_PROFEATURES_SSOAUTOLOGIN=false
      # - PREMIUM_ENTERPRISEFEATURES_AUDIT_ENABLED=true
      # - PREMIUM_ENTERPRISEFEATURES_AUDIT_LEVEL=2
      # - PREMIUM_ENTERPRISEFEATURES_AUDIT_RETENTIONDAYS=90
    
    ## 🔄 Modo
      - MODE=BACKEND
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  stirlingpdf${1:+_$1}_frontend:
    image: stirlingtools/stirling-pdf:latest ## Versão do frontend
    
    volumes:
      - stirlingpdf${1:+_$1}_frontend_data:/usr/share/nginx/html
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🔗 Backend e API
      - BACKEND_URL=http://stirlingpdf${1:+_$1}_backend:8080
    
    ## ☁️ Integrações Google Drive
      # - VITE_GOOGLE_DRIVE_CLIENT_ID=
      # - VITE_GOOGLE_DRIVE_API_KEY=
      # - VITE_GOOGLE_DRIVE_APP_ID=
    
    ## 🔄 Modo
      - MODE=FRONTEND
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.5"
          memory: 512M
      labels:
        - traefik.enable=true
        - traefik.http.routers.stirlingpdf${1:+_$1}_frontend.rule=Host(\`$url_stirlingpdf\`) ## Url da aplicação
        - traefik.http.services.stirlingpdf${1:+_$1}_frontend.loadbalancer.server.port=8080
        - traefik.http.routers.stirlingpdf${1:+_$1}_frontend.service=stirlingpdf${1:+_$1}_frontend
        - traefik.http.routers.stirlingpdf${1:+_$1}_frontend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.stirlingpdf${1:+_$1}_frontend.entrypoints=websecure
        - traefik.http.routers.stirlingpdf${1:+_$1}_frontend.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  stirlingpdf${1:+_$1}_backend_data:
    external: true
    name: stirlingpdf${1:+_$1}_backend_data
  stirlingpdf${1:+_$1}_backend_config:
    external: true
    name: stirlingpdf${1:+_$1}_backend_config
  stirlingpdf${1:+_$1}_backend_logs:
    external: true
    name: stirlingpdf${1:+_$1}_backend_logs
  stirlingpdf${1:+_$1}_frontend_data:
    external: true
    name: stirlingpdf${1:+_$1}_frontend_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do stirlingpdf"
fi
STACK_NAME="stirlingpdf${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c stirlingpdf.yaml stirlingpdf > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do stirlingpdf"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull stirlingtools/stirling-pdf:latest

## Usa o serviço wait_stirlingpdf para verificar se o serviço esta online
wait_stack stirlingpdf${1:+_$1}_stirlingpdf${1:+_$1}_backend stirlingpdf${1:+_$1}_stirlingpdf${1:+_$1}_frontend

telemetria StirlingPDF finalizado

cd dados_vps

cat > dados_stirlingpdf${1:+_$1} <<EOL
[ STIRLING PDF ]

Dominio do stirlingpdf: https://$url_stirlingpdf

Usuario: admin

Senha: stirling

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ STIRLING PDF ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_stirlingpdf\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m admin\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m stirling\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

##  ██████╗██╗     ██╗ ██████╗██╗  ██╗██╗  ██╗ ██████╗ ██╗   ██╗███████╗███████╗
## ██╔════╝██║     ██║██╔════╝██║ ██╔╝██║  ██║██╔═══██╗██║   ██║██╔════╝██╔════╝
## ██║     ██║     ██║██║     █████╔╝ ███████║██║   ██║██║   ██║███████╗█████╗  
## ██║     ██║     ██║██║     ██╔═██╗ ██╔══██║██║   ██║██║   ██║╚════██║██╔══╝  
## ╚██████╗███████╗██║╚██████╗██║  ██╗██║  ██║╚██████╔╝╚██████╔╝███████║███████╗
##  ╚═════╝╚══════╝╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚══════╝╚══════╝
                                                                                      
ferramenta_clickhouse() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_clickhouse

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o ClickHouse (ex: clickhouse.oriondesign.art.br): \e[0m" && read -r url_clickhouse
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite um nome de usuario para o ClickHouse (ex: admin): \e[0m" && read -r user_clickhouse
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite uma senha para o usuario (ex: @Senha123_): \e[0m" && read -r pass_clickhouse
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_clickhouse
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do clickhouse
    echo -e "\e[33mDominio do ClickHouse:\e[97m $url_clickhouse\e[0m"
    echo ""

    ## Informação sobre URL do clickhouse
    echo -e "\e[33mUsuario:\e[97m $user_clickhouse\e[0m"
    echo ""

    ## Informação sobre URL do clickhouse
    echo -e "\e[33mSenha:\e[97m $pass_clickhouse\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_clickhouse

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO CLICKHOUSE \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria ClickHouse iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO CLICKHOUSE \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack clickhouse.yaml
cat > clickhouse${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  clickhouse${1:+_$1}:
    image: clickhouse/clickhouse-server:23.8.8.20-alpine

    volumes:
      - clickhouse${1:+_$1}_data:/var/lib/clickhouse
      - clickhouse${1:+_$1}_log:/var/log/clickhouse-server

    networks:
      - $nome_rede_interna ## Nome da rede interna
    #ports:
    #  - "8123:8123"
    #  - "9000:9000"
    #  - "9009:9009"

    environment:
    ## 🗄️ Database Padrão
      - CLICKHOUSE_DB=default

    ## 🔐 Credenciais
      - CLICKHOUSE_USER=$user_clickhouse
      - CLICKHOUSE_PASSWORD=$pass_clickhouse

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.clickhouse${1:+_$1}.rule=Host(\`$url_clickhouse\`)
        - traefik.http.services.clickhouse${1:+_$1}.loadbalancer.server.port=8123
        - traefik.http.routers.clickhouse${1:+_$1}.service=clickhouse${1:+_$1}
        - traefik.http.routers.clickhouse${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.clickhouse${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.routers.clickhouse${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.clickhouse${1:+_$1}.tls=true        

## --------------------------- ORION --------------------------- ##

volumes:
  clickhouse${1:+_$1}_data:
    external: true
    name: clickhouse${1:+_$1}_data
  clickhouse${1:+_$1}_log:
    external: true
    name: clickhouse${1:+_$1}_log
  
networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do clickhouse"
fi
STACK_NAME="clickhouse${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c clickhouse.yaml clickhouse > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do clickhouse"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull clickhouse/clickhouse-server:23.8.8.20-alpine

## Usa o serviço wait_clickhouse para verificar se o serviço esta online
wait_stack clickhouse${1:+_$1}_clickhouse${1:+_$1}

telemetria ClickHouse finalizado

cd dados_vps

cat > dados_clickhouse${1:+_$1} <<EOL
[ CLICKHOUSE ]

Dashboard do clickhouse: https://$url_clickhouse/dashboard

API do clickhouse: https://$url_clickhouse

Usuario: $user_clickhouse

Senha: $pass_clickhouse

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ CLICKHOUSE ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_clickhouse\e[0m"
echo ""

echo -e "\e[33mDashboard:\e[97m https://$url_clickhouse/dashboard\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_clickhouse\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_clickhouse\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ██████╗ ███████╗██████╗ ██╗███████╗██╗███╗   ██╗███████╗██╗ ██████╗ ██╗  ██╗████████╗
## ██╔══██╗██╔════╝██╔══██╗██║██╔════╝██║████╗  ██║██╔════╝██║██╔════╝ ██║  ██║╚══██╔══╝
## ██████╔╝█████╗  ██║  ██║██║███████╗██║██╔██╗ ██║███████╗██║██║  ███╗███████║   ██║   
## ██╔══██╗██╔══╝  ██║  ██║██║╚════██║██║██║╚██╗██║╚════██║██║██║   ██║██╔══██║   ██║   
## ██║  ██║███████╗██████╔╝██║███████║██║██║ ╚████║███████║██║╚██████╔╝██║  ██║   ██║   
## ╚═╝  ╚═╝╚══════╝╚═════╝ ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   
                                                                                      
ferramenta_redisinsight() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_redisinsight

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o RedisInsight (ex: redisinsight.oriondesign.art.br): \e[0m" && read -r url_redisinsight
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite um usuario para o RedisInsight (ex: admin): \e[0m" && read -r user_redisinsight
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite uma senha para o usuario (ex: @Senha123_): \e[0m" && read -r pass_redisinsight
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_redisinsight
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do redisinsight
    echo -e "\e[33mDominio do redisInsight:\e[97m $url_redisinsight\e[0m"
    echo ""

    ## Informação sobre URL do redisinsight
    echo -e "\e[33mUsuario:\e[97m $user_redisinsight\e[0m"
    echo ""

    ## Informação sobre URL do redisinsight
    echo -e "\e[33mSenha:\e[97m $pass_redisinsight\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_redisinsight

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO REDISINSIGHT \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria RedisInsight iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO REDISINSIGHT \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Gerando Hash
auth_redisinsight=$(htpasswd -nb $user_redisinsight $pass_redisinsight | sed -e s/\\$/\\$\\$/g)

## Criando a stack redisinsight.yaml
cat > redisinsight${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  redisinsight${1:+_$1}:
    image: redislabs/redisinsight:latest

    volumes:
      - redisinsight${1:+_$1}_data:/db
      - redisinsight${1:+_$1}_logs:/data/logs

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🧩 Aplicação
      - RI_APP_PORT=5540
      - RI_APP_HOST=0.0.0.0

    ## 🔐 Encryption Key
      - RI_ENCRYPTION_KEY=$key_redisinsight

    ## 📜 Logs
      - RI_LOG_LEVEL=info
      - RI_FILES_LOGGER=false
      - RI_STDOUT_LOGGER=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.redisinsight${1:+_$1}.rule=Host(\`$url_redisinsight\`) ## Dominio do RedisInsight
        - traefik.http.services.redisinsight${1:+_$1}.loadbalancer.server.port=5540
        - traefik.http.routers.redisinsight${1:+_$1}.service=redisinsight${1:+_$1}
        - traefik.http.routers.redisinsight${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.redisinsight${1:+_$1}.entrypoints=websecure
        - traefik.http.middlewares.redisinsight${1:+_$1}-auth.basicauth.users=$auth_redisinsight
        - traefik.http.routers.redisinsight${1:+_$1}.middlewares=redisinsight${1:+_$1}-auth
        - traefik.http.routers.redisinsight${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  redisinsight${1:+_$1}_data:
    external: true
    name: redisinsight${1:+_$1}_data
  redisinsight${1:+_$1}_logs:
    external: true
    name: redisinsight${1:+_$1}_logs

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do RedisInsight"
fi
STACK_NAME="redisinsight${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c redisinsight.yaml redisinsight > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do redisinsight"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redislabs/redisinsight:latest

## Usa o serviço wait_redisinsight para verificar se o serviço esta online
wait_stack redisinsight${1:+_$1}_redisinsight${1:+_$1}

telemetria RedisInsight finalizado

cd dados_vps

cat > dados_redisinsight${1:+_$1} <<EOL
[ REDISINSIGHT ]

Dominio do redisInsight: https://$url_redisinsight

Usuario: $user_redisinsight

Senha: $pass_redisinsight


EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ REDISINSIGHT ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_redisinsight\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_redisinsight\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_redisinsight\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ████████╗██████╗  █████╗  ██████╗ ██████╗ █████╗ ██████╗ 
## ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔══██╗
##    ██║   ██████╔╝███████║██║     ██║     ███████║██████╔╝
##    ██║   ██╔══██╗██╔══██║██║     ██║     ██╔══██║██╔══██╗
##    ██║   ██║  ██║██║  ██║╚██████╗╚██████╗██║  ██║██║  ██║
##    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝
                                                                                      
ferramenta_traccar() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_traccar

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Traccar (ex: traccar.oriondesign.art.br): \e[0m" && read -r url_traccar
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_traccar
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do traccar
    echo -e "\e[33mDominio do Traccar:\e[97m $url_traccar\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_traccar

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO TRACCAR \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Traccar iniciado

cd
cd

gerar_senha_mysql=$(openssl rand -hex 16)

mkdir -p /opt/traccar${1:+_$1}/logs

cat > traccar.xml <<EOL
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    <entry key="database.driver">com.mysql.cj.jdbc.Driver</entry>
    <entry key="database.url">jdbc:mysql://traccar${1:+_$1}_db:3306/traccar?allowPublicKeyRetrieval=true&amp;useSSL=false</entry>
    <entry key="database.user">traccar</entry>
    <entry key="database.password">$gerar_senha_mysql</entry>
    <entry key="web.port">8082</entry>
</properties>
EOL

mv traccar.xml /opt/traccar${1:+_$1}/

cd
cd

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO TRACCAR \e[33m[2/3]\e[0m"
echo ""
sleep 1



## Criando a stack traccar.yaml
cat > traccar${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  traccar${1:+_$1}:
    image: traccar/traccar:latest
    
    volumes:
      - /opt/traccar${1:+_$1}/logs:/opt/traccar${1:+_$1}/logs:rw
      - /opt/traccar${1:+_$1}/traccar.xml:/opt/traccar${1:+_$1}/conf/traccar.xml:ro
      - traccar${1:+_$1}_data:/opt/traccar/

    networks:
     - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔄 Java Options
      - JAVA_OPTS=-Xms1g -Xmx1g -Djava.net.preferIPv4Stack=true
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.traccar${1:+_$1}.rule=Host(\`$url_traccar\`)
        - traefik.http.services.traccar${1:+_$1}.loadbalancer.server.port=8082
        - traefik.http.routers.traccar${1:+_$1}.service=traccar${1:+_$1}
        - traefik.http.routers.traccar${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.traccar${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.traccar${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  traccar${1:+_$1}_db:
    image: mysql:8.0

    volumes:
      - traccar${1:+_$1}_db:/var/lib/mysql

    networks:
     - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Credenciais
      - MYSQL_ROOT_PASSWORD=rootpassword
      - MYSQL_DATABASE=traccar
      - MYSQL_USER=traccar
      - MYSQL_PASSWORD=$gerar_senha_mysql

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  traccar${1:+_$1}_data:
    external: true
    name: traccar${1:+_$1}_data
  traccar${1:+_$1}_db:
    external: true
    name: traccar${1:+_$1}_db
    
networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do traccar"
fi
STACK_NAME="traccar${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c traccar.yaml traccar > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do traccar"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull traccar/traccar:latest mysql:8.0

## Usa o serviço wait_traccar para verificar se o serviço esta online
wait_stack traccar${1:+_$1}_traccar${1:+_$1} traccar${1:+_$1}_traccar${1:+_$1}_db

telemetria Traccar finalizado

cd dados_vps

cat > dados_traccar${1:+_$1} <<EOL
[ TRACCAR ]

Dominio do Traccar: https://$url_traccar

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ TRACCAR ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_traccar\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar no primeiro acesso do traccar\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar no primeiro acesso do traccar\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ███████╗██╗██████╗ ███████╗ ██████╗██████╗  █████╗ ██╗    ██╗██╗     
## ██╔════╝██║██╔══██╗██╔════╝██╔════╝██╔══██╗██╔══██╗██║    ██║██║     
## █████╗  ██║██████╔╝█████╗  ██║     ██████╔╝███████║██║ █╗ ██║██║     
## ██╔══╝  ██║██╔══██╗██╔══╝  ██║     ██╔══██╗██╔══██║██║███╗██║██║     
## ██║     ██║██║  ██║███████╗╚██████╗██║  ██║██║  ██║╚███╔███╔╝███████╗
## ╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚══╝╚══╝ ╚══════╝
                                                                                      
ferramenta_firecrawl() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_firecrawl

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o Firecrawl (ex: firecrawl.oriondesign.art.br): \e[0m" && read -r url_firecrawl
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite uma ApiKey da OpenAI: \e[0m" && read -r api_firecrawl
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_firecrawl
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do firecrawl
    echo -e "\e[33mDominio do Firecrawl:\e[97m $url_firecrawl\e[0m"
    echo ""

    ## Informação sobre URL do firecrawl
    echo -e "\e[33mApiKey OpenAi:\e[97m $api_firecrawl\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_firecrawl

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO FIRECRAWL \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Firecrawl iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO FIRECRAWL \e[33m[2/3]\e[0m"
echo ""
sleep 1

apikey_firecrawl="fc-$(cat /dev/urandom | tr -dc 'a-f0-9' | head -c 32)"
postgres_password=$(openssl rand -hex 16)
## Criando a stack firecrawl.yaml
cat > firecrawl${1:+_$1}.yaml <<EOL
version: "3.8"
services:

## --------------------------- ORION --------------------------- ##

  firecrawl${1:+_$1}_api:
    image: ghcr.io/firecrawl/firecrawl:latest
    command: [ "node", "--max-old-space-size=6144", "dist/src/index.js" ]

    networks:
     - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 API Key
      - FIRECRAWL_API_KEY=$apikey_firecrawl

    ## 🐘 Configurações do PostgreSQL (NUQ)
      - POSTGRES_HOST=firecrawl${1:+_$1}_nuq_postgres
      - POSTGRES_PORT=5432
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$postgres_password
      - POSTGRES_DB=postgres
      - NUQ_DATABASE_URL=postgresql://postgres:$postgres_password@firecrawl${1:+_$1}_nuq_postgres:5432/postgres
      - NUQ_DATABASE_URL_LISTEN=postgresql://postgres:$postgres_password@firecrawl${1:+_$1}_nuq_postgres:5432/postgres

    ## 🔺 Dados do Redis
      - REDIS_URL=redis://firecrawl${1:+_$1}_redis:6379
      - REDIS_RATE_LIMIT_URL=redis://firecrawl${1:+_$1}_redis:6379
      
    ## 🔮 Dados da OpenAI
      - OPENAI_API_KEY=$api_firecrawl
      - OPENAI_BASE_URL=https://api.openai.com/v1
      - MODEL_NAME=gpt-4o
      
    ## 🐝 Dados do ScrapingBee (opcional)
      - SCRAPING_BEE_API_KEY=
      
    ## 🌐 Configurações do Host e Porta
      - HOST=0.0.0.0
      - PORT=3002
      - INTERNAL_PORT=3002
      - WORKER_PORT=3005
      - EXTRACT_WORKER_PORT=3004
      
    ## 🪝 Dados do Webhook e Debug
      - SELF_HOSTED_WEBHOOK_URL=
      - LOGGING_LEVEL=DEBUG
      
    ## 🛰️ Dados do Supabase (opcional)
      - USE_DB_AUTHENTICATION=false
      #- SUPABASE_URL=
      #- SUPABASE_ANON_TOKEN=
      #- SUPABASE_SERVICE_TOKEN=
      
    ## 🛠️ Configurações de Workers
      - NUM_WORKERS_PER_QUEUE=8
      - CRAWL_CONCURRENT_REQUESTS=10
      - MAX_CONCURRENT_JOBS=5
      - BROWSER_POOL_SIZE=5
      
    ## 🎭 Configurações do Playwright Service
      - PLAYWRIGHT_MICROSERVICE_URL=http://firecrawl${1:+_$1}_playwright:3000/scrape
      
    ## 🧩 Configurações de Proxy (opcional)
      - PROXY_SERVER=
      - PROXY_USERNAME=
      - PROXY_PASSWORD=
      
    ## ⚙️ Outras configurações
      - FLY_PROCESS_GROUP=app
      - ENV=production
      
    ## ➕ Configurações adicionais (opcional)
      #- MODEL_EMBEDDING_NAME=
      #- OLLAMA_BASE_URL=
      #- SLACK_WEBHOOK_URL=
      #- BULL_AUTH_KEY=
      #- TEST_API_KEY=
      #- SEARXNG_ENDPOINT=
      #- SEARXNG_ENGINES=
      #- SEARXNG_CATEGORIES=
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4G
      labels:
        - traefik.enable=true
        - traefik.http.routers.firecrawl${1:+_$1}_api.rule=Host(\`$url_firecrawl\`)
        - traefik.http.services.firecrawl${1:+_$1}_api.loadbalancer.server.port=3002
        - traefik.http.routers.firecrawl${1:+_$1}_api.service=firecrawl${1:+_$1}_api
        - traefik.http.routers.firecrawl${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.routers.firecrawl${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.firecrawl${1:+_$1}_api.tls=true

## --------------------------- ORION --------------------------- ##

  firecrawl${1:+_$1}_worker:
    image: ghcr.io/firecrawl/firecrawl:latest
    command: [ "node", "--max-old-space-size=3072", "dist/src/services/queue-worker.js" ]
    
    networks:
     - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🐘 Configurações do PostgreSQL (NUQ)
      - POSTGRES_HOST=firecrawl${1:+_$1}_nuq_postgres
      - POSTGRES_PORT=5432
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$postgres_password
      - POSTGRES_DB=postgres
      - NUQ_DATABASE_URL=postgresql://postgres:$postgres_password@firecrawl${1:+_$1}_nuq_postgres:5432/postgres
      - NUQ_DATABASE_URL_LISTEN=postgresql://postgres:$postgres_password@firecrawl${1:+_$1}_nuq_postgres:5432/postgres

    ## 🔺 Dados do Redis
      - REDIS_URL=redis://firecrawl${1:+_$1}_redis:6379
      - REDIS_RATE_LIMIT_URL=redis://firecrawl${1:+_$1}_redis:6379
      
    ## 🔮 Dados da OpenAI
      - OPENAI_API_KEY=$api_firecrawl
      - OPENAI_BASE_URL=https://api.openai.com/v1
      - MODEL_NAME=gpt-4o
      
    ## 🐝 Dados do ScrapingBee (opcional)
      - SCRAPING_BEE_API_KEY=
      
    ## 🌐 Configurações do Host e Porta
      - HOST=0.0.0.0
      - PORT=3005
      - WORKER_PORT=3005
      
    ## 🪝 Dados do Webhook e Debug
      - SELF_HOSTED_WEBHOOK_URL=
      - LOGGING_LEVEL=DEBUG
      
    ## 🛰️ Dados do Supabase (opcional)
      - USE_DB_AUTHENTICATION=false
      #- SUPABASE_URL=
      #- SUPABASE_ANON_TOKEN=
      #- SUPABASE_SERVICE_TOKEN=
      
    ## 🛠️ Configurações de Workers
      - NUM_WORKERS_PER_QUEUE=8
      - CRAWL_CONCURRENT_REQUESTS=10
      - MAX_CONCURRENT_JOBS=5
      - BROWSER_POOL_SIZE=5
      
    ## 🎭 Configurações do Playwright Service
      - PLAYWRIGHT_MICROSERVICE_URL=http://firecrawl${1:+_$1}_playwright:3000/scrape
      
    ## 🧩 Configurações de Proxy (opcional)
      - PROXY_SERVER=
      - PROXY_USERNAME=
      - PROXY_PASSWORD=
      
    ## ⚙️ Outras configurações
      - FLY_PROCESS_GROUP=worker
      - ENV=production
      
    ## ➕ Configurações adicionais (opcional)
      #- MODEL_EMBEDDING_NAME=
      #- OLLAMA_BASE_URL=
      #- SLACK_WEBHOOK_URL=
      #- BULL_AUTH_KEY=
      #- TEST_API_KEY=
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 4G

## --------------------------- ORION --------------------------- ##

  firecrawl${1:+_$1}_playwright:
    image: ghcr.io/firecrawl/playwright-service:latest

    networks:
     - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Configurações da Aplicação
      - PORT=3000
      - BLOCK_MEDIA=true
      - MAX_CONCURRENT_PAGES=10
    
    ## 🧩 Configurações de Proxy
      - PROXY_SERVER=$proxy_server
      - PROXY_USERNAME=$proxy_username
      - PROXY_PASSWORD=$proxy_password

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4G

## --------------------------- ORION --------------------------- ##

  firecrawl${1:+_$1}_nuq_postgres:
    image: ghcr.io/firecrawl/nuq-postgres:latest

    volumes:
      - firecrawl${1:+_$1}_postgres:/var/lib/postgresql/data

    networks:
     - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🐘 Configurações do PostgreSQL (NUQ)
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$postgres_password
      - POSTGRES_DB=postgres
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "0.5"
          memory: 1G

## --------------------------- ORION --------------------------- ##

  firecrawl${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - firecrawl${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  firecrawl${1:+_$1}_postgres:
    external: true
    name: firecrawl${1:+_$1}_postgres
  firecrawl${1:+_$1}_redis:
    external: true
    name: firecrawl${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do firecrawl"
fi
STACK_NAME="firecrawl${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c firecrawl.yaml firecrawl > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do firecrawl"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/firecrawl/nuq-postgres:latest redis:latest  ghcr.io/firecrawl/firecrawl:latest ghcr.io/firecrawl/playwright-service:latest

## Usa o serviço wait_firecrawl para verificar se o serviço esta online
wait_stack firecrawl${1:+_$1}_firecrawl${1:+_$1}_nuq_postgres firecrawl${1:+_$1}_firecrawl${1:+_$1}_api firecrawl${1:+_$1}_firecrawl${1:+_$1}_worker firecrawl${1:+_$1}_firecrawl${1:+_$1}_playwright firecrawl${1:+_$1}_firecrawl${1:+_$1}_redis 

telemetria Firecrawl finalizado

cd dados_vps

cat > dados_firecrawl${1:+_$1} <<EOL
[ FIRECRAWL ]

Dominio do firecrawl: https://$url_firecrawl

API Key: $apikey_firecrawl
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ FIRECRAWL ]\e[0m"
echo ""

echo -e "\e[33mDominio da API:\e[97m https://$url_firecrawl\e[0m"
echo ""

echo -e "\e[33mAPI Key:\e[97m $apikey_firecrawl\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ██╗    ██╗██╗   ██╗███████╗ █████╗ ██████╗ ██╗
## ██║    ██║██║   ██║╚══███╔╝██╔══██╗██╔══██╗██║
## ██║ █╗ ██║██║   ██║  ███╔╝ ███████║██████╔╝██║
## ██║███╗██║██║   ██║ ███╔╝  ██╔══██║██╔═══╝ ██║
## ╚███╔███╔╝╚██████╔╝███████╗██║  ██║██║     ██║
##  ╚══╝╚══╝  ╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝
                                                                                      
ferramenta_wuzapi() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_wuzapi

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Wuzapi (ex: wuzapi.oriondesign.art.br): \e[0m" && read -r url_wuzapi
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_wuzapi
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do wuzapi
    echo -e "\e[33mDominio do wuzapi:\e[97m $url_wuzapi\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_wuzapi

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WUZAPI \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Wuzapi iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "wuzapi${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "wuzapi${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO WUZAPI \e[33m[3/4]\e[0m"
echo ""
sleep 1

apikey_wuzapi=$(openssl rand -hex 16)
encryption_key=$(openssl rand -hex 16)
## Criando a stack wuzapi.yaml
cat > wuzapi${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

 wuzapi${1:+_$1}:
  image: asternic/wuzapi:latest

  volumes:
    - wuzapi${1:+_$1}_dbdata:/app/dbdata
    - wuzapi${1:+_$1}_files:/app/files

  networks:
    - $nome_rede_interna ## Nome da rede interna

  environment:
  ## 🔑 Credencial
    - WUZAPI_ADMIN_TOKEN=$apikey_wuzapi
    - SECRET_KEY=$encryption_key

  ## 🐘 Dados do postgres
    - DB_HOST=postgres
    - DB_USER=postgres
    - DB_PASSWORD=$senha_postgres
    - DB_NAME=wuzapi${1:+_$1}
    - DB_PORT=5432
    - DB_DRIVER=postgres

  ## 🌐 Timezone
    - TZ=America/Sao_Paulo

  ## 🪝 Formato do webhook
    - WEBHOOK_FORMAT=json

  ## 📱 Nome do dispositivo
    - SESSION_DEVICE_NAME=OrionDesign

  ## 🐰 Configurações do RabbitMQ
    #- RABBITMQ_URL=amqp://wuzapi:wuzapi@rabbitmq:5672/
    #- RABBITMQ_QUEUE=whatsapp_events

  deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      #resources:
      #  limits:
      #    cpus: "1"
      #    memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.wuzapi${1:+_$1}.rule=Host(\`$url_wuzapi\`)
        - traefik.http.services.wuzapi${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.routers.wuzapi${1:+_$1}.service=wuzapi${1:+_$1}
        - traefik.http.routers.wuzapi${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.wuzapi${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.wuzapi${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  wuzapi${1:+_$1}_dbdata:
    external: true
    name: wuzapi${1:+_$1}_dbdata
  wuzapi${1:+_$1}_files:
    external: true
    name: wuzapi${1:+_$1}_files

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do wuzapi"
fi
STACK_NAME="wuzapi${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c wuzapi.yaml wuzapi > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do wuzapi"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull asternic/wuzapi:latest

## Usa o serviço wait_wuzapi para verificar se o serviço esta online
wait_stack wuzapi${1:+_$1}_wuzapi${1:+_$1}

telemetria Wuzapi finalizado

cd dados_vps

cat > dados_wuzapi${1:+_$1} <<EOL
[ WUZAPI ]

Dominio do wuzapi: https://$url_wuzapi

Apikey: $apikey_wuzapi
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WUZAPI ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_wuzapi\e[0m"
echo ""

echo -e "\e[33mDashboard:\e[97m https://$url_wuzapi/dashboard\e[0m"
echo ""

echo -e "\e[33mDocumentação:\e[97m https://$url_wuzapi/api\e[0m"
echo ""

echo -e "\e[33mAPI Key:\e[97m $apikey_wuzapi\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ██╗  ██╗██████╗  █████╗ ██╗   ██╗██╗███╗   ██╗     ██████╗██████╗ ███╗   ███╗
## ██║ ██╔╝██╔══██╗██╔══██╗╚██╗ ██╔╝██║████╗  ██║    ██╔════╝██╔══██╗████╗ ████║
## █████╔╝ ██████╔╝███████║ ╚████╔╝ ██║██╔██╗ ██║    ██║     ██████╔╝██╔████╔██║
## ██╔═██╗ ██╔══██╗██╔══██║  ╚██╔╝  ██║██║╚██╗██║    ██║     ██╔══██╗██║╚██╔╝██║
## ██║  ██╗██║  ██║██║  ██║   ██║   ██║██║ ╚████║    ╚██████╗██║  ██║██║ ╚═╝ ██║
## ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝     ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝
                                                                                      
ferramenta_krayincrm() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_krayincrm

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o dominio para o Krayin CRM (ex: krayincrm.oriondesign.art.br): \e[0m" && read -r url_krayincrm
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_krayincrm
    echo ""

    ## Sepera dominio
    dominio_smtp=$(echo "$email_krayincrm" | cut -d'@' -f2)

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_email_krayincrm
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_krayincrm
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_krayincrm
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_krayincrm
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_krayincrm" -eq 465 ]; then
    smtp_secure_krayincrm=ssl
    else
    smtp_secure_krayincrm=tls
    fi   
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_krayincrm
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do krayincrm
    echo -e "\e[33mDominio do krayincrm:\e[97m $url_krayincrm\e[0m"
    echo ""

     ## Informação sobre Email
    echo -e "\e[33mEmail do SMTP:\e[97m $email_krayincrm\e[0m"
    echo ""

    ## Informação sobre Email
    echo -e "\e[33mUsuário do SMTP:\e[97m $usuario_email_krayincrm\e[0m"
    echo ""

    ## Informação sobre Senha do Email
    echo -e "\e[33mSenha do Email:\e[97m $senha_email_krayincrm\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP do Email:\e[97m $smtp_email_krayincrm\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP do Email:\e[97m $porta_smtp_krayincrm\e[0m"
    echo ""

    ## Informação sobre Secure SMTP
    echo -e "\e[33mSecure SMTP do Email:\e[97m $smtp_secure_krayincrm\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_krayincrm

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO KRAYIN CRM \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria "Krayin CRM" "iniciado"

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO KRAYIN CRM \e[33m[2/4]\e[0m"
echo ""
sleep 1

secret_key="base64:$(openssl rand -base64 32)"
senha_percona_krayin=$(openssl rand -hex 16)

## Criando a stack krayincrm.yaml
cat > krayincrm${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  krayin${1:+_$1}_app:
    image: webkul/krayin:v2.1.2-https

    volumes:
      - krayin${1:+_$1}_app:/var/www/html/
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
      ## 🔑 Configurações básicas da aplicação
      - APP_URL=https://$url_krayincrm
      - APP_NAME=Krayin CRM
      - APP_ENV=local
      - APP_KEY=$secret_key
      - APP_TIMEZONE=America/Sao_Paulo
      - APP_LOCALE=pt_BR
      - APP_CURRENCY=BRL
      
      ## ⚙️ Configurações do Frontend (Vite)
      - VITE_HOST=0.0.0.0
      - VITE_PORT=5173
      
      ## 🧾 Logs da aplicação
      - LOG_CHANNEL=stack
      - LOG_LEVEL=debug
      - APP_DEBUG=true
      
      ## 🗄️ Banco de Dados
      - DB_CONNECTION=mysql
      - DB_HOST=krayin${1:+_$1}_db
      - DB_PORT=3306
      - DB_DATABASE=krayincrm${1:+_$1}
      - DB_USERNAME=root
      - DB_PASSWORD=$senha_percona_krayin
      - DB_PREFIX=
      
      ## ⚙️ Drivers da aplicação
      - BROADCAST_DRIVER=log
      - CACHE_DRIVER=file
      - QUEUE_CONNECTION=sync
      - SESSION_DRIVER=file
      - SESSION_LIFETIME=120
      
      ## ⚡ Redis (opcional)
      - REDIS_HOST=krayin${1:+_$1}_redis
      - REDIS_PASSWORD=null
      - REDIS_PORT=6379
      
      ## ✉️ E-mail (SMTP)
      - MAIL_MAILER=smtp
      - MAIL_FROM_ADDRESS=$email_krayincrm
      - MAIL_DOMAIN=$dominio_smtp
      - MAIL_USERNAME=$usuario_email_krayincrm
      - MAIL_PASSWORD=$senha_email_krayincrm
      - MAIL_HOST=$smtp_email_krayincrm
      - MAIL_PORT=$porta_smtp_krayincrm
      - MAIL_ENCRYPTION=$smtp_secure_krayincrm
      - MAIL_FROM_NAME=Krayin CRM
      
      ## ☁️ AWS (armazenamento em nuvem - opcional)
      #- AWS_ACCESS_KEY_ID=
      #- AWS_SECRET_ACCESS_KEY=
      #- AWS_DEFAULT_REGION=eu-south
      #- AWS_BUCKET=

    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.krayin${1:+_$1}_app.rule=Host(\`$url_krayincrm\`)
        - traefik.http.services.krayin${1:+_$1}_app.loadbalancer.server.port=80
        - traefik.http.routers.krayin${1:+_$1}_app.service=krayin${1:+_$1}_app
        - traefik.http.routers.krayin${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.krayin${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.krayin${1:+_$1}_app.tls=true
        - traefik.http.middlewares.headers.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.routers.krayin.middlewares=headers

## --------------------------- ORION --------------------------- ##

  krayin${1:+_$1}_db:
    image: percona/percona-server:latest
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_general_ci
      - --sql-mode=
      - --default-authentication-plugin=mysql_native_password
      - --max-allowed-packet=512MB
      - --expire_logs_days=7
      - --max_binlog_size=100M

    volumes:
      - krayin${1:+_$1}_db:/var/lib/mysql

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
     ## 🗄️ Configurações do MySQL
      - MYSQL_ROOT_PASSWORD=$senha_percona_krayin
      - MYSQL_DATABASE=krayincrm${1:+_$1}
    
    ## 🌐 TimeZone
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  krayin${1:+_$1}_redis:
    image: redis:latest
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - krayin${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  krayin${1:+_$1}_app:
    external: true
    name: krayin${1:+_$1}_app
  krayin${1:+_$1}_db:
    external: true
    name: krayin${1:+_$1}_db
  krayin${1:+_$1}_redis:
    external: true
    name: krayin${1:+_$1}_redis


networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do krayincrm"
fi
STACK_NAME="krayincrm${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c krayincrm.yaml krayincrm > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do krayincrm"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull percona/percona-server:latest redis:latest webkul/krayin:v2.1.2-https

## Usa o serviço wait_krayincrm para verificar se o serviço esta online
wait_stack krayincrm${1:+_$1}_krayin${1:+_$1}_db krayincrm${1:+_$1}_krayin${1:+_$1}_redis krayincrm${1:+_$1}_krayin${1:+_$1}_app 

sleep 30

## Mensagem de Passo
echo ""
echo -e "\e[97m• MIGRANDO BANCO E ATIVANDO API \e[33m[4/4]\e[0m"
echo ""
sleep 1

docker exec -it $(docker ps --filter "name=krayincrm_krayin_app" -q) sh -c "cd laravel-crm && php artisan migrate" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "1/4 - [ OK ] - Migrações Executadas"
else
    echo "1/4 - [ OFF ] - Falha ao executar migrações"
fi

docker exec -it $(docker ps --filter "name=krayincrm_krayin_app" -q) sh -c "cd laravel-crm && php artisan db:seed" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "2/4 - [ OK ] - Seeds Executados"
else
    echo "2/4 - [ OFF ] - Falha ao executar Seeds"
fi

docker exec -it $(docker ps --filter "name=krayincrm_krayin_app" -q) sh -c "cd laravel-crm && composer require krayin/rest-api" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "3/4 - [ OK ] - Pacote Rest-API instalado"
else
    echo "3/4 - [ OFF ] - Falha ao instalar pacote Rest-API"
fi

docker exec -it $(docker ps --filter "name=krayincrm_krayin_app" -q) sh -c "cd laravel-crm && php artisan krayin-rest-api:install" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "4/4 - [ OK ] - Rest-API configurado"
else
    echo "4/4 - [ OFF ] - Falha ao configurar Rest-API"
fi

telemetria "Krayin CRM" "finalizado"

cd dados_vps

cat > dados_krayincrm${1:+_$1} <<EOL
[ KRAYIN CRM ]

Dominio do Krayin CRM: https://$url_krayincrm

Usuario: admin@example.com

Senha: admin123

Documentação: https://$url_krayincrm/api/documentation

----

Host Mysql: krayin${1:+_$1}_db

Porta Mysql: 3306

Usuario Mysql: root

Senha Mysql: $senha_percona_krayin

Database Mysql: krayincrm${1:+_$1}

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ KRAYIN CRM ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_krayincrm\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m admin@example.com\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m admin123\e[0m"
echo ""

echo -e "\e[33mDocumentação:\e[97m https://$url_krayincrm/api/documentation\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao

}

## ██████╗ ██╗      █████╗ ███╗   ██╗██╗  ██╗ █████╗ 
## ██╔══██╗██║     ██╔══██╗████╗  ██║██║ ██╔╝██╔══██╗
## ██████╔╝██║     ███████║██╔██╗ ██║█████╔╝ ███████║
## ██╔═══╝ ██║     ██╔══██║██║╚██╗██║██╔═██╗ ██╔══██║
## ██║     ███████╗██║  ██║██║ ╚████║██║  ██╗██║  ██║
## ╚═╝     ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝

ferramenta_planka() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_planka

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/10\e[0m"
    echo -en "\e[33mDigite o dominio para o Planka (ex: planka.oriondesign.art.br): \e[0m" && read -r url_planka
    echo ""
  
    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/10\e[0m"
    echo -en "\e[33mDigite o nome do usuario administrador (ex: Willian): \e[0m" && read -r nome_adm_planka
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/10\e[0m"
    echo -en "\e[33mDigite o email do administrador (ex: contato@oriondesign.art.br): \e[0m" && read -r email_adm_planka
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/10\e[0m"
    echo -en "\e[33mDigite o usuario do administrador (ex: admin): \e[0m" && read -r user_adm_planka
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 5/10\e[0m"
    echo -en "\e[33mDigite a senha do administrador (ex: @Senha123_): \e[0m" && read -r senha_adm_planka
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 6/10\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_planka
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 7/10\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r usuario_email_planka
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 8/10\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r senha_email_planka
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 9/10\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_email_planka
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 10/10\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r porta_smtp_planka
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_planka" -eq 465 ]; then
    smtp_secure_planka=true
    tls_reject=false
    else
    smtp_secure_planka=false
    tls_reject=true
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_planka
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do planka
    echo -e "\e[33mDominio do Planka:\e[97m $url_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mNome do usuario:\e[97m $nome_adm_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mEmail do Usuario:\e[97m $email_adm_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mUsuario do Admin:\e[97m $user_adm_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mSenha do Admin:\e[97m $senha_adm_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mEmail SMTP:\e[97m $email_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mUsuario SMTP:\e[97m $usuario_email_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mSenha SMTP:\e[97m $senha_email_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mHost SMTP:\e[97m $smtp_email_planka\e[0m"
    echo ""

    ## Informação sobre URL do planka
    echo -e "\e[33mPorta SMTP:\e[97m $porta_smtp_planka\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_planka

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PLANKA \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Planka iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "planka${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "planka${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO PLANKA \e[33m[3/4]\e[0m"
echo ""
sleep 1

secret_key=$(openssl rand -hex 16)

## Criando a stack planka.yaml
cat > planka${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  planka${1:+_$1}_app:
    image: ghcr.io/plankanban/planka:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna

    volumes:
      - planka${1:+_$1}_avatars:/app/public/user-avatars
      - planka${1:+_$1}_backgrounds:/app/public/project-background-images
      - planka${1:+_$1}_attachments:/app/private/attachments

    environment:
    ## 🔐 Dados de acesso
      - BASE_URL=https://$url_planka
      - DEFAULT_ADMIN_NAME=$nome_adm_planka
      - DEFAULT_ADMIN_USERNAME=$user_adm_planka
      - DEFAULT_ADMIN_PASSWORD=$senha_adm_planka
      - DEFAULT_ADMIN_EMAIL=$email_adm_planka

    ## 📧 Dados do SMTP
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/planka${1:+_$1}
      
    ## 🔑 Secret Keys
      - SECRET_KEY=$secret_key

    ## ⚙️ Configurações do Planaka
      - ALLOW_ALL_TO_CREATE_PROJECTS=true ## true = Permite que qualquer usuário crie projetos

    ## 📧 Dados SMTP
      - SMTP_NAME=Planka
      - SMTP_FROM=Planka <$email_planka>
      - SMTP_USER=$usuario_email_planka
      - SMTP_PASSWORD=$senha_email_planka
      - SMTP_HOST=$smtp_email_planka
      - SMTP_PORT=$porta_smtp_planka
      - SMTP_SECURE=$smtp_secure_planka
      - SMTP_TLS_REJECT_UNAUTHORIZED=$tls_reject

    ## 🔗 Configurar Webhook Global
      #- WEBHOOKS=[{
      #-   "url": "https://webhook.dominio.com",
      #-   "accessToken": "token_se_tiver",
      #-   "events": ["cardCreate", "cardUpdate", "cardDelete"],
      #-   "excludedEvents": ["notificationCreate", "notificationUpdate"]
      #- }]
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.planka${1:+_$1}.rule=Host(\`$url_planka\`)
        - traefik.http.services.planka${1:+_$1}.loadbalancer.server.port=1337
        - traefik.http.routers.planka${1:+_$1}.service=planka${1:+_$1}
        - traefik.http.routers.planka${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.planka${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.planka${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  planka${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - planka${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  planka${1:+_$1}_avatars:
    external: true
    name: planka${1:+_$1}_avatars
  planka${1:+_$1}_backgrounds:
    external: true
    name: planka${1:+_$1}_backgrounds
  planka${1:+_$1}_attachments:
    external: true
    name: planka${1:+_$1}_attachments
  planka${1:+_$1}_redis:
    external: true
    name: planka${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do planka"
fi
STACK_NAME="planka${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c planka.yaml planka > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do planka"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest ghcr.io/plankanban/planka:latest

## Usa o serviço wait_planka para verificar se o serviço esta online
wait_stack planka${1:+_$1}_planka${1:+_$1}_redis planka${1:+_$1}_planka${1:+_$1}_app

telemetria Planka finalizado

cd dados_vps

cat > dados_planka${1:+_$1} <<EOL
[ PLANKA ]

Dominio do Planka: https://$url_planka

Usuario: $user_adm_planka

Email: $email_adm_planka

Senha: $senha_adm_planka

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PLANKA ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_planka\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_adm_planka\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m $email_adm_planka\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $senha_adm_planka\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗    ██╗██████╗ ██████╗      ██████╗ ██████╗ ███╗   ██╗███╗   ██╗███████╗ ██████╗████████╗
## ██║    ██║██╔══██╗██╔══██╗    ██╔════╝██╔═══██╗████╗  ██║████╗  ██║██╔════╝██╔════╝╚══██╔══╝
## ██║ █╗ ██║██████╔╝██████╔╝    ██║     ██║   ██║██╔██╗ ██║██╔██╗ ██║█████╗  ██║        ██║   
## ██║███╗██║██╔═══╝ ██╔═══╝     ██║     ██║   ██║██║╚██╗██║██║╚██╗██║██╔══╝  ██║        ██║   
## ╚███╔███╔╝██║     ██║         ╚██████╗╚██████╔╝██║ ╚████║██║ ╚████║███████╗╚██████╗   ██║   
##  ╚══╝╚══╝ ╚═╝     ╚═╝          ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝ ╚═════╝   ╚═╝   

ferramenta_wppconnect() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_wppconnect

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio do WPPConnect (ex: wppconnect.oriondesign.art.br): \e[0m" && read -r url_wppconnect
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_wppconnect
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do wppconnect
    echo -e "\e[33mDominio do WppConnect:\e[97m $url_wppconnect_front\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_wppconnect

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WPPCONNECT \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria WPPConnect iniciado

## Nadaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO WPPCONNECT \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack wppconnect.yaml
cat > wppconnect${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  wppconnect${1:+_$1}_api:
    image: wppconnect/server-cli:latest

    volumes:
      - wppconnect${1:+_$1}_config:/usr/src/wpp-server
      
    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.wppconnect${1:+_$1}_api.rule=Host(\`$url_wppconnect\`) && PathPrefix(\`/\`) ## Url do wppconnect API
        - traefik.http.routers.wppconnect${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.wppconnect${1:+_$1}_api.priority=1
        - traefik.http.routers.wppconnect${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.routers.wppconnect${1:+_$1}_api.service=wppconnect${1:+_$1}_api
        - traefik.http.services.wppconnect${1:+_$1}_api.loadbalancer.server.port=21465
        - traefik.http.services.wppconnect${1:+_$1}_api.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  wppconnect${1:+_$1}_config:
    external: true
    name: wppconnect${1:+_$1}_config

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do wppconnect"
fi
STACK_NAME="wppconnect${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c wppconnect.yaml wppconnect > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do wppconnect"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull wppconnect/server-cli:latest

## Usa o serviço wait_wppconnect para verificar se o serviço esta online
wait_stack wppconnect${1:+_$1}_wppconnect${1:+_$1}_api

telemetria WPPConnect finalizado

cd dados_vps

cat > dados_wppconnect${1:+_$1} <<EOL
[ WPPCONNECT ]

Dominio Front: https://$url_wppconnect

Documentação: https://$url_wppconnect/api-docs
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WPPCONNECT ]\e[0m"
echo ""

echo -e "\e[33mDominio API:\e[97m https://$url_wppconnect\e[0m"
echo ""

echo -e "\e[33mDocumentação: \e[97m https://$url_wppconnect/api-docs\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗ ██████╗  ██████╗ ██╗    ██╗███████╗███████╗██████╗ ██╗     ███████╗███████╗███████╗
## ██╔══██╗██╔══██╗██╔═══██╗██║    ██║██╔════╝██╔════╝██╔══██╗██║     ██╔════╝██╔════╝██╔════╝
## ██████╔╝██████╔╝██║   ██║██║ █╗ ██║███████╗█████╗  ██████╔╝██║     █████╗  ███████╗███████╗
## ██╔══██╗██╔══██╗██║   ██║██║███╗██║╚════██║██╔══╝  ██╔══██╗██║     ██╔══╝  ╚════██║╚════██║
## ██████╔╝██║  ██║╚██████╔╝╚███╔███╔╝███████║███████╗██║  ██║███████╗███████╗███████║███████║
## ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚══════╝

ferramenta_browserless() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_browserless

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Browserless (ex: browserless.oriondesign.art.br): \e[0m" && read -r url_browserless
    echo ""
  
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_browserless
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do browserless
    echo -e "\e[33mDominio do Browserless:\e[97m $url_browserless\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_browserless

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO BROWSERLESS \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Browserless iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO BROWSERLESS \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack browserless.yaml
cat > browserless${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  browserless${1:+_$1}:
    image: browserless/chrome:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações de Performance
      - MAX_CONCURRENT_SESSIONS=20
      - MAX_QUEUE_LENGTH=40
      - CONNECTION_TIMEOUT=60000

    ## 🗂️ Configurações de Workspaces
      - WORKSPACE_DELETE_EXPIRED=1
      - WORKSPACE_EXPIRE_DAYS=1
      - PREBOOT_CHROME=1
      - KEEP_ALIVE=1

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.browserless${1:+_$1}.rule=Host(\`$url_browserless\`)
        - traefik.http.services.browserless${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.browserless${1:+_$1}.service=browserless${1:+_$1}
        - traefik.http.routers.browserless${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.browserless${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.browserless${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do browserless"
fi
STACK_NAME="browserless${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c browserless.yaml browserless > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do browserless"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull browserless/chrome:latest

## Usa o serviço wait_browserless para verificar se o serviço esta online
wait_stack browserless${1:+_$1}_browserless${1:+_$1}

telemetria Browserless finalizado

cd dados_vps

cat > dados_browserless${1:+_$1} <<EOL
[ BROWSERLESS ]

Dominio do browserless: https://$url_browserless

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ BROWSERLESS ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_browserless\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗██████╗ ██████╗ ███╗   ██╗███████╗██╗  ██╗████████╗
## █╔════╝██╔══██╗██╔══██╗████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝
## ████╗  ██████╔╝██████╔╝██╔██╗ ██║█████╗   ╚███╔╝    ██║   
## █╔══╝  ██╔══██╗██╔═══╝ ██║╚██╗██║██╔══╝   ██╔██╗    ██║   
## ██████╗██║  ██║██║     ██║ ╚████║███████╗██╔╝ ██╗   ██║   
## ══════╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝   

ferramenta_frappe() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_frappe

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o Frappe ERPNext (ex: crm.oriondesign.art.br): \e[0m" && read -r url_frappe
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite a Senha do usuario Administrador (ex: @Senha123_): \e[0m" && read -r senha_frappe
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_frappe
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do frappe
    echo -e "\e[33mDominio do Frappe ERPNext:\e[97m $url_frappe\e[0m"
    echo ""

    ## Informação sobre URL do frappe
    echo -e "\e[33mSenha do Administrador:\e[97m $senha_frappe\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_frappe

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO FRAPPE ERPNEXT \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria FRAPPE iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO ERPNEXT \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Criando key Aleatória
DB_PASSWORD=$(openssl rand -hex 16)

## Criando a stack frappe.yaml
cat > erpnext${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_frontend:
    image: frappe/erpnext:v15.49.3
    command: ["nginx-entrypoint.sh"]

    volumes:
      - erpnext${1:+_$1}_sites:/home/frappe/frappe-bench/sites
      - erpnext${1:+_$1}_logs:/home/frappe/frappe-bench/logs

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Configurações de Conexão
      - BACKEND=erpnext${1:+_$1}_backend:8000
      - SOCKETIO=erpnext${1:+_$1}_websocket:9000

    ## 🏷️ Configurações do Site
      - FRAPPE_SITE_NAME_HEADER=$url_frappe
      - FRAPPE_SITE=$url_frappe

    ## 🧩 Configurações de Proxy
      - UPSTREAM_REAL_IP_ADDRESS=127.0.0.1
      - UPSTREAM_REAL_IP_HEADER=X-Forwarded-For
      - UPSTREAM_REAL_IP_RECURSIVE=off
      - PROXY_READ_TIMEOUT=120
      - CLIENT_MAX_BODY_SIZE=50m
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.erpnext${1:+_$1}_frontend.rule=Host(\`$url_frappe\`)
        - traefik.http.services.erpnext${1:+_$1}_frontend.loadbalancer.server.port=8080
        - traefik.http.routers.erpnext${1:+_$1}_frontend.service=erpnext${1:+_$1}_frontend
        - traefik.http.routers.erpnext${1:+_$1}_frontend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.erpnext${1:+_$1}_frontend.entrypoints=websecure
        - traefik.http.routers.erpnext${1:+_$1}_frontend.tls=true

## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_backend:
    image: frappe/erpnext:v15.49.3

    volumes:
      - erpnext${1:+_$1}_sites:/home/frappe/frappe-bench/sites
      - erpnext${1:+_$1}_logs:/home/frappe/frappe-bench/logs

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Dados do MySQL
      - DB_HOST=erpnext${1:+_$1}_db
      - DB_PORT=3306
      - DB_USER=frappe
      - DB_PASSWORD=$DB_PASSWORD
      - MYSQL_ROOT_PASSWORD=$DB_PASSWORD
      - MARIADB_ROOT_PASSWORD=$DB_PASSWORD
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_configurator:
    image: frappe/erpnext:v15.49.3

    volumes:
      - erpnext${1:+_$1}_sites:/home/frappe/frappe-bench/sites
      - erpnext${1:+_$1}_logs:/home/frappe/frappe-bench/logs

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Dados do MySQL
      - DB_HOST=erpnext${1:+_$1}_db
      - DB_PORT=3306

    ## 🔥 Dados do Redis
      - REDIS_CACHE=erpnext${1:+_$1}_cache:6379
      - REDIS_QUEUE=erpnext${1:+_$1}_queue:6379
      - REDIS_SOCKETIO=erpnext${1:+_$1}_socketio:6379

    ## 📡 Dados Websocket
      - SOCKETIO_PORT=9000

    ## 🌐 Host
      - HOST_URL=$url_frappe
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M

## --------------------------- ORION --------------------------- ##
      
  erpnext${1:+_$1}_websocket:
    image: frappe/erpnext:v15.49.3
    command: ["node", "/home/frappe/frappe-bench/apps/frappe/socketio.js"]

    volumes:
      - erpnext${1:+_$1}_sites:/home/frappe/frappe-bench/sites
      - erpnext${1:+_$1}_logs:/home/frappe/frappe-bench/logs

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
            
## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_db:
    image: mariadb:10.6
    command: ["--character-set-server=utf8mb4", "--collation-server=utf8mb4_unicode_ci", "--skip-character-set-client-handshake", "--skip-innodb-read-only-compressed"]

    volumes:
      - erpnext${1:+_$1}_db:/var/lib/mysql

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Dados do MySQL
      - MYSQL_ROOT_PASSWORD=$DB_PASSWORD
      - MARIADB_ROOT_PASSWORD=$DB_PASSWORD
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_cache:
    image: redis:latest
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - erpnext${1:+_$1}_cache:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_queue:
    image: redis:latest
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - erpnext${1:+_$1}_queue:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  erpnext${1:+_$1}_socketio:
    image: redis:latest
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - erpnext${1:+_$1}_socketio:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  erpnext${1:+_$1}_sites:
    external: true
    name: erpnext${1:+_$1}_sites
  erpnext${1:+_$1}_logs:
    external: true
    name: erpnext${1:+_$1}_logs
  erpnext${1:+_$1}_db:
    external: true
    name: erpnext${1:+_$1}_db
  erpnext${1:+_$1}_cache:
    external: true
    name: erpnext${1:+_$1}_cache
  erpnext${1:+_$1}_queue:
    external: true
    name: erpnext${1:+_$1}_queue
  erpnext${1:+_$1}_socketio:
    external: true
    name: erpnext${1:+_$1}_socketio

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do frappe"
fi
STACK_NAME="erpnext${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c frappe.yaml frappe > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do frappe"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull frappe/erpnext:v15.49.3 mariadb:10.6 redis:latest

sleep 45

echo "{
  \"db_host\": \"erpnext${1:+_$1}_db\",
  \"db_port\": \"3306\",
  \"redis_cache\": \"redis://erpnext${1:+_$1}_cache:6379\",
  \"redis_queue\": \"redis://erpnext${1:+_$1}_queue:6379\",
  \"redis_socketio\": \"redis://erpnext${1:+_$1}_socketio:6379\",
  \"auto_update\": false,
  \"disable_website_cache\": true,
  \"domains\": [\"$url_frappe\"]
}" > /var/lib/docker/volumes/erpnext${1:+_$1}_sites/_data/common_site_config.json

## Usa o serviço wait_frappe para verificar se o serviço esta online
wait_stack erpnext${1:+_$1}_erpnext${1:+_$1}_frontend erpnext${1:+_$1}_erpnext${1:+_$1}_backend erpnext${1:+_$1}_erpnext${1:+_$1}_configurator erpnext${1:+_$1}_erpnext${1:+_$1}_websocket erpnext${1:+_$1}_erpnext${1:+_$1}_db erpnext${1:+_$1}_erpnext${1:+_$1}_cache erpnext${1:+_$1}_erpnext${1:+_$1}_queue erpnext${1:+_$1}_erpnext${1:+_$1}_socketio

sleep 30

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO APLICATIVO \e[33m[4/4]\e[0m"
echo ""
sleep 1

docker exec -it $(docker ps -qf "name=erpnext${1:+_$1}_backend") bash -c "bench new-site \"$url_frappe\" --mariadb-root-password=\"$DB_PASSWORD\" --admin-password=\"$senha_frappe\" --install-app erpnext"

telemetria ERPNext finalizado

cd dados_vps

cat > dados_erpnext${1:+_$1} <<EOL
[ ERPNEXT ]

Dominio do ERPNext: https://$url_frappe

Usuario: administrator

Senha: $senha_frappe
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ERPNEXT ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_frappe\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m administrator\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $senha_frappe\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗ ██╗  ████████╗
## ██╔══██╗██╔═══██╗██║  ╚══██╔══╝
## ██████╔╝██║   ██║██║     ██║   
## ██╔══██╗██║   ██║██║     ██║   
## ██████╔╝╚██████╔╝███████╗██║   
## ╚═════╝  ╚═════╝ ╚══════╝╚═╝   

ferramenta_bolt() {

## Verifica os recursos
recursos 2 4 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_bolt

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Bolt (ex: bolt.oriondesign.art.br): \e[0m" && read -r url_bolt
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_bolt
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do bolt
    echo -e "\e[33mDominio do Bolt:\e[97m $url_bolt\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_bolt

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO BOLT \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Bolt iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO BOLT \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack bolt.yaml
cat > bolt${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  bolt${1:+_$1}_app:
    image: ghcr.io/stackblitz-labs/bolt.diy:latest
    command: pnpm run dockerstart

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações da Aplicação
      - NODE_ENV=production
      - COMPOSE_PROFILES=production
      - PORT=5173
      - VITE_LOG_LEVEL=debug
      - VITE_HMR_HOST=$url_bolt
      - DEFAULT_NUM_CTX=32768
      - RUNNING_IN_DOCKER=true

    ## 🔐 Chaves de APIs (IA)
      #- OPENAI_API_KEY=
      #- OPEN_ROUTER_API_KEY=
      #- GROQ_API_KEY=
      #- HuggingFace_API_KEY=
      #- ANTHROPIC_API_KEY=
      #- GOOGLE_GENERATIVE_AI_API_KEY=
      #- XAI_API_KEY=
      #- TOGETHER_API_KEY=

    ## 🌐 Configurações de Serviços Externos
      #- OLLAMA_API_BASE_URL=
      #- TOGETHER_API_BASE_URL=
      #- AWS_BEDROCK_CONFIG=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 4096M
      labels:
        - traefik.enable=true
        - traefik.http.routers.bolt${1:+_$1}_app.rule=Host(\`$url_bolt\`)
        - traefik.http.services.bolt${1:+_$1}_app.loadbalancer.server.port=5173
        - traefik.http.routers.bolt${1:+_$1}_app.service=bolt${1:+_$1}_app
        - traefik.http.routers.bolt${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.bolt${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.bolt${1:+_$1}_app.tls=true

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna

EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do bolt"
fi
STACK_NAME="bolt${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c bolt.yaml bolt > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do bolt"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/stackblitz-labs/bolt.diy:latest

## Usa o serviço wait_bolt para verificar se o serviço esta online
wait_stack bolt${1:+_$1}_bolt${1:+_$1}_app

telemetria Bolt finalizado

cd dados_vps

cat > dados_bolt${1:+_$1} <<EOL
[ BOLT ]

Dominio do bolt: https://$url_bolt
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ BOLT ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_bolt\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗    ██╗██╗███████╗███████╗███╗   ███╗ █████╗ ██████╗ ██████╗ ██╗███╗   ██╗ ██████╗ 
## ██║    ██║██║██╔════╝██╔════╝████╗ ████║██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║██╔════╝ 
## ██║ █╗ ██║██║███████╗█████╗  ██╔████╔██║███████║██████╔╝██████╔╝██║██╔██╗ ██║██║  ███╗
## ██║███╗██║██║╚════██║██╔══╝  ██║╚██╔╝██║██╔══██║██╔═══╝ ██╔═══╝ ██║██║╚██╗██║██║   ██║
## ╚███╔███╔╝██║███████║███████╗██║ ╚═╝ ██║██║  ██║██║     ██║     ██║██║ ╚████║╚██████╔╝
##  ╚══╝╚══╝ ╚═╝╚══════╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝ 

ferramenta_wisemapping() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_wisemapping

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o WiseMapping (ex: wisemapping.oriondesign.art.br): \e[0m" && read -r url_wisemapping
    echo ""

    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_wisemapping
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do wisemapping
    echo -e "\e[33mDominio do WiseMapping:\e[97m $url_wisemapping\e[0m"
    echo ""


    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_wisemapping

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WISEMAPPING \e[33m[1/5]\e[0m"
echo ""
sleep 1

telemetria WiseMapping iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/5]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "wisemapping${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "wisemapping${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• CRIANDO ARQUIVOS DO WISEMAPPING \e[33m[3/5]\e[0m"
echo ""
sleep 1

sudo mkdir -p /root/wisemapping${1:+_$1}
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Criando diretório Wisemapping${1:+_$1}"
else
    echo "1/3 - [ OFF ] - Criando diretório Wisemapping${1:+_$1}"
    echo "Não foi criar o diretório"
fi

cd

cd wisemapping${1:+_$1}

jwt_secret=$(openssl rand -hex 32)

cat > app.yml <<EOL
spring:
  main:
    allow-circular-references: true
  datasource:
    url: jdbc:postgresql://postgres:5432/wisemapping${1:+_$1}?stringtype=unspecified
    username: postgres
    password: $senha_postgres
    driver-class-name: org.postgresql.Driver
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      pool-name: HikariPool-WiseMapping
      minimum-idle: 5
      maximum-pool-size: 20
      idle-timeout: 300000
      max-lifetime: 1800000
      connection-timeout: 30000
      auto-commit: false
      transaction-isolation: TRANSACTION_READ_COMMITTED
      leak-detection-threshold: 60000
      data-source-properties:
        prepareThreshold: 0
        # PostgreSQL uses prepared statements by default, prepareThreshold=0 
        # means always use prepared statements (cached automatically)
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        default_batch_fetch_size: 200
        format_sql: false
        # Fix for @Lob byte[] mapping to BYTEA in PostgreSQL
        jdbc:
          lob:
            non_contextual_creation: true
          use_streams_for_binary: true
        # Enable second-level cache (L2) for entity caching across sessions
        cache:
          use_second_level_cache: true
          use_query_cache: true
          region:
            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
        # Configure JCache provider (EHCache)
        jakarta:
          cache:
            provider: org.ehcache.jsr107.EhcacheCachingProvider
            uri: classpath:ehcache.xml
  sql:
    init:
      platform: postgresql
      mode: always
      schema-locations: classpath:schema-postgresql.sql
      data-locations: classpath:data-postgresql.sql
      continue-on-error: false
  mail:
    host: localhost
    port: 25
    test-connection: false

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
      probes:
        enabled: true
  metrics:
    tags:
      application: wisemapping-api
      environment: production
    export:
      prometheus:
        enabled: true
        step: 60s

# Application configuration
app:
  site:
    ui-base-url: https://$url_wisemapping
    api-base-url: https://$url_wisemapping
  admin:
    user: admin@wisemapping.org
  jwt:
    secret: $jwt_secret
    expirationMin: 10080
  mail:
    enabled: false
    sender-email: noreply@wisemapping.org
    support-email: support@wisemapping.org

# Server configuration
server:
  tomcat:
    remoteip:
      remote-ip-header: x-forwarded-for
      protocol-header: x-forwarded-proto
      port-header: x-forwarded-port

# Logging configuration
logging:
  level:
    root: INFO
    com.wisemapping: \${LOG_LEVEL_WISEMAPPING:-INFO}
    org.springframework: WARN
    org.hibernate: WARN
EOL
if [ $? -eq 0 ]; then
    echo "2/3 - [ OK ] - Criando arquivo application.yml"
else
    echo "2/3 - [ OFF ] - Criando arquivo application.yml"
    echo "Não foi criar o arquivo application.yml"
fi

cat > nginx.conf <<EOL
# Detect HTTPS from Traefik's X-Forwarded-Proto header
# When behind Traefik, the connection to Nginx is HTTP, but the original request was HTTPS
map \$http_x_forwarded_proto \$forwarded_scheme {
  default \$scheme;
  https https;
}

# Use forwarded scheme if available, otherwise use default scheme
map \$forwarded_scheme \$final_scheme {
  default \$forwarded_scheme;
  "" \$scheme;
}

server {
  listen 80;
  gzip on;
  charset UTF-8;
  server_name _;
  
  # Replace <base> tag with absolute URL at runtime
  # Use \$final_scheme to correctly detect HTTPS when behind Traefik
  sub_filter '<base>' '<base href="\$final_scheme://\$http_host/">';
  sub_filter_once on;

  # Frontend routes
  location / {
    root /usr/share/nginx/html;
    try_files \$uri /index.html;
    
    # Add security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
  }

  location /c/ {
    try_files \$uri /usr/share/nginx/html/index.html;
    
    # Add security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
  }

  # Backend API proxy - intercept config endpoint to rewrite URLs with actual port
  location /api/restful/app/config {
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$final_scheme;
    proxy_set_header X-Forwarded-Host \$http_host;
    proxy_set_header X-NginX-Proxy true;
    proxy_pass http://localhost:8080/api/restful/app/config;
    proxy_ssl_session_reuse off;
    proxy_set_header Host \$http_host;
    proxy_cache_bypass \$http_upgrade;
    proxy_redirect off;
    
    # Rewrite apiBaseUrl and uiBaseUrl in JSON response to use correct scheme
    sub_filter '"apiBaseUrl":"http://localhost:8080"' '"apiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"apiBaseUrl":"http://localhost:3000"' '"apiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"apiBaseUrl":"https://localhost:8080"' '"apiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"apiBaseUrl":"https://localhost:3000"' '"apiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"uiBaseUrl":"http://localhost:3000"' '"uiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"uiBaseUrl":"http://localhost:8080"' '"uiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"uiBaseUrl":"https://localhost:3000"' '"uiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter '"uiBaseUrl":"https://localhost:8080"' '"uiBaseUrl":"\$final_scheme://\$http_host"';
    sub_filter_once off;  # Replace all occurrences
    sub_filter_types application/json;
  }

  # Backend API proxy - all other API endpoints
  location /api/ {
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$final_scheme;
    proxy_set_header X-Forwarded-Host \$http_host;
    proxy_set_header X-NginX-Proxy true;
    proxy_pass http://localhost:8080/api/;
    proxy_ssl_session_reuse off;
    proxy_set_header Host \$http_host;
    proxy_cache_bypass \$http_upgrade;
    proxy_redirect off;
    
    # Increase timeouts for long-running requests
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
  }

  # Health check endpoint
  location /health {
    access_log off;
    return 200 "healthy\n";
    add_header Content-Type text/plain;
  }
}
EOL
if [ $? -eq 0 ]; then
    echo "3/3 - [ OK ] - Criando arquivo nginx.conf"
else
    echo "3/3 - [ OFF ] - Criando arquivo nginx.conf"
    echo "Não foi criar o arquivo nginx.conf"
fi
echo ""

cd

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO WISEMAPPING \e[33m[4/5]\e[0m"
echo ""
sleep 1

## Criando a stack wisemapping.yaml
cat > wisemapping${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  wisemapping${1:+_$1}:
    image: wisemapping/wisemapping:latest

    volumes:
      - wisemapping${1:+_$1}_db:/var/lib/wisemapping/db
      - /root/wisemapping${1:+_$1}/app.yml:/app/config/application.yml:z,ro
      - /root/wisemapping${1:+_$1}/nginx.conf:/etc/nginx/http.d/default.conf:z,ro

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🚀 Configurações de Performance (Java)
      - JAVA_OPTS=Xmx2048m -Xms1024m -XX:+UseG1GC -XX:MaxGCPauseMillis=200
    
    ## ⚙️ Configurações da Aplicação
      - SPRING_PROFILES_ACTIVE=production
      - TZ=America/Sao_Paulo
      - SPRING_CONFIG_ADDITIONAL_LOCATION=optional:file:/app/config/
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.wisemapping${1:+_$1}.rule=Host(\`$url_wisemapping\`)
        - traefik.http.services.wisemapping${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.wisemapping${1:+_$1}.service=wisemapping${1:+_$1}
        - traefik.http.routers.wisemapping${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.wisemapping${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.wisemapping${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  wisemapping${1:+_$1}_db:
    external: true
    name: wisemapping${1:+_$1}_db
    
networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do wisemapping"
fi
STACK_NAME="wisemapping${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c wisemapping.yaml wisemapping > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do wisemapping"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull wisemapping/wisemapping:latest

## Usa o serviço wait_wisemapping para verificar se o serviço esta online
wait_stack wisemapping${1:+_$1}_wisemapping${1:+_$1}

sleep 30

telemetria WiseMapping finalizado

cd dados_vps

cat > dados_wisemapping${1:+_$1} <<EOL
[ WISEMAPPING ]

Dominio do WiseMapping: https://$url_wisemapping

Email do usuario Admin: admin@wisemapping.org

Senha do usuario Admin: testAdmin123
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WISEMAPPING ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_wisemapping\e[0m"
echo ""

echo -e "\e[33mEmail do usuario Admin:\e[97m admin@wisemapping.org\e[0m"
echo ""

echo -e "\e[33mSenha do usuario Admin:\e[97m testAdmin123\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗   ██╗ ██████╗      █████╗ ██╗
## ██╔════╝██║   ██║██╔═══██╗    ██╔══██╗██║
## █████╗  ██║   ██║██║   ██║    ███████║██║
## ██╔══╝  ╚██╗ ██╔╝██║   ██║    ██╔══██║██║
## ███████╗ ╚████╔╝ ╚██████╔╝    ██║  ██║██║
## ╚══════╝  ╚═══╝   ╚═════╝     ╚═╝  ╚═╝╚═╝
##                                          
                                         
ferramenta_evoai() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_evoai

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/9\e[0m"
    echo -en "\e[33mDigite o Dominio para o painel da EvoAI (ex: evoai.oriondesign.art.br): \e[0m" && read -r url_evoai_front
    echo ""

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 2/9\e[0m"
    echo -en "\e[33mDigite o Dominio para a API da EvoAI (ex: evoapi.oriondesign.art.br): \e[0m" && read -r url_evoai_api
    echo ""

    ##Pergunta o Usuario para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/9\e[0m"
    echo -en "\e[33mDigite um email para o usuario admin (ex: contato@oriondesign.art.br): \e[0m" && read -r email_evoai
    echo ""
    
    ##Pergunta a Senha para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/9\e[0m"
    echo -e "$amarelo--> Minimo 8 caracteres. Use Letras MAIUSCULAS e minusculas, numero e um caractere especial @ ou _"
    echo -e "$amarelo--> Evite os caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma senha para o usuario (ex: @Senha123_): \e[0m" && read -r pass_evoai
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 5/9\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r smtp_email_evoai
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 6/9\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r smtp_user_evoai
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 7/9\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r smtp_pass_evoai
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 8/9\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_host_evoai
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 9/9\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r smtp_port_evoai
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$smtp_port_evoai" -eq 465 ]; then
    SMTP_USE_TLS=false
    SMTP_USE_SSL=true
    else
    SMTP_USE_TLS=true
    SMTP_USE_SSL=false
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_evoai
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do painel:\e[97m $url_evoai_front\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mDominio da api:\e[97m $url_evoai_api\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mEmail do usuario:\e[97m $email_evoai\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do usuario:\e[97m $pass_evoai\e[0m"
    echo ""

    ## Informação sobre Email SMTP
    echo -e "\e[33mEmail SMTP:\e[97m $smtp_email_evoai\e[0m"
    echo ""

    ## Informação sobre Email SMTP
    echo -e "\e[33mUser SMTP:\e[97m $smtp_user_evoai\e[0m"
    echo ""    
    
    ## Informação sobre Senha SMTP
    echo -e "\e[33mSenha SMTP:\e[97m $smtp_pass_evoai\e[0m"
    echo ""
    
    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP:\e[97m $smtp_host_evoai\e[0m"
    echo ""
    
    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP:\e[97m $smtp_port_evoai\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_evoai

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DA EVO AI \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria EvoAI iniciado

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "evoai${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "evoai${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A EVO AI \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação da Evolution API

## Criando uma Global Key Aleatória
EVO_AI_ENCRYPTION_KEY=$(python3 -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
EVO_AI_JWT_SECRET_KEY=$(openssl rand -base64 32)

## Criando a stack evoai.yaml
cat > evoai${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  evoai${1:+_$1}_api:
    image: evoapicloud/evo-ai:latest ## Versão da imagem

    volumes:
      - evoai${1:+_$1}_logs:/app/logs
      - evoai${1:+_$1}_static:/app/static
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔗 Informações da API
      - API_URL=https://$url_evoai_api

    ## 🔗 Informações do Front
      - APP_URL=https://$url_evoai_front
      
    ## 🧪 Dados do Admin
      - ADMIN_EMAIL=$email_evoai
      - ADMIN_INITIAL_PASSWORD=$pass_evoai

    ## 📧 Configuração de SMTP
      - EMAIL_PROVIDER=smtp
      - SMTP_FROM=$smtp_email_evoai
      - SMTP_USER=$smtp_user_evoai
      - SMTP_PASSWORD=$smtp_pass_evoai
      - SMTP_HOST=$smtp_host_evoai
      - SMTP_PORT=$smtp_port_evoai
      - SMTP_USE_TLS=$SMTP_USE_TLS
      - SMTP_USE_SSL=$SMTP_USE_SSL

    ## 🛢️ Configuração do Postgres
      - POSTGRES_CONNECTION_STRING=postgresql://postgres:$senha_postgres@postgres:5432/evoai${1:+_$1}

    ## ⚡ Configuração do Redis
      - REDIS_HOST=evoai${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_DB=9
      - REDIS_KEY_PREFIX=a2a${1:+_$1}
      - REDIS_SSL=false
      - REDIS_TTL=3600
      - TOOLS_CACHE_TTL=3600

    ## 🔐 Encriptação e JWT
      - ENCRYPTION_KEY=$EVO_AI_ENCRYPTION_KEY
      - JWT_SECRET_KEY=$EVO_AI_JWT_SECRET_KEY
      - JWT_ALGORITHM=HS256
      - JWT_EXPIRATION_TIME=3600

    ## 🧾 Logs
      - LOG_LEVEL=INFO
      - LOG_DIR=logs
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.evoai${1:+_$1}_api.rule=Host(\`$url_evoai_api\`) ## Url da Evolution API
        - traefik.http.routers.evoai${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.evoai${1:+_$1}_api.priority=1
        - traefik.http.routers.evoai${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evoai${1:+_$1}_api.service=evoai${1:+_$1}_api
        - traefik.http.services.evoai${1:+_$1}_api.loadbalancer.server.port=8000
        - traefik.http.services.evoai${1:+_$1}_api.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  evoai${1:+_$1}_frontend:
    image: evoapicloud/evo-ai-frontend:latest ## Versão da imagem
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      - NEXT_PUBLIC_API_URL=https://$url_evoai_api
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.evoai${1:+_$1}_frontend.rule=Host(\`$url_evoai_front\`) ## Url da Evolution API
        - traefik.http.routers.evoai${1:+_$1}_frontend.entrypoints=websecure
        - traefik.http.routers.evoai${1:+_$1}_frontend.priority=1
        - traefik.http.routers.evoai${1:+_$1}_frontend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evoai${1:+_$1}_frontend.service=evoai${1:+_$1}_frontend
        - traefik.http.services.evoai${1:+_$1}_frontend.loadbalancer.server.port=3000
        - traefik.http.services.evoai${1:+_$1}_frontend.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  evoai${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - evoai${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  evoai${1:+_$1}_logs:
    external: true
    name: evoai${1:+_$1}_logs
  evoai${1:+_$1}_static:
    external: true
    name: evoai${1:+_$1}_static
  evoai${1:+_$1}_redis:
    external: true
    name: evoai${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna

EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Evolution API"
fi
STACK_NAME="evoai${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c evoai.yaml evoai > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Evolution API"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest evoapicloud/evo-ai:latest evoapicloud/evo-ai-frontend:latest

## Usa o serviço wait_evoai para verificar se o serviço esta online
wait_stack evoai${1:+_$1}_evoai${1:+_$1}_redis evoai${1:+_$1}_evoai${1:+_$1}_api evoai${1:+_$1}_evoai${1:+_$1}_frontend

telemetria EvoAI finalizado

cd dados_vps

cat > dados_evoai${1:+_$1} <<EOL
[ EVO AI ]

Painel: https://$url_evoai_front

API: https://$url_evoai_api

Email Admin: $email_evoai

Senha Admin: $pass_evoai
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ EVO AI ]\e[0m"
echo ""

echo -e "\e[97mLink do Painel:\e[33m https://$url_evoai_front\e[0m"
echo ""

echo -e "\e[97mAPI URL:\e[33m https://$url_evoai_api\e[0m"
echo ""

echo -e "\e[97mEmail Admin:\e[33m $email_evoai\e[0m"
echo ""

echo -e "\e[97mSenha Admin:\e[33m $pass_evoai\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗  ██╗███████╗██╗   ██╗ ██████╗██╗      ██████╗  █████╗ ██╗  ██╗
## ██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔════╝██║     ██╔═══██╗██╔══██╗██║ ██╔╝
## █████╔╝ █████╗   ╚████╔╝ ██║     ██║     ██║   ██║███████║█████╔╝ 
## ██╔═██╗ ██╔══╝    ╚██╔╝  ██║     ██║     ██║   ██║██╔══██║██╔═██╗ 
## ██║  ██╗███████╗   ██║   ╚██████╗███████╗╚██████╔╝██║  ██║██║  ██╗
## ╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝

ferramenta_keycloak() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_keycloak

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o Keycloak (ex: keycloak.oriondesign.art.br): \e[0m" && read -r url_keycloak
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite um usuario para o Keycloak (ex: admin): \e[0m" && read -r user_keycloak
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite uma senha para o usuario (ex: @Senha123_): \e[0m" && read -r senha_keycloak
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_keycloak
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do keycloak
    echo -e "\e[33mDominio do Keycloak:\e[97m $url_keycloak\e[0m"
    echo ""

    ## Informação sobre URL do keycloak
    echo -e "\e[33mUsuario:\e[97m $user_keycloak\e[0m"
    echo ""

    ## Informação sobre URL do keycloak
    echo -e "\e[33mSenha:\e[97m $senha_keycloak\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_keycloak

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO KEYCLOAK \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Keycloak iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "keycloak${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "keycloak${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO keycloak \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack keycloak.yaml
cat > keycloak${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- KEYCLOAK --------------------------- ##

  keycloak${1:+_$1}:

    image: quay.io/keycloak/keycloak:latest
    command: start
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 👤 Dados de acesso
      - KEYCLOAK_ADMIN=$user_keycloak
      - KEYCLOAK_ADMIN_PASSWORD=$senha_keycloak

    ## 🌐 Configurações Gerais
      - TZ=America/Sao_Paulo

    ## 🔗 Configurações de Rede e Proxy
      ## $url_keycloak deve ser apenas o hostname (ex: keycloak.exemplo.com)
      ## O scheme (https) e porta serão resolvidos dinamicamente dos headers X-Forwarded-*
      - KC_HOSTNAME=$url_keycloak
      - KC_HOSTNAME_STRICT=false
      - KC_HOSTNAME_STRICT_HTTPS=false
      - KC_HOSTNAME_STRICT_BACKCHANNEL=false
      - KC_HTTP_ENABLED=true
      ## KC_PROXY=edge está deprecated na v2, removido para evitar warnings
      ## KC_PROXY_HEADERS é obrigatório quando usando proxy reverso
      - KC_PROXY_HEADERS=xforwarded
      - KC_HTTP_RELATIVE_PATH=/
      
    ## 🐘 Banco de Dados PostgreSQL (VARIÁVEIS)
      - KC_DB=postgres
      - KC_DB_URL=jdbc:postgresql://postgres:5432/keycloak${1:+_$1}
      - KC_DB_USERNAME=postgres
      - KC_DB_PASSWORD=$senha_postgres
      
    ## 🔄 Health & Metrics (fixos)
      - KC_HEALTH_ENABLED=true
      - KC_METRICS_ENABLED=true
      
    ## ⚙️ Performance (fixos)
      - JAVA_OPTS_APPEND=-Dkeycloak.profile.feature.upload_scripts=enabled
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 2048M
      labels:
        - traefik.enable=true
        
        ## Router principal
        - traefik.http.routers.keycloak${1:+_$1}.rule=Host(\`$url_keycloak\`)
        - traefik.http.routers.keycloak${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.keycloak${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.keycloak${1:+_$1}.tls=true
        - traefik.http.routers.keycloak${1:+_$1}.service=keycloak${1:+_$1}
        - traefik.http.services.keycloak${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.middlewares.keycloak${1:+_$1}-headers.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.middlewares.keycloak${1:+_$1}-headers.headers.customrequestheaders.X-Forwarded-For=
        - traefik.http.middlewares.keycloak${1:+_$1}-headers.headers.customrequestheaders.X-Real-IP=
        - traefik.http.middlewares.keycloak${1:+_$1}-headers.headers.customrequestheaders.X-Forwarded-Host=$url_keycloak
        - traefik.http.middlewares.keycloak${1:+_$1}-headers.headers.customrequestheaders.X-Forwarded-Port=443
        - traefik.http.routers.keycloak${1:+_$1}.middlewares=keycloak${1:+_$1}-headers

## --------------------------- NETWORKS --------------------------- ##

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna


EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do keycloak"
fi
STACK_NAME="keycloak${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c keycloak.yaml keycloak > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do keycloak"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull quay.io/keycloak/keycloak:latest

## Usa o serviço wait_keycloak para verificar se o serviço esta online
wait_stack keycloak${1:+_$1}_keycloak${1:+_$1}

telemetria Keycloak finalizado

cd dados_vps

cat > dados_keycloak${1:+_$1} <<EOL
[ KEYCLOAK ]

Dominio do Keycloak: https://$url_keycloak/auth

Usuario: $user_keycloak

Senha: $senha_keycloak

EOL

cd
cd

## Espera 30 segundos
wait_30_sec
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ KEYCLOAK ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_keycloak\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_keycloak\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $senha_keycloak\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  █████╗ ███████╗███████╗██████╗  ██████╗ ██╗  ████████╗
## ██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗██╔═══██╗██║  ╚══██╔══╝
## ██████╔╝███████║███████╗███████╗██████╔╝██║   ██║██║     ██║   
## ██╔═══╝ ██╔══██║╚════██║╚════██║██╔══██╗██║   ██║██║     ██║   
## ██║     ██║  ██║███████║███████║██████╔╝╚██████╔╝███████╗██║   
## ╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝  ╚═════╝ ╚══════╝╚═╝   

ferramenta_passbolt() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_passbolt

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para aplicação
    echo -e "\e[97mPasso$amarelo 1/6\e[0m"
    echo -en "\e[33mDigite o Dominio para o Passbolt (ex: passbolt.oriondesign.art.br): \e[0m" && read -r url_passbolt
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email do usuario Admin do Passbolt (ex: contato@oriondesign.art.br): \e[0m" && read -r email_user_passbolt
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 2/6\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r smtp_email_passbolt
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 3/6\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r smtp_user_passbolt
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 4/6\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r smtp_pass_passbolt
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 5/6\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r smtp_host_passbolt
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 6/6\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r smtp_port_passbolt
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$smtp_port_passbolt" -eq 465 ]; then
    smtp_ssltls_passbolt=false
    else
    smtp_ssltls_passbolt=true
    fi

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_passbolt
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do Passbolt:\e[97m $url_passbolt_front\e[0m"
    echo ""

    ## Informação sobre Email do usuario Admin do Passbolt
    echo -e "\e[33mEmail Admin:\e[97m $email_user_passbolt\e[0m"
    echo ""

    ## Informação sobre Email SMTP
    echo -e "\e[33mEmail SMTP:\e[97m $smtp_email_passbolt\e[0m"
    echo ""

    ## Informação sobre Email SMTP
    echo -e "\e[33mUser SMTP:\e[97m $smtp_user_passbolt\e[0m"
    echo ""
    
    ## Informação sobre Senha SMTP
    echo -e "\e[33mSenha SMTP:\e[97m $smtp_pass_passbolt\e[0m"
    echo ""
    
    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP:\e[97m $smtp_host_passbolt\e[0m"
    echo ""
    
    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP:\e[97m $smtp_port_passbolt\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_passbolt

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PASSBOLT \e[33m[1/7]\e[0m"
echo ""
sleep 1

telemetria PassBolt iniciado

## Literalmente nada, apenas um espaço vazio caso precisar de adicionar alguma coisa
## Antes..
## E claro, para aparecer a mensagem do passo..


## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO MYSQL \e[33m[2/7]\e[0m"
echo ""
sleep 1

dados

## Cria banco de dados do site no mysql
verificar_container_mysql
    if [ $? -eq 0 ]; then
        echo "1/3 - [ OK ] - MySQL já instalado"
        pegar_senha_mysql > /dev/null 2>&1
        echo "2/3 - [ OK ] - Copiando senha do MySQL"
        criar_banco_mysql_da_stack "passbolt${1:+_$1}"
        echo "3/3 - [ OK ] - Criando banco de dados"
        echo ""
    else
        ferramenta_mysql
        pegar_senha_mysql > /dev/null 2>&1
        criar_banco_mysql_da_stack "passbolt${1:+_$1}"
    fi
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[3/7]\e[0m"
echo ""
sleep 1

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO A PASSBOLT \e[33m[4/7]\e[0m"
echo ""
sleep 1

## Aqui de fato vamos iniciar a instalação do Passbolt

## Criando a stack passbolt.yaml
cat > passbolt${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  passbolt${1:+_$1}:
    image: passbolt/passbolt:latest ## Versão da aplicação

    volumes:
      - passbolt${1:+_$1}_data:/var/www/passbolt/webroot
      - passbolt${1:+_$1}_config:/etc/passbolt/

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Configurações Gerais
      - APP_FULL_BASE_URL=https://$url_passbolt
      - PASSBOLT_REGISTRATION_PUBLIC=false ## false = Não permite registro de novos usuários
      - PASSBOLT_SSL_FORCE=false
      - PASSBOLT_FORCE_SSL=false

    ## 🔐 JWT Authentication
      - PASSBOLT_PLUGINS_JWT_AUTHENTICATION_ENABLED=true
      - PASSBOLT_JWT_SERVER_KEY=
      - PASSBOLT_JWT_SERVER_PEM=

    ## 🗄️ Banco do MySQL
      - DATASOURCES_DEFAULT_HOST=mysql
      - DATASOURCES_DEFAULT_PORT=3306
      - DATASOURCES_DEFAULT_DATABASE=passbolt${1:+_$1}
      - DATASOURCES_DEFAULT_USERNAME=root
      - DATASOURCES_DEFAULT_PASSWORD=$senha_mysql

    ## 📧 Dados do SMTP
      - EMAIL_DEFAULT_FROM_NAME=Suporte
      - EMAIL_DEFAULT_FROM=$smtp_email_passbolt
      - EMAIL_TRANSPORT_DEFAULT_USERNAME=$smtp_user_passbolt
      - EMAIL_TRANSPORT_DEFAULT_PASSWORD=$smtp_pass_passbolt
      - EMAIL_TRANSPORT_DEFAULT_HOST=$smtp_host_passbolt
      - EMAIL_TRANSPORT_DEFAULT_PORT=$smtp_port_passbolt
      - EMAIL_TRANSPORT_DEFAULT_TLS=$smtp_ssltls_passbolt

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.passbolt${1:+_$1}.rule=Host(\`$url_passbolt\`)
        - traefik.http.services.passbolt${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.passbolt${1:+_$1}.service=passbolt${1:+_$1}
        - traefik.http.routers.passbolt${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.passbolt${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.passbolt${1:+_$1}.tls=true
        ## Mobile APP
        - traefik.http.routers.passbolt${1:+_$1}.middlewares=passbolt${1:+_$1}_mobile
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.customrequestheaders.X-Forwarded-Port=443
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.customrequestheaders.X-Forwarded-Host=$url_passbolt
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.customrequestheaders.X-Real-IP=
        - traefik.http.routers.passbolt${1:+_$1}_mobile.rule=Host(\`$url_passbolt\`) && (PathPrefix(\`/auth/jwt/\`) || PathPrefix(\`/mobile/\`) || PathPrefix(\`/auth/verify\`))
        - traefik.http.routers.passbolt${1:+_$1}_mobile.entrypoints=websecure
        - traefik.http.routers.passbolt${1:+_$1}_mobile.tls=true
        - traefik.http.routers.passbolt${1:+_$1}_mobile.tls.certresolver=letsencryptresolver
        - traefik.http.routers.passbolt${1:+_$1}_mobile.service=passbolt${1:+_$1}
        - traefik.http.routers.passbolt${1:+_$1}_mobile.middlewares=passbolt${1:+_$1}_mobile
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.framedeny=false
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.sslredirect=false
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.stsincludesubdomains=true
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.stspreload=true
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.stsseconds=31536000
        - "traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.contentsecuritypolicy=default-src 'self' 'unsafe-inline' 'unsafe-eval'; img-src 'self' data:; connect-src 'self'"
        - traefik.http.middlewares.passbolt${1:+_$1}_mobile.headers.referrerpolicy=strict-origin-when-cross-origin

## --------------------------- ORION --------------------------- ##

volumes:
  passbolt${1:+_$1}_data:
    external: true
    name: passbolt${1:+_$1}_data
  passbolt${1:+_$1}_config:
    external: true
    name: passbolt${1:+_$1}_config

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack da Passbolt"
fi
STACK_NAME="passbolt${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c passbolt.yaml passbolt > /dev/null 2>&1

#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel subir a stack da Passbolt"
#fi

sleep 10

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/7]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull passbolt/passbolt:latest

## Usa o serviço wait_passbolt para verificar se o serviço esta online
wait_stack "passbolt${1:+_$1}_passbolt${1:+_$1}"

wait_30_sec
wait_30_sec

## Mensagem de Passo
echo ""
echo -e "\e[97m• CADASTRANDO EMAIL COMO ADMINISTRADOR \e[33m[6/7]\e[0m"
echo ""
sleep 1

#docker exec -u www-data $(docker ps --format "{{.Names}}" | grep "^passbolt${1:+_$1}") /usr/share/php/passbolt/bin/cake passbolt register_user -u "$email_user_passbolt" -f Administrador -l Master -r admin

url_setup=$(docker exec -u www-data $(docker ps --format "{{.Names}}" | grep "^passbolt${1:+_$1}") \
/usr/share/php/passbolt/bin/cake passbolt register_user \
-u "$email_user_passbolt" -f Administrador -l Master -r admin | grep -o 'https://.*')

echo "1/1 - [ OK ] - Usuário administrador criado no email: $email_user_passbolt"
echo ""
## Mensagem de Passo
echo -e "\e[97m• CONFIGURANDO PASSBOLT.PHP \e[33m[7/7]\e[0m"
echo ""
sleep 1

PASSBOLT_FILE="/var/lib/docker/volumes/passbolt${1:+_$1}_config/_data/passbolt.php"
echo "1/5 - [ OK ] - Verificando diretório"

# Captura o fingerprint do servidor GPG (substitua "server@passbolt" pelo seu email/keyid)
FINGERPRINT=$(gpg --show-keys --with-fingerprint /var/lib/docker/volumes/passbolt${1:+_$1}_config/_data/gpg/serverkey.asc | grep -A1 "pub" | tail -1 | tr -d ' ')

echo "2/5 - [ OK ] - Pegando Fingerprint"

cat > "$PASSBOLT_FILE" << EOF
<?php
return [

    'App' => [
        'fullBaseUrl' => env('APP_FULL_BASE_URL', 'https://$url_passbolt'),
    ],

    'Datasources' => [
        'default' => [
            'host' => env('DATASOURCES_DEFAULT_HOST', 'mysql'),
            'port' => env('DATASOURCES_DEFAULT_PORT', 3306),
            'username' => env('DATASOURCES_DEFAULT_USERNAME', 'root'),
            'password' => env('DATASOURCES_DEFAULT_PASSWORD', '$senha_mysql'),
            'database' => env('DATASOURCES_DEFAULT_DATABASE', 'passbolt${1:+_$1}'),
        ],
    ],

    'EmailTransport' => [
        'default' => [
            'host' => env('EMAIL_TRANSPORT_DEFAULT_HOST', '$smtp_host_passbolt'),
            'port' => env('EMAIL_TRANSPORT_DEFAULT_PORT', $smtp_port_passbolt),
            'timeout' => env('EMAIL_TRANSPORT_DEFAULT_TIMEOUT', 30),
            'username' => env('EMAIL_TRANSPORT_DEFAULT_USERNAME', '$smtp_user_passbolt'),
            'password' => env('EMAIL_TRANSPORT_DEFAULT_PASSWORD', '$smtp_pass_passbolt'),
            'client' => env('EMAIL_TRANSPORT_DEFAULT_CLIENT', null),
            'tls' => env('EMAIL_TRANSPORT_DEFAULT_TLS', '$smtp_ssltls_passbolt'),
            'url' => env('EMAIL_TRANSPORT_DEFAULT_URL', null),
        ],
    ],

    'Email' => [
        'default' => [
            'transport' => env('EMAIL_DEFAULT_TRANSPORT', 'default'),
            'from' => [
                '$smtp_email_passbolt' => 'Suporte'
            ],
        ],
    ],

    'passbolt' => [
        'gpg' => [
            'serverKey' => [
                'fingerprint' => env('PASSBOLT_GPG_SERVER_KEY_FINGERPRINT', '$FINGERPRINT'),
                'public' => env('PASSBOLT_GPG_SERVER_KEY_PUBLIC', CONFIG . 'gpg' . DS . 'serverkey.asc'),
                'private' => env('PASSBOLT_GPG_SERVER_KEY_PRIVATE', CONFIG . 'gpg' . DS . 'serverkey_private.asc'),
            ],
        ],
        'security' => [
            'checkDomainMismatch' => false,
        ],
    ],
];
EOF

echo "3/5 - [ OK ] - Criando passbolt.php"

chmod 640 "$PASSBOLT_FILE"
chown www-data:www-data "$PASSBOLT_FILE"
echo "4/5 - [ OK ] - Dando permissão ao arquivo"

sleep 5

echo "5/5 - [ OK ] - Reiniciando o serviço..."
docker service update --force passbolt${1:+_$1}_passbolt${1:+_$1} >/dev/null 2>&1

sleep 15
docker ps -a --filter "name=passbolt" --filter "status=exited" -q | xargs -r docker rm > /dev/null 2>&1


telemetria PassBolt finalizado

cd dados_vps

cat > dados_passbolt${1:+_$1} <<EOL
[ PASSBOLT ]

Link do Passbolt: https://$url_passbolt

Email Administrador: $email_user_passbolt

Senha Administrador: Via link magico no email

Link de Setup: $url_setup
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PASSBOLT ]\e[0m"
echo ""

echo -e "\e[97mLink do Painel:\e[33m https://$url_passbolt\e[0m"
echo ""

echo -e "\e[97mEmail Administrador:\e[33m $email_user_passbolt\e[0m"
echo ""

echo -e "\e[97mSenha Administrador:\e[33m Via link magico no email\e[0m"
echo ""

echo -e "\e[97mLink de Setup:\e[33m $url_setup\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗  ██████╗ ████████╗███████╗███╗   ██╗██████╗ ███████╗██████╗  ██████╗ 
## ██╔════╝ ██╔═══██╗╚══██╔══╝██╔════╝████╗  ██║██╔══██╗██╔════╝██╔══██╗██╔════╝ 
## ██║  ███╗██║   ██║   ██║   █████╗  ██╔██╗ ██║██████╔╝█████╗  ██████╔╝██║  ███╗
## ██║   ██║██║   ██║   ██║   ██╔══╝  ██║╚██╗██║██╔══██╗██╔══╝  ██╔══██╗██║   ██║
## ╚██████╔╝╚██████╔╝   ██║   ███████╗██║ ╚████║██████╔╝███████╗██║  ██║╚██████╔╝
##  ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝ ╚═════╝ 

ferramenta_gotenberg() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_gotenberg

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o dominio para o Gotenberg (ex: gotenberg.oriondesign.art.br): \e[0m" && read -r url_gotenberg
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o usuario para o Gotenberg (ex: OrionDesign): \e[0m" && read -r gotenberg_user
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite a senha para o Gotenberg (ex: @Senha123_): \e[0m" && read -r gotenberg_pass
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_gotenberg
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do gotenberg
    echo -e "\e[33mDominio do Gotenberg:\e[97m $url_gotenberg\e[0m"
    echo ""

    ## Informação sobre URL do gotenberg
    echo -e "\e[33mUsuario para a autenticação básica:\e[97m $gotenberg_user\e[0m"
    echo ""

    ## Informação sobre URL do gotenberg
    echo -e "\e[33mSenha para a autenticação básica:\e[97m $gotenberg_pass\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_gotenberg

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO GOTENBERG \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Gotenberg iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO GOTENBERG \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack gotenberg.yaml
cat > gotenberg${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  gotenberg${1:+_$1}:
    image: gotenberg/gotenberg:latest
    command:
      - "gotenberg"

    volumes:
      - gotenberg${1:+_$1}_data:/gotenberg

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Autenticação Básica
      - API_ENABLE_BASIC_AUTH=true
      - GOTENBERG_API_BASIC_AUTH_USERNAME=$gotenberg_user
      - GOTENBERG_API_BASIC_AUTH_PASSWORD=$gotenberg_pass

    ## 📝 Logging
      - LOG_LEVEL=info
      - LOG_FORMAT=auto

    ## 🌐 Configuração da API
      - API_PORT=3000
      - API_TIMEOUT=30s
      - API_START_TIMEOUT=30s
      - API_BODY_LIMIT=
      - API_ROOT_PATH=/

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.gotenberg${1:+_$1}.rule=Host(\`$url_gotenberg\`)
        - traefik.http.services.gotenberg${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.gotenberg${1:+_$1}.service=gotenberg${1:+_$1}
        - traefik.http.routers.gotenberg${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.gotenberg${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.gotenberg${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  gotenberg${1:+_$1}_data:
    external: true
    name: gotenberg${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Gotenberg"
fi
STACK_NAME="gotenberg${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c gotenberg.yaml gotenberg > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do gotenberg"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull gotenberg/gotenberg:latest

## Usa o serviço wait_gotenberg para verificar se o serviço esta online
wait_stack gotenberg${1:+_$1}_gotenberg${1:+_$1}

telemetria Gotenberg finalizado

cd dados_vps

cat > dados_gotenberg${1:+_$1} <<EOL
[ GOTENBERG ]

Dominio do gotenberg: https://$url_gotenberg

Usuario: $gotenberg_user

Senha: $gotenberg_pass

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ GOTENBERG ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_gotenberg\e[0m"

echo -e "\e[33mUsuario:\e[97m $gotenberg_user\e[0m"

echo -e "\e[33mSenha:\e[97m $gotenberg_pass\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗    ██╗██╗██╗  ██╗██╗        ██╗███████╗
## ██║    ██║██║██║ ██╔╝██║        ██║██╔════╝
## ██║ █╗ ██║██║█████╔╝ ██║        ██║███████╗
## ██║███╗██║██║██╔═██╗ ██║   ██   ██║╚════██║
## ╚███╔███╔╝██║██║  ██╗██║██╗╚█████╔╝███████║
##  ╚══╝╚══╝ ╚═╝╚═╝  ╚═╝╚═╝╚═╝ ╚════╝ ╚══════╝

ferramenta_wiki() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_wiki

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o Wiki.JS (ex: wiki.oriondesign.art.br): \e[0m" && read -r url_wiki
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_wiki
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do wiki
    echo -e "\e[33mDominio do Wiki:\e[97m $url_wiki\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_wiki

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WIKI \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Wiki iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO WIKI \e[33m[2/3]\e[0m"
echo ""
sleep 1

wiki_postgres_password=$(openssl rand -hex 16)

## Criando a stack wikijs.yaml
cat > wiki${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  wiki${1:+_$1}_app:
    image: requarks/wiki:latest ## Versão da aplicação

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🐘 Dados do Postgres
      - DB_TYPE=postgres
      - DB_HOST=wiki${1:+_$1}_db
      - DB_PORT=5432
      - DB_USER=wikijs
      - DB_PASS=$wiki_postgres_password ## Senha para o Postgres
      - DB_NAME=wiki
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.wiki${1:+_$1}_app.rule=Host(\`$url_wiki\`) ## Dominio para aplicação
        - traefik.http.routers.wiki${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.wiki${1:+_$1}_app.priority=1
        - traefik.http.routers.wiki${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.wiki${1:+_$1}_app.service=wiki${1:+_$1}_app
        - traefik.http.services.wiki${1:+_$1}_app.loadbalancer.server.port=3000
        - traefik.http.services.wiki${1:+_$1}_app.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  wiki${1:+_$1}_db:
    image: postgres:15-alpine ## Versão do Postgres

    volumes:
      - wiki${1:+_$1}_db:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
      - POSTGRES_DB=wiki
      - POSTGRES_PASSWORD=$wiki_postgres_password ## Senha para o Postgres
      - POSTGRES_USER=wikijs
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##
  
volumes:
  wiki${1:+_$1}_db:
    external: true
    name: wiki${1:+_$1}_db

networks:
  $nome_rede_interna: ## Sua Rede interna
    external: true
    name: $nome_rede_interna ## Sua Rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do wiki"
fi
STACK_NAME="wiki${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c wiki.yaml wiki > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do wiki"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull requarks/wiki:latest postgres:15-alpine

## Usa o serviço wait_wiki para verificar se o serviço esta online
wait_stack wiki${1:+_$1}_wiki${1:+_$1}_db wiki${1:+_$1}_wiki${1:+_$1}_app

telemetria wiki finalizado

cd dados_vps

cat > dados_wiki${1:+_$1} <<EOL
[ WIKI ]

Dominio do wiki: https://$url_wiki

Usuario: Precisa criar no primeiro acesso do wiki

Senha: Precisa criar no primeiro acesso do wiki

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WIKI ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_wiki\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do wiki\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do wiki\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗ ███████╗██╗   ██╗██████╗  █████╗  ██████╗ █████╗ ███████╗████████╗
## ██╔══██╗╚══███╔╝██║   ██║██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔════╝╚══██╔══╝
## ███████║  ███╔╝ ██║   ██║██████╔╝███████║██║     ███████║███████╗   ██║   
## ██╔══██║ ███╔╝  ██║   ██║██╔══██╗██╔══██║██║     ██╔══██║╚════██║   ██║   
## ██║  ██║███████╗╚██████╔╝██║  ██║██║  ██║╚██████╗██║  ██║███████║   ██║   
## ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝   ╚═╝                                                                         

ferramenta_azuracast() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_azuracast

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o AzuraCast (ex: azuracast.oriondesign.art.br): \e[0m" && read -r url_azuracast
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_azuracast
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do azuracast
    echo -e "\e[33mDominio do AzuraCast:\e[97m $url_azuracast\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_azuracast

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO AZURACAST \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria AzuraCast iniciado

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO AZURACAST \e[33m[2/3]\e[0m"
echo ""
sleep 1

azuracast_mysql_password=$(openssl rand -hex 16)

## Criando a stack azuracast.yaml
cat > azuracast${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  azuracast${1:+_$1}_web:
    image: ghcr.io/azuracast/azuracast:latest

    volumes:
      - azuracast${1:+_$1}_station_data:/var/azuracast/stations
      - azuracast${1:+_$1}_backups:/var/azuracast/backups
      - azuracast${1:+_$1}_db_data:/var/lib/mysql
      - azuracast${1:+_$1}_www_uploads:/var/azuracast/storage/uploads
      - azuracast${1:+_$1}_shoutcast2_install:/var/azuracast/storage/shoutcast2
      - azuracast${1:+_$1}_stereo_tool_install:/var/azuracast/storage/stereo_tool
      - azuracast${1:+_$1}_rsas_install:/var/azuracast/storage/rsas
      - azuracast${1:+_$1}_geolite_install:/var/azuracast/storage/geoip
      - azuracast${1:+_$1}_sftpgo_data:/var/azuracast/storage/sftpgo
      - azuracast${1:+_$1}_acme:/var/azuracast/storage/acme

    networks:
      - $nome_rede_interna ## Nome da rede interna
    ports:
      - target: 2022
        published: 2022
        protocol: tcp
        mode: host
      - target: 8005
        published: 8005
        protocol: tcp
        mode: host

    environment:
    ## 📦 Identificação do Projeto
      - COMPOSE_PROJECT_NAME=azuracast

    ## 📡 Configurações de Portas
      - AZURACAST_HTTP_PORT=80
      - AZURACAST_HTTPS_PORT=443
      - AZURACAST_SFTP_PORT=2022

    ## 🔒 Configurações de Permissões
      - AZURACAST_PUID=1000
      - AZURACAST_PGID=1000

    ## 🚀 Configurações de Performance
      - NGINX_TIMEOUT=1800

    ## 🐘 Configurações do MySQL (INTERNO)
      - ENABLE_INTERNAL_MYSQL=true
      - MYSQL_ROOT_PASSWORD=$azuracast_mysql_password ## Senha do MySQL (INTERNO)
      - MYSQL_DATABASE=azuracast
      - MYSQL_USER=azuracast
      - MYSQL_PASSWORD=$azuracast_mysql_password ## Senha do usuário do MySQL (INTERNO)
      - MYSQL_CHARACTER_SET_SERVER=utf8mb4
      - MYSQL_COLLATION_SERVER=utf8mb4_unicode_ci

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.azuracast${1:+_$1}_web.rule=Host(\`$url_azuracast\`) ## Dominio para aplicação
        - traefik.http.routers.azuracast${1:+_$1}_web.entrypoints=websecure
        - traefik.http.routers.azuracast${1:+_$1}_web.priority=1
        - traefik.http.routers.azuracast${1:+_$1}_web.tls.certresolver=letsencryptresolver
        - traefik.http.routers.azuracast${1:+_$1}_web.service=azuracast${1:+_$1}_web
        - traefik.http.services.azuracast${1:+_$1}_web.loadbalancer.server.port=80
        - traefik.http.services.azuracast${1:+_$1}_web.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  azuracast${1:+_$1}_updater:
    image: ghcr.io/azuracast/updater:latest

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

## --------------------------- ORION --------------------------- ##

volumes:
  azuracast${1:+_$1}_station_data:
    external: true
    name: azuracast${1:+_$1}_station_data
  azuracast${1:+_$1}_backups:
    external: true
    name: azuracast${1:+_$1}_backups
  azuracast${1:+_$1}_db_data:
    external: true
    name: azuracast${1:+_$1}_db_data
  azuracast${1:+_$1}_www_uploads:
    external: true
    name: azuracast${1:+_$1}_www_uploads
  azuracast${1:+_$1}_shoutcast2_install:
    external: true
    name: azuracast${1:+_$1}_shoutcast2_install
  azuracast${1:+_$1}_stereo_tool_install:
    external: true
    name: azuracast${1:+_$1}_stereo_tool_install
  azuracast${1:+_$1}_rsas_install:
    external: true
    name: azuracast${1:+_$1}_rsas_install
  azuracast${1:+_$1}_geolite_install:
    external: true
    name: azuracast${1:+_$1}_geolite_install
  azuracast${1:+_$1}_sftpgo_data:
    external: true
    name: azuracast${1:+_$1}_sftpgo_data
  azuracast${1:+_$1}_acme:
    external: true
    name: azuracast${1:+_$1}_acme

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna

EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do AzuraCast"
fi
STACK_NAME="azuracast${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c azuracast.yaml azuracast > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do azuracast"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/azuracast/azuracast:latest ghcr.io/azuracast/updater:latest

## Usa o serviço wait_azuracast para verificar se o serviço esta online
wait_stack azuracast${1:+_$1}_azuracast${1:+_$1}_web azuracast${1:+_$1}_azuracast${1:+_$1}_updater

telemetria AzuraCast finalizado

cd dados_vps

cat > dados_azuracast${1:+_$1} <<EOL
[ AZURACAST ]

Dominio do AzuraCast: https://$url_azuracast

Usuario: Precisa criar no primeiro acesso do AzuraCast

Senha: Precisa criar no primeiro acesso do AzuraCast

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ AZURACAST ]\e[0m"
echo ""

echo -e "\e[33mDominio:\e[97m https://$url_azuracast\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no primeiro acesso do AzuraCast\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no primeiro acesso do AzuraCast\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗██╗  ██╗██╗     ██╗███╗   ██╗██╗  ██╗
## ██╔════╝██║  ██║██║     ██║████╗  ██║██║ ██╔╝
## ███████╗███████║██║     ██║██╔██╗ ██║█████╔╝ 
## ╚════██║██╔══██║██║     ██║██║╚██╗██║██╔═██╗ 
## ███████║██║  ██║███████╗██║██║ ╚████║██║  ██╗
## ╚══════╝╚═╝  ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝

ferramenta_shlink() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_shlink

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/4\e[0m"
    echo -en "\e[33mDigite o dominio para o Painel do Shlink (ex: painel-shlink.oriondesign.art.br): \e[0m" && read -r url_shlink
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/4\e[0m"
    echo -en "\e[33mDigite o dominio para a API do Shlink (ex: shlink.oriondesign.art.br): \e[0m" && read -r url_shlink_api
    echo ""

    ## Pergunta o usuario da ferramenta
    echo -e "\e[97mPasso$amarelo 3/4\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ e/ou espaços"
    echo -en "\e[33mDigite um usuario (ex: OrionDesign): \e[0m" && read -r shlink_user
    echo ""

    ## Pergunta o senha da ferramenta
    echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma Senha (ex: @Senha123_): \e[0m" && read -r shlink_pass
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_shlink
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do shlink
    echo -e "\e[33mDominio do Painel do Shlink:\e[97m $url_shlink\e[0m"
    echo ""

    ## Informação sobre URL do shlink
    echo -e "\e[33mDominio da API do Shlink:\e[97m $url_shlink_api\e[0m"
    echo ""

    ## Informação sobre URL do shlink
    echo -e "\e[33mUsuario do Shlink:\e[97m $shlink_user\e[0m"
    echo ""

    ## Informação sobre URL do shlink
    echo -e "\e[33mSenha do Shlink:\e[97m $shlink_pass\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_shlink

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO SHLINK \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria shlink iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres e redis instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "shlink${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "shlink${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO SHLINK \e[33m[3/4]\e[0m"
echo ""
sleep 1

shlink_api_key=$(openssl rand -hex 16)

basicauth=$(htpasswd -nbB "$shlink_user" "$shlink_pass" | sed 's/\$/\$\$/g')

## Criando a stack shlink.yaml
cat > shlink${1:+_$1}.yaml <<EOL
version: "3.8"
services:

## --------------------------- ORION --------------------------- ##

  shlink${1:+_$1}_app:
    image: shlinkio/shlink-web-client:latest

    networks:
      - $nome_rede_interna
    
    environment:
    ## 🌐 Configurações Gerais
      - DEFAULT_DOMAIN=$url_shlink_api
      - IS_HTTPS_ENABLED=true

    ## 🔐 ApiKey Shlink
      - INITIAL_API_KEY=$shlink_api_key

    ## 🌐 ApiKey do Geolite
      #- GEOLITE_LICENSE_KEY=SUA_CHAVE_GEOIP

    ## 🐘 Dados do Postgres
      - DB_DRIVER=postgres
      - DB_HOST=postgres
      - DB_NAME=shlink${1:+_$1}
      - DB_USER=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_PORT=5432

    ## 🔄 Redis
      - REDIS_URL=redis://redis:6379

    ## 🕒 Timezone
      - TIMEZONE=America/Sao_Paulo
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.shlink${1:+_$1}_app.rule=Host(\`$url_shlink\`) ## Dominio para aplicação
        - traefik.http.routers.shlink${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.shlink${1:+_$1}_app.priority=1
        - traefik.http.routers.shlink${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.shlink${1:+_$1}_app.service=shlink${1:+_$1}_app
        - traefik.http.services.shlink${1:+_$1}_app.loadbalancer.server.port=8080
        - traefik.http.services.shlink${1:+_$1}_app.loadbalancer.passHostHeader=true
        - "traefik.http.routers.shlink${1:+_$1}_app.middlewares=authshlink${1:+_$1}_app"
        - "traefik.http.middlewares.authshlink${1:+_$1}_app.basicauth.users=$basicauth"

## --------------------------- ORION --------------------------- ##

  shlink${1:+_$1}_api:
    image: shlinkio/shlink:latest

    volumes:
      - shlink${1:+_$1}_data:/etc/shlink

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Configurações Gerais
      - DEFAULT_DOMAIN=$url_shlink_api
      - IS_HTTPS_ENABLED=true

    ## 🔐 ApiKey Shlink
      - INITIAL_API_KEY=$shlink_api_key

    ## 🌐 ApiKey do Geolite
      #- GEOLITE_LICENSE_KEY=SUA_CHAVE_GEOIP

    ## 🐘 Dados do Postgres
      - DB_DRIVER=postgres
      - DB_HOST=postgres
      - DB_NAME=shlink${1:+_$1}
      - DB_USER=postgres
      - DB_PASSWORD=$senha_postgres
      - DB_PORT=5432

    ## 🔄 Redis
      - REDIS_URL=redis://redis:6379

    ## 🕒 Timezone
      - TIMEZONE=America/Sao_Paulo
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.shlink${1:+_$1}_api.rule=Host(\`$url_shlink_api\`) ## Dominio para aplicação
        - traefik.http.routers.shlink${1:+_$1}_api.entrypoints=websecure
        - traefik.http.routers.shlink${1:+_$1}_api.priority=1
        - traefik.http.routers.shlink${1:+_$1}_api.tls.certresolver=letsencryptresolver
        - traefik.http.routers.shlink${1:+_$1}_api.service=shlink${1:+_$1}_api
        - traefik.http.services.shlink${1:+_$1}_api.loadbalancer.server.port=8080
        - traefik.http.services.shlink${1:+_$1}_api.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  shlink${1:+_$1}_data:
    external: true
    name: shlink${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do shlink"
fi
STACK_NAME="shlink${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c shlink.yaml shlink > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do shlink"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull shlinkio/shlink-web-client:latest shlinkio/shlink:latest

## Usa o serviço wait_shlink para verificar se o serviço esta online
wait_stack shlink${1:+_$1}_shlink${1:+_$1}_app shlink${1:+_$1}_shlink${1:+_$1}_api

telemetria shlink finalizado

cd dados_vps

cat > dados_shlink${1:+_$1} <<EOL
[ SHLINK ]

Dominio do Painel do Shlink: https://$url_shlink

Dominio da API do Shlink: https://$url_shlink_api

ApiKey do Shlink: $shlink_api_key
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ SHLINK ]\e[0m"
echo ""

echo -e "\e[33mPainel do Shlink:\e[97m https://$url_shlink\e[0m"
echo ""

echo -e "\e[33mDominio da API:\e[97m https://$url_shlink_api\e[0m"
echo ""

echo -e "\e[33mApiKey:\e[97m $shlink_api_key\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗ ██╗   ██╗███████╗████████╗██████╗ ███████╗███████╗██╗  ██╗
## ██╔══██╗██║   ██║██╔════╝╚══██╔══╝██╔══██╗██╔════╝██╔════╝██║ ██╔╝
## ██████╔╝██║   ██║███████╗   ██║   ██║  ██║█████╗  ███████╗█████╔╝ 
## ██╔══██╗██║   ██║╚════██║   ██║   ██║  ██║██╔══╝  ╚════██║██╔═██╗ 
## ██║  ██║╚██████╔╝███████║   ██║   ██████╔╝███████╗███████║██║  ██╗
## ╚═╝  ╚═╝ ╚═════╝ ╚══════╝   ╚═╝   ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝

ferramenta_rustdesk() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_rustdesk

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o dominio para o HBBS do Rustdesk (ex: hbbs-rustdesk.oriondesign.art.br): \e[0m" && read -r url_hbbs
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite o dominio para o HBBR do Rustdesk (ex: hbbr-rustdesk.oriondesign.art.br): \e[0m" && read -r url_hbbr
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_rustdesk
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do rustdesk
    echo -e "\e[33mDominio do Servidor de ID do RustDesk:\e[97m $url_hbbs\e[0m"
    echo ""

    ## Informação sobre URL do rustdesk
    echo -e "\e[33mDominio do Servidor de Relay RustDesk:\e[97m $url_hbbr\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_rustdesk

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO RUSTDESK \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria RustDesk iniciado

## Gerando a chave do RustDesk
rustdesk_api_key=$(openssl rand -hex 16)

generate_rustdesk_string() {
    local link_hbbs="$1"
    local link_hbbr="$2"
    local key="$3"
    
    # Criar o JSON com formatação específica
    local json="{\"host\":\"$link_hbbs\",\"relay\":\"$link_hbbr\",\"api\":\"\",\"key\":\"$key\"}"
    
    # Converter para base64 e inverter
    echo -n "$json" | base64 -w 0 | rev
}

link_hbbs="$url_hbbs"
link_hbbr="$url_hbbr"
key="$rustdesk_api_key"

rustdesk_string=$(generate_rustdesk_string "$url_hbbs" "$url_hbbr" "$key")

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO RUSTDESK \e[33m[2/3]\e[0m"
echo ""
sleep 1


## Criando a stack rustdesk.yaml
cat > rustdesk${1:+_$1}.yaml <<EOL
version: "3.8"
services:

## --------------------------- ORION --------------------------- ##

  rustdesk${1:+_$1}_hbbs:
    image: rustdesk/rustdesk-server:latest
    command: hbbs

    volumes:
      - rustdesk${1:+_$1}_data:/root
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    ports:
      - 21115:21115
      - 21116:21116
      - 21116:21116/udp
      - 21118:21118  
    
    environment:
    ## 🌐 Configurações de Conexão
      - ALWAYS_USE_RELAY=N
      - RELAY=$url_hbbr
    
    ## 🔐 Segurança
      - KEY=$rustdesk_api_key
    
    ## 📜 Logs
      - RUST_LOG=info

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.rustdesk${1:+_$1}_hbbs.rule=Host(\`$url_hbbs\`) ## Dominio para aplicação
        - traefik.http.routers.rustdesk${1:+_$1}_hbbs.entrypoints=websecure
        - traefik.http.routers.rustdesk${1:+_$1}_hbbs.priority=1
        - traefik.http.routers.rustdesk${1:+_$1}_hbbs.tls.certresolver=letsencryptresolver
        - traefik.http.routers.rustdesk${1:+_$1}_hbbs.service=rustdesk${1:+_$1}_hbbs
        - traefik.http.services.rustdesk${1:+_$1}_hbbs.loadbalancer.server.port=21116
        - traefik.http.services.rustdesk${1:+_$1}_hbbs.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  rustdesk${1:+_$1}_hbbr:
    image: rustdesk/rustdesk-server:latest
    command: hbbr

    volumes:
      - rustdesk${1:+_$1}_data:/root
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    ports:
      - 21117:21117
      - 21119:21119      

    environment:
    ## 🔐 Segurança
      - KEY=$rustdesk_api_key
    
    ## 🚀 Performance e Banda
      - LIMIT_SPEED=200
      - SINGLE_BANDWIDTH=50
      - TOTAL_BANDWIDTH=500
    
    ## 📜 Logs
      - RUST_LOG=info

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.rustdesk${1:+_$1}_hbbr.rule=Host(\`$url_hbbr\`) ## Dominio para aplicação
        - traefik.http.routers.rustdesk${1:+_$1}_hbbr.entrypoints=websecure
        - traefik.http.routers.rustdesk${1:+_$1}_hbbr.priority=1
        - traefik.http.routers.rustdesk${1:+_$1}_hbbr.tls.certresolver=letsencryptresolver
        - traefik.http.routers.rustdesk${1:+_$1}_hbbr.service=rustdesk${1:+_$1}_hbbr
        - traefik.http.services.rustdesk${1:+_$1}_hbbr.loadbalancer.server.port=21117
        - traefik.http.services.rustdesk${1:+_$1}_hbbr.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  rustdesk${1:+_$1}_data:
    external: true
    name: rustdesk${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do rustdesk"
fi
STACK_NAME="rustdesk${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c rustdesk.yaml rustdesk > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do rustdesk"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull rustdesk/rustdesk-server:latest

## Usa o serviço wait_rustdesk para verificar se o serviço esta online
wait_stack rustdesk${1:+_$1}_rustdesk${1:+_$1}_hbbs rustdesk${1:+_$1}_rustdesk${1:+_$1}_hbbr

telemetria RustDesk finalizado

cd dados_vps

cat > dados_rustdesk${1:+_$1} <<EOL
[ RUSTDESK ]

Dominio do Servidor de ID do RustDesk:$url_hbbs

Dominio do Servidor de Relay do RustDesk:$url_hbbr

Dominio do Servidor da API do RustDesk: VAZIO

ApiKey do RustDesk: $rustdesk_api_key

Configurações do Servidor Rundesk: $rustdesk_string
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ RUSTDESK ]\e[0m"
echo ""

echo -e "\e[33mDominio do Servidor de ID do RustDesk:\e[97m $url_hbbs\e[0m"
echo ""

echo -e "\e[33mDominio do Servidor de Relay do RustDesk:\e[97m $url_hbbr\e[0m"
echo ""

echo -e "\e[33mDominio do Servidor da API do RustDesk:\e[97m VAZIO\e[0m"
echo ""

echo -e "\e[33mKey do RustDesk:\e[97m $rustdesk_api_key\e[0m"
echo ""

echo -e "\e[33mConfigurações do Servidor Rundesk:\e[97m $rustdesk_string\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗  ██╗ ██████╗ ██████╗ ██████╗ ███████╗ ██████╗ ██████╗ ████████╗ ██████╗██╗  ██╗
## ██║  ██║██╔═══██╗██╔══██╗██╔══██╗██╔════╝██╔════╝██╔═══██╗╚══██╔══╝██╔════╝██║  ██║
## ███████║██║   ██║██████╔╝██████╔╝███████╗██║     ██║   ██║   ██║   ██║     ███████║
## ██╔══██║██║   ██║██╔═══╝ ██╔═══╝ ╚════██║██║     ██║   ██║   ██║   ██║     ██╔══██║
## ██║  ██║╚██████╔╝██║     ██║     ███████║╚██████╗╚██████╔╝   ██║   ╚██████╗██║  ██║
## ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝     ╚══════╝ ╚═════╝ ╚═════╝    ╚═╝    ╚═════╝╚═╝  ╚═╝

ferramenta_hoppscotch() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_hoppscotch

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/8\e[0m"
    echo -en "\e[33mDigite o dominio para o Frontend do Hoppscotch (ex: hoppscotch.oriondesign.art.br): \e[0m" && read -r url_hoppscotch_frontend
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/8\e[0m"
    echo -en "\e[33mDigite o dominio para a API Admin do Hoppscotch (ex: admin-hoppscotch.oriondesign.art.br): \e[0m" && read -r url_hoppscotch_admin
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/8\e[0m"
    echo -en "\e[33mDigite o dominio para a API Backend do Hoppscotch (ex: backend-hoppscotch.oriondesign.art.br): \e[0m" && read -r url_hoppscotch_backend
    echo ""

    ##Pergunta o Email SMTP
    echo -e "\e[97mPasso$amarelo 4/8\e[0m"
    echo -en "\e[33mDigite o Email para SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r hoppscotch_smtp_email
    echo ""

    ##Pergunta o usuário do Email SMTP
    echo -e "\e[97mPasso$amarelo 5/8\e[0m"
    echo -e "$amarelo--> Caso não tiver um usuario do email, use o proprio email abaixo"
    echo -en "\e[33mDigite o Usuário para SMTP (ex: oriondesign ou contato@oriondesign.art.br): \e[0m" && read -r hoppscotch_smtp_user
    echo ""
    
    ## Pergunta a senha do SMTP
    echo -e "\e[97mPasso$amarelo 6/8\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ | Se estiver usando gmail use a senha de app"
    echo -en "\e[33mDigite a Senha SMTP do Email (ex: @Senha123_): \e[0m" && read -r hoppscotch_smtp_pass
    echo ""

    ## Pergunta o Host SMTP do email
    echo -e "\e[97mPasso$amarelo 7/8\e[0m"
    echo -en "\e[33mDigite o Host SMTP do Email (ex: smtp.hostinger.com): \e[0m" && read -r hoppscotch_smtp_host
    echo ""

    ## Pergunta a porta SMTP do email
    echo -e "\e[97mPasso$amarelo 8/8\e[0m"
    echo -en "\e[33mDigite a porta SMTP do Email (ex: 465): \e[0m" && read -r hoppscotch_smtp_port
    echo ""

    ## Verifica se a porta é 465, se sim deixa o ssl true, se não, deixa false 
    if [ "$porta_smtp_typebot" -eq 465 ]; then
    hoppscotch_smtp_secure=true
    else
    hoppscotch_smtp_secure=false
    fi
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_hoppscotch
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do hoppscotch
    echo -e "\e[33mDominio Frontend do Hoppscotch:\e[97m $url_hoppscotch_frontend\e[0m"
    echo ""

    ## Informação sobre URL do hoppscotch
    echo -e "\e[33mDominio Admin do Hoppscotch:\e[97m $url_hoppscotch_admin\e[0m"
    echo ""

    ## Informação sobre URL do hoppscotch
    echo -e "\e[33mDominio Backend do Hoppscotch:\e[97m $url_hoppscotch_backend\e[0m"
    echo ""

    ## Informação sobre Email SMTP
    echo -e "\e[33mEmail SMTP:\e[97m $hoppscotch_smtp_email\e[0m"
    echo ""

    ## Informação sobre Usuário SMTP
    echo -e "\e[33mUsuário SMTP:\e[97m $hoppscotch_smtp_user\e[0m"
    echo ""

    ## Informação sobre Host SMTP
    echo -e "\e[33mHost SMTP:\e[97m $hoppscotch_smtp_host\e[0m"
    echo ""

    ## Informação sobre Porta SMTP
    echo -e "\e[33mPorta SMTP:\e[97m $hoppscotch_smtp_port\e[0m"
    echo ""

    ## Informação sobre SSL SMTP
    echo -e "\e[33mSSL SMTP:\e[97m $hoppscotch_smtp_secure\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_hoppscotch

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO HOPPSCOTCH \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Hoppscotch iniciado

## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Cansei já de explicar o que isso faz kkkk
verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "hoppscotch${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "hoppscotch${1:+_$1}"
fi

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO HOPPSCOTCH \e[33m[3/4]\e[0m"
echo ""
sleep 1

encryption_key=$(openssl rand -hex 16)
jwt_secret_key=$(openssl rand -hex 16)
sesstion_secret_key=$(openssl rand -hex 16)

## Criando a stack hoppscotch.yaml
cat > hoppscotch${1:+_$1}.yaml <<EOL
version: "3.8"
services:

## --------------------------- ORION --------------------------- ##

  hoppscotch${1:+_$1}_app:
    image: hoppscotch/hoppscotch-frontend:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🌐 URLs do Aplicativo
      - VITE_BASE_URL=https://$url_hoppscotch_frontend
      - VITE_SHORTCODE_BASE_URL=https://$url_hoppscotch_frontend
      - VITE_ADMIN_URL=https://$url_hoppscotch_admin
      - VITE_BACKEND_GQL_URL=https://$url_hoppscotch_backend/graphql
      - VITE_BACKEND_WS_URL=wss://$url_hoppscotch_backend/graphql
      - VITE_BACKEND_API_URL=https://$url_hoppscotch_backend/v1

    ## 🔐 Provedores de Autenticação
      - VITE_ALLOWED_AUTH_PROVIDERS=EMAIL ## Opções: EMAIL,GOOGLE,GITHUB,MICROSOFT

    ## 📄 Termos e Privacidade
      - VITE_APP_TOS_LINK=https://docs.hoppscotch.io/support/terms
      - VITE_APP_PRIVACY_POLICY_LINK=https://docs.hoppscotch.io/support/privacy

    ## 🛣️ Acesso via Subpath
      - ENABLE_SUBPATH_BASED_ACCESS=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.hoppscotch${1:+_$1}_app.rule=Host(\`$url_hoppscotch_frontend\`) ## Dominio para aplicação
        - traefik.http.routers.hoppscotch${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.hoppscotch${1:+_$1}_app.priority=1
        - traefik.http.routers.hoppscotch${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.hoppscotch${1:+_$1}_app.service=hoppscotch${1:+_$1}_app
        - traefik.http.services.hoppscotch${1:+_$1}_app.loadbalancer.server.port=3000
        - traefik.http.services.hoppscotch${1:+_$1}_app.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  hoppscotch${1:+_$1}_admin:
    image: hoppscotch/hoppscotch-admin:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🌐 URLs do Aplicativo
      - VITE_BASE_URL=https://$url_hoppscotch_frontend
      - VITE_SHORTCODE_BASE_URL=https://$url_hoppscotch_frontend
      - VITE_ADMIN_URL=https://$url_hoppscotch_admin
      - VITE_BACKEND_GQL_URL=https://$url_hoppscotch_backend/graphql
      - VITE_BACKEND_WS_URL=wss://$url_hoppscotch_backend/graphql
      - VITE_BACKEND_API_URL=https://$url_hoppscotch_backend/v1

    ## 🔐 Provedores de Autenticação
      - VITE_ALLOWED_AUTH_PROVIDERS=EMAIL ## Opções: EMAIL,GOOGLE,GITHUB,MICROSOFT

    ## 📄 Termos e Privacidade
      - VITE_APP_TOS_LINK=https://docs.hoppscotch.io/support/terms
      - VITE_APP_PRIVACY_POLICY_LINK=https://docs.hoppscotch.io/support/privacy

    ## 🛣️ Acesso via Subpath
      - ENABLE_SUBPATH_BASED_ACCESS=false
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.hoppscotch${1:+_$1}_admin.rule=Host(\`$url_hoppscotch_admin\`) ## Dominio para aplicação
        - traefik.http.routers.hoppscotch${1:+_$1}_admin.entrypoints=websecure
        - traefik.http.routers.hoppscotch${1:+_$1}_admin.priority=1
        - traefik.http.routers.hoppscotch${1:+_$1}_admin.tls.certresolver=letsencryptresolver
        - traefik.http.routers.hoppscotch${1:+_$1}_admin.service=hoppscotch${1:+_$1}_admin
        - traefik.http.services.hoppscotch${1:+_$1}_admin.loadbalancer.server.port=3100
        - traefik.http.services.hoppscotch${1:+_$1}_admin.loadbalancer.passHostHeader=true
        
## --------------------------- ORION --------------------------- ##

  hoppscotch${1:+_$1}_backend:
    image: hoppscotch/hoppscotch-backend:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🐘 Dados do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/hoppscotch${1:+_$1}

    ## ⚙️ Configurações do App
      - REDIRECT_URL=https://$url_hoppscotch_frontend
      - WHITELISTED_ORIGINS=https://$url_hoppscotch_frontend,https://$url_hoppscotch_admin
      - VITE_BASE_URL=https://$url_hoppscotch_frontend
      - VITE_ADMIN_URL=https://$url_hoppscotch_admin

    ## 🔐 Provedores de Autenticação
      - VITE_ALLOWED_AUTH_PROVIDERS=EMAIL ## Opções: EMAIL,GOOGLE,GITHUB,MICROSOFT

    ## 📧 E-mail SMTP
      - MAILER_SMTP_ENABLE=true
      - MAILER_USE_CUSTOM_CONFIGS=true
      - MAILER_ADDRESS_FROM=$hoppscotch_smtp_email
      - MAILER_SMTP_USER=$hoppscotch_smtp_user
      - MAILER_SMTP_PASSWORD=$hoppscotch_smtp_pass
      - MAILER_SMTP_HOST=$hoppscotch_smtp_host
      - MAILER_SMTP_PORT=$hoppscotch_smtp_port
      - MAILER_SMTP_SECURE=$hoppscotch_smtp_secure
      - MAILER_TLS_REJECT_UNAUTHORIZED=true

    ## 🛡️ Configurações de Segurança
      - DATA_ENCRYPTION_KEY=$encryption_key
      - JWT_SECRET=$jwt_secret_key
      - TOKEN_SALT_COMPLEXITY=10
      - MAGIC_LINK_TOKEN_VALIDITY=3
      - REFRESH_TOKEN_VALIDITY=604800000
      - ACCESS_TOKEN_VALIDITY=86400000
      - SESSION_SECRET=$sesstion_secret_key
      - ALLOW_SECURE_COOKIES=true

    ## 🚦 Rate Limit
      - RATE_LIMIT_TTL=60
      - RATE_LIMIT_MAX=100

    ## 🔵 Auth Google
      - GOOGLE_CLIENT_ID=disabled
      - GOOGLE_CLIENT_SECRET=disabled
      - GOOGLE_CALLBACK_URL=https://$url_hoppscotch_backend/v1/auth/google/callback
      - GOOGLE_SCOPE=email,profile
  
    ## 🔵 Auth Github
      - GITHUB_CLIENT_ID=disabled
      - GITHUB_CLIENT_SECRET=disabled
      - GITHUB_CALLBACK_URL=https://$url_hoppscotch_backend/v1/auth/github/callback
      - GITHUB_SCOPE=user:email

    ## 🔵 Auth Microsoft
      - MICROSOFT_CLIENT_ID=disabled
      - MICROSOFT_CLIENT_SECRET=disabled
      - MICROSOFT_CALLBACK_URL=https://$url_hoppscotch_backend/v1/auth/microsoft/callback
      - MICROSOFT_SCOPE=user.read
      - MICROSOFT_TENANT=common   

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=1
        - traefik.http.routers.hoppscotch${1:+_$1}_backend.rule=Host(\`$url_hoppscotch_backend\`) ## Dominio para aplicação
        - traefik.http.routers.hoppscotch${1:+_$1}_backend.entrypoints=websecure
        - traefik.http.routers.hoppscotch${1:+_$1}_backend.priority=1
        - traefik.http.routers.hoppscotch${1:+_$1}_backend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.hoppscotch${1:+_$1}_backend.service=hoppscotch${1:+_$1}_backend
        - traefik.http.services.hoppscotch${1:+_$1}_backend.loadbalancer.server.port=3170
        - traefik.http.services.hoppscotch${1:+_$1}_backend.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

  hoppscotch${1:+_$1}_migrate:
    image: hoppscotch/hoppscotch-backend:latest
    command: sh -c "sleep 30 && pnpx prisma migrate deploy"

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🐘 Dados do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/hoppscotch${1:+_$1}
    
    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: none
      placement:
        constraints:
          - node.role == manager      

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Hoppscotch"
fi
STACK_NAME="hoppscotch${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c hoppscotch.yaml hoppscotch > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do hoppscotch"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull hoppscotch/hoppscotch-backend:latest hoppscotch/hoppscotch-frontend:latest hoppscotch/hoppscotch-admin:latest

## Usa o serviço wait_hoppscotch para verificar se o serviço esta online
wait_stack hoppscotch${1:+_$1}_hoppscotch${1:+_$1}_migrate hoppscotch${1:+_$1}_hoppscotch${1:+_$1}_app hoppscotch${1:+_$1}_hoppscotch${1:+_$1}_admin hoppscotch${1:+_$1}_hoppscotch${1:+_$1}_backend

telemetria Hoppscotch finalizado

cd dados_vps

cat > dados_hoppscotch${1:+_$1} <<EOL
[ HOPPSCOTCH ]

Dominio do hoppscotch: https://$url_hoppscotch_frontend

Usuario: Precisa criar no Hoppscotch

Senha: Precisa criar no Hoppscotch

Dominio do Admin: https://$url_hoppscotch_admin

Dominio do Backend API: https://$url_hoppscotch_backend
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ HOPPSCOTCH ]\e[0m"
echo ""

echo -e "\e[33mDominio do App:\e[97m https://$url_hoppscotch_frontend\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no Hoppscotch\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no Hoppscotch\e[0m"
echo ""

echo -e "\e[33mDominio do Admin:\e[97m https://$url_hoppscotch_admin\e[0m"
echo ""

echo -e "\e[33mDominio do Backend API:\e[97m https://$url_hoppscotch_backend\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ████████╗██████╗  █████╗ ███╗   ██╗███████╗ ██████╗██████╗ ███████╗██╗   ██╗███████╗
## ╚══██╔══╝██╔══██╗██╔══██╗████╗  ██║██╔════╝██╔════╝██╔══██╗██╔════╝██║   ██║██╔════╝
##    ██║   ██████╔╝███████║██╔██╗ ██║███████╗██║     ██████╔╝█████╗  ██║   ██║█████╗  
##    ██║   ██╔══██╗██╔══██║██║╚██╗██║╚════██║██║     ██╔══██╗██╔══╝  ╚██╗ ██╔╝██╔══╝  
##    ██║   ██║  ██║██║  ██║██║ ╚████║███████║╚██████╗██║  ██║███████╗ ╚████╔╝ ███████╗
##    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝  ╚═══╝  ╚══════╝
##                                                                                     
##                                ███████╗ █████╗ ██████╗                             
##                                ╚══███╔╝██╔══██╗██╔══██╗                            
##                                  ███╔╝ ███████║██████╔╝                            
##                                 ███╔╝  ██╔══██║██╔═══╝                             
##                                ███████╗██║  ██║██║                                 
##                                ╚══════╝╚═╝  ╚═╝╚═╝                                 

ferramenta_transcrevezap() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_transcrevezap

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/4\e[0m"
    echo -en "\e[33mDigite o dominio para a API do TranscreveZap (ex: apitranscreve.oriondesign.art.br): \e[0m" && read -r api_transcrevezap
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/4\e[0m"
    echo -en "\e[33mDigite o dominio para o Manager do TranscreveZap (ex: transcrevezap.oriondesign.art.br): \e[0m" && read -r url_transcrevezap
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/4\e[0m"
    echo -en "\e[33mDigite um usuario para o TranscreveZap (ex: OrionDesign): \e[0m" && read -r user_transcrevezap
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    echo -en "\e[33mDigite uma senha para o TranscreveZap (ex: @Senha123_): \e[0m" && read -r pass_transcrevezap
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_transcrevezap
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do transcrevezap
    echo -e "\e[33mDominio da API TranscreveZap:\e[97m $api_transcrevezap\e[0m"
    echo ""

    ## Informação sobre URL do transcrevezap
    echo -e "\e[33mDominio do Manager do TranscreveZap:\e[97m $url_transcrevezap\e[0m"
    echo ""

    ## Informação sobre URL do transcrevezap
    echo -e "\e[33mUsuario do TranscreveZap:\e[97m $user_transcrevezap\e[0m"
    echo ""

    ## Informação sobre URL do transcrevezap
    echo -e "\e[33mSenha do TranscreveZap:\e[97m $pass_transcrevezap\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_transcrevezap

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO TRANSCREVEZAP \e[33m[1/3]\e[0m"
echo ""
sleep 1




## Nadaaaaa

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO TRANSCREVEZAP \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack transcrevezap.yaml
cat > transcrevezap${1:+_$1}.yaml <<EOL

version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  transcrevezap${1:+_$1}:
    image: impacteai/transcrevezap:latest
    command: ./start.sh

    networks:
      - $nome_rede_interna

    environment:
    ## 🔐 Configurações de Acesso
      - MANAGER_USER=$user_transcrevezap
      - MANAGER_PASSWORD=$pass_transcrevezap

    ## ⚙️ Configurações Globais
      - API_DOMAIN=$api_transcrevezap
      - UVICORN_PORT=8005
      - UVICORN_HOST=0.0.0.0
      - UVICORN_RELOAD=true
      - UVICORN_WORKERS=1

    ## 🔄 Configurações do Redis
      - REDIS_HOST=redis_transcrevezap${1:+_$1}
      - REDIS_PORT=6380

    ## 🐞 Configurações de Debug
      - DEBUG_MODE=false
      - LOG_LEVEL=INFO

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.transcrevezap${1:+_$1}.rule=Host(\`$api_transcrevezap\`) ## url do transcrevezap
        - traefik.http.routers.transcrevezap${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.transcrevezap${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.services.transcrevezap${1:+_$1}.loadbalancer.server.port=8005
        - traefik.http.services.transcrevezap${1:+_$1}.loadbalancer.passHostHeader=true
        - traefik.http.routers.transcrevezap${1:+_$1}.service=transcrevezap${1:+_$1}
        - traefik.http.middlewares.traefik-compress.compress=true
        - traefik.http.routers.transcrevezap${1:+_$1}.middlewares=traefik-compress
        - traefik.http.routers.transcrevezap${1:+_$1}_manager.rule=Host(\`$url_transcrevezap\`) ## url do manager do transcrevezap
        - traefik.http.routers.transcrevezap${1:+_$1}_manager.entrypoints=websecure
        - traefik.http.routers.transcrevezap${1:+_$1}_manager.tls.certresolver=letsencryptresolver
        - traefik.http.services.transcrevezap${1:+_$1}_manager.loadbalancer.server.port=8501
        - traefik.http.routers.transcrevezap${1:+_$1}_manager.service=transcrevezap${1:+_$1}_manager

## --------------------------- ORION --------------------------- ##

  redis_transcrevezap${1:+_$1}:
    image: redis:6
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6380"
      ]

    volumes:
      - redis_transcrevezap${1:+_$1}_data:/data

    networks:
      - $nome_rede_interna

## --------------------------- ORION --------------------------- ##

volumes:
  redis_transcrevezap${1:+_$1}_data:
    external: true
    name: redis_transcrevezap${1:+_$1}_data

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL

if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do TranscreveZap"
fi
STACK_NAME="transcrevezap${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c transcrevezap.yaml transcrevezap > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do transcrevezap"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull impacteai/transcrevezap:latest redis:6

## Usa o serviço wait_transcrevezap para verificar se o serviço esta online
wait_stack transcrevezap${1:+_$1}_transcrevezap${1:+_$1} transcrevezap${1:+_$1}_redis_transcrevezap${1:+_$1}

telemetria TranscreveZap finalizado

cd dados_vps

cat > dados_transcrevezap${1:+_$1} <<EOL
[ TRANSCREVEZAP ]

Url API do TranscreveZap: https://$api_transcrevezap

Url Manager do TranscreveZap: https://$url_transcrevezap

Usuario: $user_transcrevezap

Senha: $pass_transcrevezap
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ TRANSCREVEZAP ]\e[0m"
echo ""

echo -e "\e[33mLink do Manager:\e[97m https://$url_transcrevezap\e[0m"
echo ""

echo -e "\e[33mLink da API:\e[97m https://$api_transcrevezap\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_transcrevezap\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_transcrevezap\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ███╗   ███╗███╗   ██╗██╗████████╗ ██████╗  ██████╗ ██╗     ███████╗
## ██╔═══██╗████╗ ████║████╗  ██║██║╚══██╔══╝██╔═══██╗██╔═══██╗██║     ██╔════╝
## ██║   ██║██╔████╔██║██╔██╗ ██║██║   ██║   ██║   ██║██║   ██║██║     ███████╗
## ██║   ██║██║╚██╔╝██║██║╚██╗██║██║   ██║   ██║   ██║██║   ██║██║     ╚════██║
## ╚██████╔╝██║ ╚═╝ ██║██║ ╚████║██║   ██║   ╚██████╔╝╚██████╔╝███████╗███████║
##  ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═══╝╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝╚══════╝

ferramenta_omnitools() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_omnitools

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o OmniTools (ex: omnitools.oriondesign.art.br): \e[0m" && read -r url_omnitools
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_omnitools
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do transcrevezap
    echo -e "\e[33mDominio do OmniTools:\e[97m $url_omnitools\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_omnitools

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO OMNITOOLS \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria OmniTools iniciado

echo -e "\e[97m• INSTALANDO OMNITOOLS \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack omnitools.yaml
cat > omnitools${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  omnitools${1:+_$1}:
    image: iib0011/omni-tools:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    #environments:
    ## 🌐 Integração com Locize
      #- LOCIZE_API_KEY=

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.omnitools${1:+_$1}.rule=Host(\`$url_omnitools\`)
        - traefik.http.services.omnitools${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.omnitools${1:+_$1}.service=omnitools${1:+_$1}
        - traefik.http.routers.omnitools${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.omnitools${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.omnitools${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do OmniTools"
fi

STACK_NAME="omnitools${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c omnitools.yaml omnitools > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do omnitools"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull iib0011/omni-tools:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack omnitools${1:+_$1}_omnitools${1:+_$1}

telemetria OmniTools finalizado

cd dados_vps

cat > dados_omnitools${1:+_$1} <<EOL
[ OMNITOOLS ]

Dominio do OmniTools: https://$url_omnitools
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ OMNITOOLS ]\e[0m"
echo ""

echo -e "\e[33mDominio do OmniTools:\e[97m https://$url_omnitools\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗███████╗██████╗ ██████╗ ██████╗ ███████╗ █████╗ ██████╗ 
## ██╔════╝██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔══██╗
## ███████╗█████╗  ██████╔╝██████╔╝██████╔╝█████╗  ███████║██████╔╝
## ╚════██║██╔══╝  ██╔══██╗██╔═══╝ ██╔══██╗██╔══╝  ██╔══██║██╔══██╗
## ███████║███████╗██║  ██║██║     ██████╔╝███████╗██║  ██║██║  ██║
## ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝

ferramenta_serpbear() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_serpbear

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o Serpbear (ex: serpbear.oriondesign.art.br): \e[0m" && read -r url_serpbear
    echo ""

    ##Pergunta o usuario
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o usuario para o Serpbear (ex: admin): \e[0m" && read -r user_serpbear
    echo ""
    
    ##Pergunta a senha
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite a senha para o Serpbear (ex: @Senha123_): \e[0m" && read -r pass_serpbear
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_serpbear
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL do transcrevezap
    echo -e "\e[33mDominio do Serpbear:\e[97m $url_serpbear\e[0m"
    echo ""

    ## Informação sobre Usuario do Serpbear
    echo -e "\e[33mUsuario do Serpbear:\e[97m $user_serpbear\e[0m"
    echo ""

    ## Informação sobre Senha do Serpbear
    echo -e "\e[33mSenha do Serpbear:\e[97m $pass_serpbear\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_serpbear

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO SERPBEAR \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Serpbear iniciado

echo -e "\e[97m• INSTALANDO SERPBEAR \e[33m[2/1]\e[0m"
echo ""
sleep 1

secret_key_serpbear=$(openssl rand -hex 32)
apikey_serpbear=$(openssl rand -hex 16)

## Criando a stack serpbear.yaml
cat > serpbear${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  serpbear${1:+_$1}:
    image: towfiqi/serpbear:latest

    volumes:
      - serpbear${1:+_$1}_appdata:/app/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      ## 🌐 Url do Frontend
      - NEXT_PUBLIC_APP_URL=https://$url_serpbear

      ## 🔐 Dados de acesso
      - USER=$user_serpbear
      - PASSWORD=$pass_serpbear

      ## 🧾 SecretKey e APIKey
      - SECRET=$secret_key_serpbear
      - APIKEY=$apikey_serpbear

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.serpbear${1:+_$1}.rule=Host(\`$url_serpbear\`)
        - traefik.http.services.serpbear${1:+_$1}.loadbalancer.server.port=3000
        - traefik.http.routers.serpbear${1:+_$1}.service=serpbear${1:+_$1}
        - traefik.http.routers.serpbear${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.serpbear${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.serpbear${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  serpbear${1:+_$1}_appdata:
    external: true
    name: serpbear${1:+_$1}_appdata

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Serpbear"
fi

STACK_NAME="serpbear${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c serpbear.yaml serpbear > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do serpbear"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull towfiqi/serpbear:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack serpbear${1:+_$1}_serpbear${1:+_$1}

telemetria Serpbear finalizado

cd dados_vps

cat > dados_serpbear${1:+_$1} <<EOL
[ SERPBEAR ]

Dominio do Serpbear: https://$url_serpbear

Usuario: $user_serpbear

Senha: $pass_serpbear
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ SERPBEAR ]\e[0m"
echo ""

echo -e "\e[33mDominio do Serpbear:\e[97m https://$url_serpbear\e[0m"
echo ""

echo -e "\e[33mUsuario do Serpbear:\e[97m $user_serpbear\e[0m"
echo ""

echo -e "\e[33mSenha do Serpbear:\e[97m $pass_serpbear\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗  ██████╗████████╗██╗██╗   ██╗███████╗██████╗ ██╗███████╗ ██████╗███████╗███████╗
## ██╔══██╗██╔════╝╚══██╔══╝██║██║   ██║██╔════╝██╔══██╗██║██╔════╝██╔════╝██╔════╝██╔════╝
## ███████║██║        ██║   ██║██║   ██║█████╗  ██████╔╝██║█████╗  ██║     █████╗  ███████╗
## ██╔══██║██║        ██║   ██║╚██╗ ██╔╝██╔══╝  ██╔═══╝ ██║██╔══╝  ██║     ██╔══╝  ╚════██║
## ██║  ██║╚██████╗   ██║   ██║ ╚████╔╝ ███████╗██║     ██║███████╗╚██████╗███████╗███████║
## ╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚═╝  ╚═══╝  ╚══════╝╚═╝     ╚═╝╚══════╝ ╚═════╝╚══════╝╚══════╝

ferramenta_activepieces() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_activepieces

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o ActivePieces (ex: activepieces.oriondesign.art.br): \e[0m" && read -r url_activepieces
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_activepieces
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do ActivePieces:\e[97m $url_activepieces\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_activepieces

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO ACTIVEPIECES \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria ActivePieces iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO ACTIVEPIECES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "activepieces${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "activepieces${1:+_$1}"
fi

echo -e "\e[97m• INSTALANDO ACTIVEPIECES \e[33m[3/4]\e[0m"
echo ""
sleep 1

apikey_activepieces=$(openssl rand -hex 16)
encryptionkey_activepieces=$(openssl rand -hex 16)
jwtsecret_activepieces=$(openssl rand -hex 16)

## Criando a stack activepieces.yaml
cat > activepieces${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  activepieces${1:+_$1}_app:
    image: activepieces/activepieces:latest

    volumes:
      - activepieces${1:+_$1}_cache:/usr/src/app/cache

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌍 Ambiente e URLs
      - AP_ENVIRONMENT=prod
      - AP_FRONTEND_URL=https://$url_activepieces ## Url da Aplicação
      - AP_TEMPLATES_SOURCE_URL=https://cloud.activepieces.com/api/v1/flow-templates

    ## 🔐 Segurança e Autenticação
      - AP_API_KEY=$apikey_activepieces
      - AP_ENCRYPTION_KEY=$encryptionkey_activepieces
      - AP_JWT_SECRET=$jwtsecret_activepieces

    ## 🗄️ Banco de Dados (PostgreSQL)
      - AP_POSTGRES_HOST=postgres
      - AP_POSTGRES_PORT=5432
      - AP_POSTGRES_DATABASE=activepieces${1:+_$1}
      - AP_POSTGRES_USERNAME=postgres
      - AP_POSTGRES_PASSWORD=$senha_postgres

    ## ⚡ Redis
      - AP_REDIS_HOST=activepieces${1:+_$1}_redis
      - AP_REDIS_PORT=6379
      
    ## 🔧 Execução e Engine
      - AP_ENGINE_EXECUTABLE_PATH=dist/packages/engine/main.js
      - AP_EXECUTION_MODE=UNSANDBOXED
      - AP_FLOW_TIMEOUT_SECONDS=600
      - AP_TRIGGER_DEFAULT_POLL_INTERVAL=5
      - AP_WEBHOOK_TIMEOUT_SECONDS=30

    ## 📊 Telemetria
      - AP_TELEMETRY_ENABLED=false

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.activepieces${1:+_$1}.rule=Host(\`$url_activepieces\`) ## Url da Aplicação
        - traefik.http.services.activepieces${1:+_$1}.loadbalancer.server.port=80
        - traefik.http.routers.activepieces${1:+_$1}.service=activepieces${1:+_$1}
        - traefik.http.routers.activepieces${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.activepieces${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.activepieces${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  activepieces${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - activepieces${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  activepieces${1:+_$1}_cache:
    external: true
    name: activepieces${1:+_$1}_cache
  activepieces${1:+_$1}_redis:
    external: true
    name: activepieces${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do ActivePieces"
fi

STACK_NAME="activepieces${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c activepieces.yaml activepieces > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do activepieces"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest activepieces/activepieces:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack activepieces${1:+_$1}_activepieces${1:+_$1}_redis activepieces${1:+_$1}_activepieces${1:+_$1}_app

telemetria ActivePieces finalizado

cd dados_vps

cat > dados_activepieces${1:+_$1} <<EOL
[ ACTIVEPIECES ]

Dominio do ActivePieces: https://$url_activepieces

Usuario: Precisa criar no primeiro acesso do ActivePieces

Senha: Precisa criar no primeiro acesso do ActivePieces
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ACTIVEPIECES ]\e[0m"
echo ""

echo -e "\e[33mDominio do ActivePieces:\e[97m https://$url_activepieces\e[0m"
echo ""

echo -e "\e[33mUsuario do ActivePieces:\e[97m Precisa criar no primeiro acesso do ActivePieces\e[0m"
echo ""

echo -e "\e[33mSenha do ActivePieces:\e[97m Precisa criar no primeiro acesso do ActivePieces\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗ ██╗   ██╗████████╗██╗  ██╗███████╗███╗   ██╗████████╗██╗██╗  ██╗
## ██╔══██╗██║   ██║╚══██╔══╝██║  ██║██╔════╝████╗  ██║╚══██╔══╝██║██║ ██╔╝
## ███████║██║   ██║   ██║   ███████║█████╗  ██╔██╗ ██║   ██║   ██║█████╔╝ 
## ██╔══██║██║   ██║   ██║   ██╔══██║██╔══╝  ██║╚██╗██║   ██║   ██║██╔═██╗ 
## ██║  ██║╚██████╔╝   ██║   ██║  ██║███████╗██║ ╚████║   ██║   ██║██║  ██╗
## ╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝╚═╝  ╚═╝

ferramenta_authentik() {
## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_authentik

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o Authentik (ex: authentik.oriondesign.art.br): \e[0m" && read -r url_authentik
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o email para o Authentik (ex: orion@oriondesign.art.br): \e[0m" && read -r email_authentik
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite o senha para o Authentik (ex: @Senha123_): \e[0m" && read -r senha_authentik
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_authentik
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do authentik:\e[97m $url_authentik\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mEmail do authentik:\e[97m $email_authentik\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do authentik:\e[97m $senha_authentik\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_authentik

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO AUTHENTIK \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Authentik iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO AUTHENTIK \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "authentik${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "authentik${1:+_$1}"
fi

echo -e "\e[97m• INSTALANDO AUTHENTIK \e[33m[3/4]\e[0m"
echo ""
sleep 1

secretkey_authentik=$(openssl rand -hex 16)

## Criando a stack authentik.yaml
cat > authentik${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  authentik${1:+_$1}_server:
    image: ghcr.io/goauthentik/server:latest
    command: server
    
    volumes:
    - authentik${1:+_$1}_media:/data/media
    - authentik${1:+_$1}_templates:/templates

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Dados de acesso
      - AUTHENTIK_BOOTSTRAP_EMAIL=$email_authentik
      - AUTHENTIK_BOOTSTRAP_PASSWORD=$senha_authentik

    ## 🐘 Configuração do PostgreSQL
      - AUTHENTIK_POSTGRESQL__HOST=postgres
      - AUTHENTIK_POSTGRESQL__NAME=authentik${1:+_$1}
      - AUTHENTIK_POSTGRESQL__PASSWORD=$senha_postgres
      - AUTHENTIK_POSTGRESQL__USER=postgres
    
    ## 🧠 Configuração do Redis
      - AUTHENTIK_REDIS__HOST=authentik${1:+_$1}_redis
      - AUTHENTIK_REDIS__PORT=6379

    ## 🔑 Secret Key
      - AUTHENTIK_SECRET_KEY=$secretkey_authentik
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.authentik${1:+_$1}_server.rule=Host(\`$url_authentik\`)
        - traefik.http.services.authentik${1:+_$1}_server.loadbalancer.server.port=9000
        - traefik.http.routers.authentik${1:+_$1}_server.service=authentik${1:+_$1}_server
        - traefik.http.routers.authentik${1:+_$1}_server.tls.certresolver=letsencryptresolver
        - traefik.http.routers.authentik${1:+_$1}_server.entrypoints=websecure
        - traefik.http.routers.authentik${1:+_$1}_server.tls=true

## --------------------------- ORION --------------------------- ##

  authentik${1:+_$1}_worker:
    image: ghcr.io/goauthentik/server:latest
    command: worker
   
    volumes:
    - /var/run/docker.sock:/var/run/docker.sock
    - authentik${1:+_$1}_media:/data/media
    - authentik${1:+_$1}_certs:/certs
    - authentik${1:+_$1}_templates:/templates

    networks:
      - $nome_rede_interna

    environment:
    ## 🔐 Dados de acesso
      - AUTHENTIK_BOOTSTRAP_EMAIL=$email_authentik
      - AUTHENTIK_BOOTSTRAP_PASSWORD=$senha_authentik

    ## 🐘 Configuração do PostgreSQL
      - AUTHENTIK_POSTGRESQL__HOST=postgres
      - AUTHENTIK_POSTGRESQL__NAME=authentik${1:+_$1}
      - AUTHENTIK_POSTGRESQL__PASSWORD=$senha_postgres
      - AUTHENTIK_POSTGRESQL__USER=postgres
    
    ## 🧠 Configuração do Redis
      - AUTHENTIK_REDIS__HOST=authentik${1:+_$1}_redis
      - AUTHENTIK_REDIS__PORT=6379

    ## 🔑 Secret Key
      - AUTHENTIK_SECRET_KEY=$secretkey_authentik
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  authentik${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - authentik${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  authentik${1:+_$1}_media:
    external: true
    name: authentik${1:+_$1}_media
  authentik${1:+_$1}_templates:
    external: true
    name: authentik${1:+_$1}_templates
  authentik${1:+_$1}_certs:
    external: true
    name: authentik${1:+_$1}_certs
  authentik${1:+_$1}_redis:
    external: true
    name: authentik${1:+_$1}_redis


networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Authentik"
fi

STACK_NAME="authentik${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c authentik.yaml authentik > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do authentik"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest ghcr.io/goauthentik/server:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack authentik${1:+_$1}_authentik${1:+_$1}_redis authentik${1:+_$1}_authentik${1:+_$1}_worker authentik${1:+_$1}_authentik${1:+_$1}_server 

telemetria Authentik finalizado

cd dados_vps

cat > dados_authentik${1:+_$1} <<EOL
[ AUTHENTIK ]

Dominio do authentik: https://$url_authentik

Email: $email_authentik

Senha: $senha_authentik
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ AUTHENTIK ]\e[0m"
echo ""

echo -e "\e[33mDominio do authentik:\e[97m https://$url_authentik\e[0m"
echo ""

echo -e "\e[33mEmail do authentik:\e[97m $email_authentik\e[0m"
echo ""

echo -e "\e[33mSenha do authentik:\e[97m $senha_authentik\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗██╗  ██╗███████╗ ██████╗██╗  ██╗███╗   ███╗ █████╗ ████████╗███████╗
## ██╔════╝██║  ██║██╔════╝██╔════╝██║ ██╔╝████╗ ████║██╔══██╗╚══██╔══╝██╔════╝
## ██║     ███████║█████╗  ██║     █████╔╝ ██╔████╔██║███████║   ██║   █████╗  
## ██║     ██╔══██║██╔══╝  ██║     ██╔═██╗ ██║╚██╔╝██║██╔══██║   ██║   ██╔══╝  
## ╚██████╗██║  ██║███████╗╚██████╗██║  ██╗██║ ╚═╝ ██║██║  ██║   ██║   ███████╗
##  ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝

ferramenta_checkmate() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados
pegar_senha_mongodb

## Mostra o nome da aplicação
nome_checkmate

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o Dominio para o Checkmate (ex: checkmate.oriondesign.art.br): \e[0m" && read -r url_checkmate
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite o Dominio para a API do Checkmate (ex: checkmate-api.oriondesign.art.br): \e[0m" && read -r url_checkmate_api
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_checkmate
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do checkmate:\e[97m $url_checkmate\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mDominio da API do checkmate:\e[97m $url_checkmate_api\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_checkmate

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO CHECKMATE \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Checkmate iniciado


echo -e "\e[97m• INSTALANDO CHECKMATE \e[33m[2/3]\e[0m"
echo ""
sleep 1

secretkey_checkmate=$(openssl rand -hex 16)

## Criando a stack checkmate.yaml
cat > checkmate${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  checkmate${1:+_$1}_client:
    image: ghcr.io/bluewave-labs/checkmate-client:latest

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Url do Frontend
      - UPTIME_APP_CLIENT_HOST=https://$url_checkmate

    ## 🔗 Url do Backend
      - UPTIME_APP_API_BASE_URL=https://$url_checkmate_api/api/v1
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.checkmate${1:+_$1}_client.rule=Host(\`$url_checkmate\`)
        - traefik.http.services.checkmate${1:+_$1}_client.loadbalancer.server.port=80
        - traefik.http.routers.checkmate${1:+_$1}_client.service=checkmate${1:+_$1}_client
        - traefik.http.routers.checkmate${1:+_$1}_client.tls.certresolver=letsencryptresolver
        - traefik.http.routers.checkmate${1:+_$1}_client.entrypoints=websecure
        - traefik.http.routers.checkmate${1:+_$1}_client.tls=true

## --------------------------- ORION --------------------------- ##

  checkmate${1:+_$1}_server:
    image: ghcr.io/bluewave-labs/checkmate-backend:latest

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

    networks:
       $nome_rede_interna: ## Nome da rede interna
        aliases:
          - server 

    environment:
    ## 🌐 Configurações de URLs e Hosts
      - VITE_APP_API_BASE_URL=https://$url_checkmate_api/api/v1
      - VITE_APP_CLIENT_HOST=https://$url_checkmate
      - UPTIME_APP_CLIENT_HOST=https://$url_checkmate
      - CLIENT_HOST=https://$url_checkmate

    ## ⚙️ Configurações da Aplicação
      - VITE_APP_LOG_LEVEL=info

    ## 🗄️ Configurações do Banco de Dados
      - DB_CONNECTION_STRING=mongodb://$user_mongo:$pass_mongo@mongodb:27017/checkmate${1:+_$1}?authSource=admin

    ## 🧠 Configurações do Redis
      - REDIS_URL=redis://checkmate${1:+_$1}_redis:6379

    ## 🔐 Configurações de Segurança
      - JWT_SECRET=$secretkey_checkmate

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M  
      labels:
        - traefik.enable=true
        - traefik.http.routers.checkmate${1:+_$1}_server.rule=Host(\`$url_checkmate_api\`)
        - traefik.http.services.checkmate${1:+_$1}_server.loadbalancer.server.port=52345
        - traefik.http.routers.checkmate${1:+_$1}_server.service=checkmate${1:+_$1}_server
        - traefik.http.routers.checkmate${1:+_$1}_server.tls.certresolver=letsencryptresolver
        - traefik.http.routers.checkmate${1:+_$1}_server.entrypoints=websecure
        - traefik.http.routers.checkmate${1:+_$1}_server.tls=true

## --------------------------- ORION --------------------------- ##

  checkmate${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - checkmate${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  checkmate${1:+_$1}_data:
    external: true
    name: checkmate${1:+_$1}_data
  checkmate${1:+_$1}_redis:
    external: true
    name: checkmate${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do checkmate"
fi

STACK_NAME="checkmate${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c checkmate.yaml checkmate > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do checkmate"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest ghcr.io/bluewave-labs/checkmate-client:latest ghcr.io/bluewave-labs/checkmate-backend:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack checkmate${1:+_$1}_checkmate${1:+_$1}_redis checkmate${1:+_$1}_checkmate${1:+_$1}_server checkmate${1:+_$1}_checkmate${1:+_$1}_client 

telemetria Checkmate finalizado

cd dados_vps

cat > dados_checkmate${1:+_$1} <<EOL
[ CHECKMATE ]

Dominio do checkmate: https://$url_checkmate

Dominio da API do checkmate: https://$url_checkmate_api
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ CHECKMATE ]\e[0m"
echo ""

echo -e "\e[33mDominio do checkmate:\e[97m https://$url_checkmate\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no Checkmate\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no Checkmate\e[0m"
echo ""

echo -e "\e[33mDominio da API do checkmate:\e[97m https://$url_checkmate_api\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗  ██╗███████╗██╗   ██╗███████╗ ██████╗ ██████╗ ███╗   ███╗
## ██║  ██║██╔════╝╚██╗ ██╔╝██╔════╝██╔═══██╗██╔══██╗████╗ ████║
## ███████║█████╗   ╚████╔╝ █████╗  ██║   ██║██████╔╝██╔████╔██║
## ██╔══██║██╔══╝    ╚██╔╝  ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║
## ██║  ██║███████╗   ██║   ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║
## ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝

ferramenta_heyform() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados
pegar_senha_mongodb

## Mostra o nome da aplicação
nome_heyform

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o HeyForm (ex: heyform.oriondesign.art.br): \e[0m" && read -r url_heyform
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_heyform
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do HeyForm:\e[97m $url_heyform\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_heyform

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO HEYFORM \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Heyform iniciado

echo -e "\e[97m• INSTALANDO HEYFORM \e[33m[2/3]\e[0m"
echo ""
sleep 1

sessionkey_heyform=$(openssl rand -hex 16)
encryptionkey_heyform=$(openssl rand -hex 16)

## Criando a stack heyform.yaml
cat > heyform${1:+_$1}.yaml <<EOL
version: '3.8'
services:

## --------------------------- ORION --------------------------- ##

  heyform${1:+_$1}_app:
    image: heyform/community-edition:v0.1.0

    volumes:
      - heyform${1:+_$1}_uploads:/app/static/upload

    networks:
      - $nome_rede_interna

    environment:
    ## ⚙️ Configurações da Aplicação
      - NODE_ENV=production
      - APP_LISTEN_PORT=9157
      - APP_LISTEN_HOSTNAME=0.0.0.0
      - APP_HOMEPAGE_URL=https://$url_heyform
      - APP_DISABLE_REGISTRATION=false ## false = Permite registro de novos usuarios
      
    ## 🍪 Cookies e Sessões
      - COOKIE_MAX_AGE=1y
      - COOKIE_DOMAIN=
      - SESSION_KEY=$sessionkey_heyform
      - SESSION_MAX_AGE=15d
      
    ## 🔐 Encryptation
      - FORM_ENCRYPTION_KEY=$encryptionkey_heyform
      
    ## 🗄️ Configuração do MongoDB
      - MONGO_URI=mongodb://mongodb:27017/heyform${1:+_$1}?authSource=admin
      - MONGO_USER=$user_mongo
      - MONGO_PASSWORD=$pass_mongo
      - MONGO_SSL_CA_PATH=
      
    ## 🧠 Configuração do Redis
      - REDIS_HOST=heyform${1:+_$1}_redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      - REDIS_DB=0
      
    ## 📤 Configurações de Upload de Arquivos
      - UPLOAD_FILE_SIZE=10485760
      - UPLOAD_FILE_TYPES=
      
    ## 🔑 Segurança de Senhas (Bcrypt)
      - BCRYPT_SALT=10
      
    ## 📦 Configuração da Fila de Processamento (Bull)
      - BULL_JOB_ATTEMPTS=3
      - BULL_JOB_TIMEOUT=1m
      - BULL_JOB_BACKOFF_DELAY=3000
      - BULL_JOB_BACKOFF_TYPE=fixed
      
    ## 🧩 Outras Configurações da Aplicação
      - INVITE_CODE_EXPIRE_DAYS=7
      - FORM_REPORT_RATE=5s
      - VERIFICATION_CODE_EXPIRE=10m
      - VERIFICATION_CODE_LIMIT=5
      - ACCOUNT_DELETION_SCHEDULE_INTERVAL=2d
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.heyform${1:+_$1}_app.rule=Host(\`$url_heyform\`)
        - traefik.http.services.heyform${1:+_$1}_app.loadbalancer.server.port=9157
        - traefik.http.routers.heyform${1:+_$1}_app.service=heyform${1:+_$1}_app
        - traefik.http.routers.heyform${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.heyform${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.heyform${1:+_$1}_app.tls=true

## --------------------------- ORION --------------------------- ##

  heyform${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - heyform${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  heyform${1:+_$1}_uploads:
    external: true
    name: heyform${1:+_$1}_uploads
  heyform${1:+_$1}_redis:
    external: true
    name: heyform${1:+_$1}_redis

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna


EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do heyform"
fi

STACK_NAME="heyform${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c heyform.yaml heyform > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do heyform"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest heyform/community-edition:v0.1.0

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack heyform${1:+_$1}_heyform${1:+_$1}_redis heyform${1:+_$1}_heyform${1:+_$1}_app

telemetria Heyform finalizado

cd dados_vps

cat > dados_heyform${1:+_$1} <<EOL
[ HEYFORM ]

Dominio do Heyform: https://$url_heyform
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ HEYFORM ]\e[0m"
echo ""

echo -e "\e[33mDominio do Heyform:\e[97m https://$url_heyform\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no Heyform\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no Heyform\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗    ██╗███████╗██╗  ██╗ █████╗ ███╗   ██╗
## ██║    ██║██╔════╝██║ ██╔╝██╔══██╗████╗  ██║
## ██║ █╗ ██║█████╗  █████╔╝ ███████║██╔██╗ ██║
## ██║███╗██║██╔══╝  ██╔═██╗ ██╔══██║██║╚██╗██║
## ╚███╔███╔╝███████╗██║  ██╗██║  ██║██║ ╚████║
##  ╚══╝╚══╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝

ferramenta_wekan() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados
pegar_senha_mongodb

## Mostra o nome da aplicação
nome_wekan

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o Wekan (ex: wekan.oriondesign.art.br): \e[0m" && read -r url_wekan
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_wekan
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Wekan:\e[97m $url_wekan\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_wekan

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO WEKAN \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Wekan iniciado

echo -e "\e[97m• INSTALANDO WEKAN \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack wekan.yaml
cat > wekan${1:+_$1}.yaml <<EOL
version: "3.7"
services:   

## --------------------------- ORION --------------------------- ##

  wekan${1:+_$1}:
    image: ghcr.io/wekan/wekan:latest

    volumes:
      - wekan${1:+_$1}_files:/data:rw

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Configuração da URL da Aplicação
      - ROOT_URL=https://$url_wekan

    ## 📁 Caminhos e Armazenamento
      - WRITABLE_PATH=/data

    ## 🐘 Configuração do MongoDB
      - MONGO_URL=mongodb://$user_mongo:$pass_mongo@mongodb:27017/wekan${1:+_$1}?authSource=admin
      
    ## 📧 Configuração do SMTP
      - MAIL_URL=smtp://email@dominio.com:@Senha123_@smtp.dominio.com:587
      - MAIL_FROM=Wekan Notifications <email@dominio.com>

    ## 🔗 Configuração da API
      - WITH_API=true

    ## ⚙️ Comportamento e Recursos
      - RICHER_CARD_COMMENT_EDITOR=false
      - CARD_OPENED_WEBHOOK_ENABLED=false
      - BIGEVENTS_PATTERN=NONE
      - LDAP_BACKGROUND_SYNC_INTERVAL=''
      - BROWSER_POLICY_ENABLED=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.wekan${1:+_$1}.rule=Host(\`$url_wekan\`)
        - traefik.http.services.wekan${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.routers.wekan${1:+_$1}.service=wekan${1:+_$1}
        - traefik.http.routers.wekan${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.wekan${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.wekan${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  wekan${1:+_$1}_files:
    external: true
    name: wekan${1:+_$1}_files

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna

EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Wekan"
fi

STACK_NAME="wekan${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c wekan.yaml wekan > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do wekan"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/wekan/wekan:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack wekan${1:+_$1}_wekan${1:+_$1}

telemetria Wekan finalizado

cd dados_vps

cat > dados_wekan${1:+_$1} <<EOL
[ WEKAN ]

Dominio do Wekan: https://$url_wekan
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ WEKAN ]\e[0m"
echo ""

echo -e "\e[33mDominio do Wekan:\e[97m https://$url_wekan\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no Wekan\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no Wekan\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗ ███╗   ██╗
## ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝ ████╗  ██║
## ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║  ███╗██╔██╗ ██║
## ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║╚════██║██║██║   ██║██║╚██╗██║
## ╚██████╔╝██║     ███████╗██║ ╚████║███████║██║╚██████╔╝██║ ╚████║
##  ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝

ferramenta_opensign() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados
pegar_senha_mongodb

## Mostra o nome da aplicação
nome_opensign

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o OpenSign (ex: opensign.oriondesign.art.br): \e[0m" && read -r url_opensign
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_opensign
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do OpenSign:\e[97m $url_opensign\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_opensign

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO OPENSIGN \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria OpenSign iniciado

echo -e "\e[97m• INSTALANDO OPENSIGN \e[33m[2/3]\e[0m"
echo ""
sleep 1

keymaster_opensign=$(openssl rand -hex 16)
jwtsecret_opensign=$(openssl rand -hex 16)
senha_pfx_opensign=$(openssl rand -hex 16)

KEY_FILE="/tmp/opensign_key.pem"
CERT_FILE="/tmp/opensign_cert.pem"
PFX_FILE="/tmp/opensign.pfx"

openssl req -x509 -newkey rsa:2048 \
  -keyout "$KEY_FILE" \
  -out "$CERT_FILE" \
  -days 3650 \
  -nodes \
  -subj "/C=BR/ST=SP/L=SaoPaulo/O=OpenSign/CN=${url_opensign}" \
  > /dev/null 2>&1

openssl pkcs12 -export \
  -out "$PFX_FILE" \
  -inkey "$KEY_FILE" \
  -in "$CERT_FILE" \
  -passout pass:"$senha_pfx_opensign" \
  > /dev/null 2>&1

PFX_BASE64=$(base64 "$PFX_FILE" | tr -d '\n')

rm -f "$KEY_FILE" "$CERT_FILE" "$PFX_FILE"

## Criando a stack opensign.yaml
cat > opensign${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  opensign${1:+_$1}_server:
    image: opensign/opensignserver:main
    command: ["node", "index.js"]

    networks:
      - $nome_rede_interna ## Nome da rede interna

    volumes:
      - opensign${1:+_$1}_files:/usr/src/app/files

    environment:
    ## ⚙️ Configurações da Aplicação
      - NODE_ENV=production
      - SERVER_URL=https://$url_opensign/app
      - PUBLIC_URL=https://$url_opensign
      - PARSE_MOUNT=/app
      - SERVER_HOST=0.0.0.0
      - PORT=8080

    ## 🗄️ Banco de Dados (MongoDB)
      - MONGODB_URI=mongodb://$user_mongo:$pass_mongo@mongodb:27017/OpenSignDB${1:+_$1}?authSource=admin
      - DATABASE_URI=mongodb://$user_mongo:$pass_mongo@mongodb:27017/OpenSignDB${1:+_$1}?authSource=admin
      - MONGO_URL=mongodb://$user_mongo:$pass_mongo@mongodb:27017/OpenSignDB${1:+_$1}?authSource=admin

    ## 🔐 Chaves de Segurança
      - MASTER_KEY=$keymaster_opensign
      - JWT_SECRET=$jwtsecret_opensign
      - APP_ID=opensign

    ## 📁 Configurações de Armazenamento
      - USE_LOCAL=true

    ## 📧 Configurações de SMTP
      - SMTP_ENABLE=false

    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    ## 🪪 Certificado PFX para Assinatura Digital
      - PFX_BASE64=$PFX_BASE64
      - PASS_PHRASE=$senha_pfx_opensign

    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: on-failure
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.opensign${1:+_$1}_server.rule=Host(\`$url_opensign\`) && PathPrefix(\`/app\`)
        - traefik.http.services.opensign${1:+_$1}_server.loadbalancer.server.port=8080
        - traefik.http.routers.opensign${1:+_$1}_server.service=opensign${1:+_$1}_server
        - traefik.http.routers.opensign${1:+_$1}_server.tls.certresolver=letsencryptresolver
        - traefik.http.routers.opensign${1:+_$1}_server.entrypoints=websecure
        - traefik.http.routers.opensign${1:+_$1}_server.tls=true
        - traefik.http.routers.opensign${1:+_$1}_server.priority=100

## --------------------------- ORION --------------------------- ##

  opensign${1:+_$1}_client:
    image: opensign/opensign:main

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações da Aplicação
      - NODE_ENV=production
      - REACT_APP_SERVERURL=https://$url_opensign/app
      - PUBLIC_URL=https://$url_opensign
      - REACT_APP_APPID=opensign
      - GENERATE_SOURCEMAP=false
    
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.opensign${1:+_$1}_client.rule=Host(\`$url_opensign\`) && !PathPrefix(\`/app\`)
        - traefik.http.services.opensign${1:+_$1}_client.loadbalancer.server.port=3000
        - traefik.http.routers.opensign${1:+_$1}_client.service=opensign${1:+_$1}_client
        - traefik.http.routers.opensign${1:+_$1}_client.tls.certresolver=letsencryptresolver
        - traefik.http.routers.opensign${1:+_$1}_client.entrypoints=websecure
        - traefik.http.routers.opensign${1:+_$1}_client.tls=true
        - traefik.http.routers.opensign${1:+_$1}_client.priority=50

## --------------------------- ORION --------------------------- ##

volumes:
  opensign${1:+_$1}_files:
    external: true
    name: opensign${1:+_$1}_files

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do opensign"
fi

STACK_NAME="opensign${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c opensign.yaml opensign > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do opensign"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull opensign/opensignserver:main opensign/opensign:main

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack opensign${1:+_$1}_opensign${1:+_$1}_server opensign${1:+_$1}_opensign${1:+_$1}_client

telemetria OpenSign finalizado

cd dados_vps

cat > dados_opensign${1:+_$1} <<EOL
[ OPENSIGN ]

Dominio do opensign: https://$url_opensign
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ OPENSIGN ]\e[0m"
echo ""

echo -e "\e[33mDominio do opensign:\e[97m https://$url_opensign\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no opensign\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no opensign\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗  ██████╗███╗   ███╗ ██████╗ ███████╗████████╗
## ██╔══██╗██╔═══██╗██╔════╝████╗ ████║██╔═══██╗██╔════╝╚══██╔══╝
## ██║  ██║██║   ██║██║     ██╔████╔██║██║   ██║███████╗   ██║   
## ██║  ██║██║   ██║██║     ██║╚██╔╝██║██║   ██║╚════██║   ██║   
## ██████╔╝╚██████╔╝╚██████╗██║ ╚═╝ ██║╚██████╔╝███████║   ██║   
## ╚═════╝  ╚═════╝  ╚═════╝╚═╝     ╚═╝ ╚═════╝ ╚══════╝   ╚═╝   

ferramenta_docmost() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_docmost

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o Docmost (ex: docmost.oriondesign.art.br): \e[0m" && read -r url_docmost
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_docmost
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Docmost:\e[97m $url_docmost\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_docmost

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO DOCMOST \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Docmost iniciado

# Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "docmost${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "docmost${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

echo -e "\e[97m• INSTALANDO docmost \e[33m[3/4]\e[0m"
echo ""
sleep 1

secret_docmost=$(openssl rand -hex 16)

## Criando a stack docmost.yaml
cat > docmost${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  docmost${1:+_$1}_app:
    image: docmost/docmost:latest

    volumes:
      - docmost${1:+_$1}_storage:/app/data/storage

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configurações da Aplicação
      - APP_URL=https://$url_docmost
      - PORT=3000
      - APP_SECRET=$secret_docmost
      - JWT_TOKEN_EXPIRES_IN=30d
      - DEBUG_MODE=false
      - DISABLE_TELEMETRY=true
      
    ## 🗄️ Configurações do Banco de Dados
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/docmost${1:+_$1}?schema=public
      
    ## 🧠 Configurações do Redis
      - REDIS_URL=redis://docmost${1:+_$1}_redis:6379
      
    ## 📁 Configurações de Armazenamento
      - STORAGE_DRIVER=local ## local ou s3
      - FILE_UPLOAD_SIZE_LIMIT=50mb
      #- AWS_S3_ACCESS_KEY_ID=
      #- AWS_S3_SECRET_ACCESS_KEY=
      #- AWS_S3_REGION=
      #- AWS_S3_BUCKET=
      #- AWS_S3_ENDPOINT=
      #- AWS_S3_FORCE_PATH_STYLE=
      
    ## 📧 Configurações do SMTP
      #- MAIL_DRIVER=smtp
      #- MAIL_FROM_NAME=Docmost
      #- MAIL_FROM_ADDRESS=email@dominio.com
      #- SMTP_USERNAME=email@dominio.com
      #- SMTP_PASSWORD=@Senha123_
      #- SMTP_HOST=smtp.dominio.com
      #- SMTP_PORT=587
      #- SMTP_SECURE=false
      #- SMTP_IGNORETLS=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.docmost${1:+_$1}_app.rule=Host(\`$url_docmost\`)
        - traefik.http.services.docmost${1:+_$1}_app.loadbalancer.server.port=3000
        - traefik.http.routers.docmost${1:+_$1}_app.service=docmost${1:+_$1}_app
        - traefik.http.routers.docmost${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.docmost${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.docmost${1:+_$1}_app.tls=true

## --------------------------- ORION --------------------------- ##

  docmost${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - docmost${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  docmost${1:+_$1}_storage:
    external: true
    name: docmost${1:+_$1}_storage
  docmost${1:+_$1}_redis:
    external: true
    name: docmost${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do docmost"
fi

STACK_NAME="docmost${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c docmost.yaml docmost > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do docmost"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest docmost/docmost:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack docmost${1:+_$1}_docmost${1:+_$1}_redis docmost${1:+_$1}_docmost${1:+_$1}_app

telemetria Docmost finalizado

cd dados_vps

cat > dados_docmost${1:+_$1} <<EOL
[ DOCMOST ]

Dominio do docmost: https://$url_docmost
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ DOCMOST ]\e[0m"
echo ""

echo -e "\e[33mDominio do docmost:\e[97m https://$url_docmost\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no docmost\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no docmost\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ██╗███████╗████████╗██████╗  ██████╗ ██╗  ██╗
## ████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██╔═══██╗╚██╗██╔╝
## ██╔██╗ ██║█████╗     ██║   ██████╔╝██║   ██║ ╚███╔╝ 
## ██║╚██╗██║██╔══╝     ██║   ██╔══██╗██║   ██║ ██╔██╗ 
## ██║ ╚████║███████╗   ██║   ██████╔╝╚██████╔╝██╔╝ ██╗
## ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═════╝  ╚═════╝ ╚═╝  ╚═╝

ferramenta_netbox() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_netbox

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o NetBox (ex: netbox.oriondesign.art.br): \e[0m" && read -r url_netbox
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_netbox
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do NetBox:\e[97m $url_netbox\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_netbox

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO NETBOX \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria NetBox iniciado

# Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "netbox${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "netbox${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

echo -e "\e[97m• INSTALANDO NETBOX \e[33m[3/4]\e[0m"
echo ""
sleep 1

secretkey_netbox=$(openssl rand -hex 25)
tokenpepper_netbox=$(openssl rand -hex 16)
postgres_netbox=$(openssl rand -hex 16)

## Criando a stack netbox.yaml
cat > netbox${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  netbox${1:+_$1}_app:
    image: docker.io/netboxcommunity/netbox:v4.4-3.4.2

    volumes:
      - netbox${1:+_$1}_media_files:/opt/netbox/netbox/media:rw
      - netbox${1:+_$1}_reports_files:/opt/netbox/netbox/reports:rw
      - netbox${1:+_$1}_scripts_files:/opt/netbox/netbox/scripts:rw

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do Postgres
      - DB_HOST=netbox${1:+_$1}_db
      - DB_NAME=netbox${1:+_$1}
      - DB_PASSWORD=$postgres_netbox
      - DB_USER=postgres

    ## 🧠 Configuração do Redis
      - REDIS_HOST=netbox${1:+_$1}_redis
      - REDIS_PASSWORD=
      - REDIS_DATABASE=0
      - REDIS_SSL=false
      - REDIS_INSECURE_SKIP_TLS_VERIFY=false

    ## 🚀 Configuração do Redis
      - REDIS_CACHE_HOST=netbox${1:+_$1}_redis_cache
      - REDIS_CACHE_PASSWORD=
      - REDIS_CACHE_DATABASE=1
      - REDIS_CACHE_SSL=false
      - REDIS_CACHE_INSECURE_SKIP_TLS_VERIFY=false

    ## 🔐 Segurança e Chaves
      - SECRET_KEY=$secretkey_netbox
      - API_TOKEN_PEPPER_1=$tokenpepper_netbox

    ## ⚙️ Configurações da Aplicação
      - MEDIA_ROOT=/opt/netbox/netbox/media
      - CORS_ORIGIN_ALLOW_ALL=True
      - GRAPHQL_ENABLED=true
      - WEBHOOKS_ENABLED=true
      - METRICS_ENABLED=false
      - SKIP_SUPERUSER=false

    ## 📧 Configuração de SMTP
      #- EMAIL_FROM=email@dominio.com
      #- EMAIL_USERNAME=email@dominio.com
      #- EMAIL_PASSWORD=@Senha123_
      #- EMAIL_SERVER=smtp.dominio.com
      #- EMAIL_PORT=587
      #- EMAIL_USE_SSL=false
      #- EMAIL_USE_TLS=false
      #- EMAIL_TIMEOUT=5
      #- EMAIL_SSL_CERTFILE=
      #- EMAIL_SSL_KEYFILE=

    ## 🔄 Verificação de Atualizações
      - RELEASE_CHECK_URL=https://api.github.com/repos/netbox-community/netbox/releases

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.netbox${1:+_$1}.rule=Host(\`$url_netbox\`)
        - traefik.http.services.netbox${1:+_$1}.loadbalancer.server.port=8080
        - traefik.http.routers.netbox${1:+_$1}.service=netbox${1:+_$1}
        - traefik.http.routers.netbox${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.netbox${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.netbox${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

  netbox${1:+_$1}_worker:
    image: docker.io/netboxcommunity/netbox:v4.4-3.4.2
    command:
      - /opt/netbox/venv/bin/python
      - /opt/netbox/netbox/manage.py
      - rqworker

    volumes:
      - netbox${1:+_$1}_media_files:/opt/netbox/netbox/media:rw
      - netbox${1:+_$1}_reports_files:/opt/netbox/netbox/reports:rw
      - netbox${1:+_$1}_scripts_files:/opt/netbox/netbox/scripts:rw

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do Postgres
      - DB_HOST=netbox${1:+_$1}_db
      - DB_NAME=netbox${1:+_$1}
      - DB_PASSWORD=$postgres_netbox
      - DB_USER=postgres

    ## 🧠 Configuração do Redis
      - REDIS_HOST=netbox${1:+_$1}_redis
      - REDIS_PASSWORD=
      - REDIS_DATABASE=0
      - REDIS_SSL=false
      - REDIS_INSECURE_SKIP_TLS_VERIFY=false

    ## 🚀 Configuração do Redis
      - REDIS_CACHE_HOST=netbox${1:+_$1}_redis_cache
      - REDIS_CACHE_PASSWORD=
      - REDIS_CACHE_DATABASE=1
      - REDIS_CACHE_SSL=false
      - REDIS_CACHE_INSECURE_SKIP_TLS_VERIFY=false

    ## 🔐 Segurança e Chaves
      - SECRET_KEY=$secretkey_netbox
      - API_TOKEN_PEPPER_1=$tokenpepper_netbox

    ## ⚙️ Configurações da Aplicação
      - MEDIA_ROOT=/opt/netbox/netbox/media
      - CORS_ORIGIN_ALLOW_ALL=True
      - GRAPHQL_ENABLED=true
      - WEBHOOKS_ENABLED=true
      - METRICS_ENABLED=false
      - SKIP_SUPERUSER=false

    ## 📧 Configuração de SMTP
      #- EMAIL_FROM=email@dominio.com
      #- EMAIL_USERNAME=email@dominio.com
      #- EMAIL_PASSWORD=@Senha123_
      #- EMAIL_SERVER=smtp.dominio.com
      #- EMAIL_PORT=587
      #- EMAIL_USE_SSL=false
      #- EMAIL_USE_TLS=false
      #- EMAIL_TIMEOUT=5
      #- EMAIL_SSL_CERTFILE=
      #- EMAIL_SSL_KEYFILE=

    ## 🔄 Verificação de Atualizações
      - RELEASE_CHECK_URL=https://api.github.com/repos/netbox-community/netbox/releases

    deploy:
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 10
        window: 120s
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  netbox${1:+_$1}_db:
    image: docker.io/postgres:17-alpine

    volumes:
      - netbox${1:+_$1}_db:/var/lib/postgresql/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do Postgres
      - POSTGRES_DB=netbox${1:+_$1}
      - POSTGRES_PASSWORD=$postgres_netbox

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  netbox${1:+_$1}_redis:
    image: docker.io/valkey/valkey:8.1-alpine
    command: [
        "valkey-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - netbox${1:+_$1}_redis_data:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  netbox${1:+_$1}_redis_cache:
    image: docker.io/valkey/valkey:8.1-alpine
    command: [
        "valkey-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]
    
    volumes:
      - netbox${1:+_$1}_redis_cache_data:/data
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  netbox${1:+_$1}_media_files:
    external: true
    name: netbox${1:+_$1}_media_files
  netbox${1:+_$1}_db:
    external: true
    name: netbox${1:+_$1}_db
  netbox${1:+_$1}_redis_cache_data:
    external: true
    name: netbox${1:+_$1}_redis_cache_data
  netbox${1:+_$1}_redis_data:
    external: true
    name: netbox${1:+_$1}_redis_data
  netbox${1:+_$1}_reports_files:
    external: true
    name: netbox${1:+_$1}_reports_files
  netbox${1:+_$1}_scripts_files:
    external: true
    name: netbox${1:+_$1}_scripts_files

networks:
  $nome_rede_interna: ## Nome da rede interna
    name: $nome_rede_interna ## Nome da rede interna
    external: true
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do netbox"
fi

STACK_NAME="netbox${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c netbox.yaml netbox > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do netbox"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull docker.io/postgres:17-alpine docker.io/valkey/valkey:8.1-alpine docker.io/netboxcommunity/netbox:v4.4-3.4.2

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack netbox${1:+_$1}_netbox${1:+_$1}_db netbox${1:+_$1}_netbox${1:+_$1}_redis netbox${1:+_$1}_netbox${1:+_$1}_redis_cache netbox${1:+_$1}_netbox${1:+_$1}_app  netbox${1:+_$1}_netbox${1:+_$1}_worker

telemetria NetBox finalizado

cd dados_vps

cat > dados_netbox${1:+_$1} <<EOL
[ NETBOX ]

Dominio do NetBox: https://$url_netbox

Usuario: admin

Senha: admin
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ NETBOX ]\e[0m"
echo ""

echo -e "\e[33mDominio do NetBox:\e[97m https://$url_netbox\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m admin\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m admin\e[0m"
echo ""

echo -e "\e[33mBiblioteca de Modelos de Dispositivos (BONUS):\e[97m https://github.com/netbox-community/devicetype-library\e[0m"
echo ""

echo -e "\e[97mObservação:\e[33m Aguarde 5 minutos antes de acessar o NetBox devido as migrações\e[0m"
echo -e "\e[33mque levam um certo tempo para serem concluidas\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██╗  ██╗ █████╗ ███████╗██╗  ██╗ █████╗ 
## ██║ ██╔╝██╔══██╗██╔════╝██║ ██╔╝██╔══██╗
## █████╔╝ ███████║█████╗  █████╔╝ ███████║
## ██╔═██╗ ██╔══██║██╔══╝  ██╔═██╗ ██╔══██║
## ██║  ██╗██║  ██║██║     ██║  ██╗██║  ██║
## ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝

ferramenta_kafka() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_kafka

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o Kafka (ex: kafka.oriondesign.art.br): \e[0m" && read -r url_kafka
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite o Usuario para o Kafka (ex: admin): \e[0m" && read -r user_ntfy
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite a Senha para o Kafka (ex: @Senha123_): \e[0m" && read -r pass_ntfy
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_kafka
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Kafka:\e[97m $url_kafka\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUsuario do Kafka:\e[97m $user_ntfy\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do Kafka:\e[97m $pass_ntfy\e[0m"
    echo ""
    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_kafka

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO KAFKA \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Kafka iniciado

echo -e "\e[97m• INSTALANDO KAFKA \e[33m[2/3]\e[0m"
echo ""
sleep 1

cluster_kafka=$(openssl rand -base64 16 | tr -d "=+/" | head -c 22)

senha_kafka=$(htpasswd -nb $user_ntfy $pass_ntfy | sed -e s/\\$/\\$\\$/g)

## Criando a stack kafka.yaml
cat > kafka${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  kafka${1:+_$1}_broker:
    image: apache/kafka:latest

    volumes:
      - kafka${1:+_$1}_data:/var/lib/kafka/data
      - kafka${1:+_$1}_logs:/var/log/kafka

    networks:
      - $nome_rede_interna ## Nome da rede interna
    #ports:
    #  - "9092:9092"
    #  - "19092:19092"  # JMX para monitoramento

    environment:
    ## ⚙️ Configurações do Kafka
      - KAFKA_BROKER_ID=1
      - KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka${1:+_$1}_broker:9092
      - KAFKA_PROCESS_ROLES=broker,controller
      - KAFKA_NODE_ID=1
      - KAFKA_CONTROLLER_QUORUM_VOTERS=1@kafka${1:+_$1}_broker:9093
      - KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093
      - KAFKA_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_LOG_DIRS=/var/lib/kafka/data
      - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      - CLUSTER_ID=$cluster_kafka

    ## 🚀 Otimizações de Performance
      - KAFKA_NUM_NETWORK_THREADS=8
      - KAFKA_NUM_IO_THREADS=16
      - KAFKA_NUM_REPLICA_FETCHERS=4

    ## 🌐 Buffers de Rede
      - KAFKA_SOCKET_SEND_BUFFER_BYTES=102400
      - KAFKA_SOCKET_RECEIVE_BUFFER_BYTES=102400
      - KAFKA_REPLICA_SOCKET_RECEIVE_BUFFER_BYTES=65536

    ## 🧾 Logs e Segmentação
      - KAFKA_LOG_SEGMENT_BYTES=1073741824
      - KAFKA_LOG_RETENTION_HOURS=24
      - KAFKA_LOG_RETENTION_BYTES=1073741824

    ## 📦 Compressão e Batching
      - KAFKA_COMPRESSION_TYPE=lz4
      - KAFKA_BATCH_SIZE=200000
      - KAFKA_LINGER_MS=100

    ## 🧩 Partições e Paralelismo
      - KAFKA_NUM_PARTITIONS=12
      - KAFKA_DEFAULT_REPLICATION_FACTOR=1

    ## 🧠 JVM Otimizada
      - KAFKA_HEAP_OPTS=-Xms1G -Xmx1G
      - KAFKA_JVM_PERFORMANCE_OPTS=-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:MaxInlineLevel=15 -Djava.awt.headless=true

    ## 📊 Monitoramento via JMX
      - KAFKA_JMX_PORT=19092
      - KAFKA_JMX_HOSTNAME=0.0.0.0

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  kafka${1:+_$1}_ui:
    image: provectuslabs/kafka-ui:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🧩 Configuração do Cluster Kafka
      - KAFKA_CLUSTERS_0_NAME=setuporion
      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka${1:+_$1}_broker:9092
      - KAFKA_CLUSTERS_0_JMXPORT=19092
      - KAFKA_CLUSTERS_0_JMXHOST=kafka${1:+_$1}_broker
    
    ## ⚙️ Configurações Dinâmicas
      - DYNAMIC_CONFIG_ENABLED=true

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M     
      labels:
        - traefik.enable=true
        - traefik.http.routers.kafka${1:+_$1}_ui.rule=Host(\`$url_kafka\`)
        - traefik.http.routers.kafka${1:+_$1}_ui.entrypoints=websecure
        - traefik.http.routers.kafka${1:+_$1}_ui.tls=true
        - traefik.http.routers.kafka${1:+_$1}_ui.tls.certresolver=letsencryptresolver
        - traefik.http.routers.kafka${1:+_$1}_ui.service=kafka${1:+_$1}_ui
        - traefik.http.routers.kafka${1:+_$1}_ui.middlewares=kafka${1:+_$1}_ui_auth
        - traefik.http.services.kafka${1:+_$1}_ui.loadbalancer.server.port=8080
        - traefik.http.middlewares.kafka${1:+_$1}_ui_auth.basicauth.users=$senha_kafka

## --------------------------- ORION --------------------------- ##

volumes:
  kafka${1:+_$1}_data:
    external: true
    name: kafka${1:+_$1}_data
  kafka${1:+_$1}_logs:
    external: true
    name: kafka${1:+_$1}_logs

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do Kafka"
fi

STACK_NAME="kafka${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c kafka.yaml kafka > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do kafka"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull apache/kafka:latest provectuslabs/kafka-ui:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack kafka${1:+_$1}_kafka${1:+_$1}_broker kafka${1:+_$1}_kafka${1:+_$1}_ui

telemetria Kafka finalizado

cd dados_vps

cat > dados_kafka${1:+_$1} <<EOL
[ KAFKA ]

Dominio do Kafka: https://$url_kafka
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ KAFKA ]\e[0m"
echo ""

echo -e "\e[33mDominio do kafka:\e[97m https://$url_kafka\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa criar no kafka\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa criar no kafka\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  █████╗ ███████╗████████╗██████╗  █████╗             
## ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗            
## ███████║███████╗   ██║   ██████╔╝███████║            
## ██╔══██║╚════██║   ██║   ██╔══██╗██╔══██║            
## ██║  ██║███████║   ██║   ██║  ██║██║  ██║            
## ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝            
##                                                                  
##  ██████╗ █████╗ ███╗   ███╗██████╗  █████╗ ██╗ ██████╗ ███╗   ██╗
## ██╔════╝██╔══██╗████╗ ████║██╔══██╗██╔══██╗██║██╔════╝ ████╗  ██║
## ██║     ███████║██╔████╔██║██████╔╝███████║██║██║  ███╗██╔██╗ ██║
## ██║     ██╔══██║██║╚██╔╝██║██╔═══╝ ██╔══██║██║██║   ██║██║╚██╗██║
## ╚██████╗██║  ██║██║ ╚═╝ ██║██║     ██║  ██║██║╚██████╔╝██║ ╚████║
##  ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝

ferramenta_astracampaign() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_astracampaign

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o AstraCampaign (ex: astracampaign.oriondesign.art.br): \e[0m" && read -r url_astracampaign
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_astracampaign
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do AstraCampaign:\e[97m $url_astracampaign\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_astracampaign

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO ASTRACAMPAIGN \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria AstraCampaign iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "astracampaign${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "astracampaign${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

echo -e "\e[97m• INSTALANDO ASTRACAMPAIGN \e[33m[3/4]\e[0m"
echo ""
sleep 1

jwtsecret_astracampaign=$(openssl rand -hex 16)

## Criando a stack astracampaign.yaml
cat > astracampaign${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  astracampaign${1:+_$1}_backend:
    image: astraonline/astracampaignbackend:latest

    volumes:
      - astracampaign${1:+_$1}_contacts:/app/data
      - astracampaign${1:+_$1}_uploads:/app/uploads
      - astracampaign${1:+_$1}_backup:/app/backups

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🗄️ Configuração do Postgres
      - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/astracampaign${1:+_$1}
    
    ## 🔁 Configuração do Redis
      - REDIS_URL=redis://astracampaign${1:+_$1}_redis:6379
      - REDIS_PREFIX=work_app

    ## 🌐 Configuração do Servidor
      - PORT=3001
      - NODE_ENV=production
    
    ## 🔐 Configuração de Autenticação (JWT)
      - JWT_SECRET=$jwtsecret_astracampaign
      - JWT_EXPIRES_IN=24h
    
    ## 🏢 Configuração da Aplicação
      - DEFAULT_COMPANY_NAME=SetupOrion
      - DEFAULT_PAGE_TITLE=Sistema de Gestão de Contatos - By AstraOnline

    ## 🔓 Configuração de CORS
      - ALLOWED_ORIGINS=https://$url_astracampaign,http://$url_astracampaign,http://astracampaign${1:+_$1}_frontend,http://astracampaign${1:+_$1}_frontend:80

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.work-backend.rule=Host(\`$url_astracampaign\`) && PathPrefix(\`/api\`)
        - traefik.http.services.work-backend.loadbalancer.server.port=3001
        - traefik.http.routers.work-backend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.work-backend.entrypoints=websecure
        - traefik.http.routers.work-backend.tls=true
        - traefik.docker.network=$nome_rede_interna

## --------------------------- ORION --------------------------- ##

  astracampaign${1:+_$1}_frontend:
    image: astraonline/astracampaignfrontend:latest

    networks:
      - $nome_rede_interna ## Nome da rede interna

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.work-frontend.rule=Host(\`$url_astracampaign\`)
        - traefik.http.services.work-frontend.loadbalancer.server.port=80
        - traefik.http.routers.work-frontend.tls.certresolver=letsencryptresolver
        - traefik.http.routers.work-frontend.entrypoints=websecure
        - traefik.http.routers.work-frontend.tls=true
        - traefik.docker.network=$nome_rede_interna

## --------------------------- ORION --------------------------- ##

  astracampaign${1:+_$1}_redis:
    image: redis:latest  ## Versão do Redis
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]

    volumes:
      - astracampaign${1:+_$1}_redis:/data

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ## Descomente as linhas abaixo para uso externo
    #ports:
    #  - 6379:6379

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

volumes:
  astracampaign${1:+_$1}_contacts:
    external: true
    name: astracampaign${1:+_$1}_contacts
  astracampaign${1:+_$1}_uploads:
    external: true
    name: astracampaign${1:+_$1}_uploads
  astracampaign${1:+_$1}_backup:
    external: true
    name: astracampaign${1:+_$1}_backup
  astracampaign${1:+_$1}_redis:
    external: true
    name: astracampaign${1:+_$1}_redis

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do AstraCampaign"
fi

STACK_NAME="astracampaign${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c astracampaign.yaml astracampaign > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do astracampaign"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull redis:latest astraonline/astracampaignbackend:latest astraonline/astracampaignfrontend:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack astracampaign${1:+_$1}_astracampaign${1:+_$1}_redis astracampaign${1:+_$1}_astracampaign${1:+_$1}_backend astracampaign${1:+_$1}_astracampaign${1:+_$1}_frontend

telemetria AstraCampaign finalizado

cd dados_vps

cat > dados_astracampaign${1:+_$1} <<EOL
[ ASTRACAMPAIGN ]

Dominio do AstraCampaign: https://$url_astracampaign

Email: superadmin@astraonline.com.br

Senha: Admin123
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ASTRACAMPAIGN ]\e[0m"
echo ""

echo -e "\e[33mDominio do astracampaign:\e[97m https://$url_astracampaign\e[0m"
echo ""

echo -e "\e[33mEmail:\e[97m superadmin@astraonline.com.br\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Admin123\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗ ██╗   ██╗██████╗ ██╗     ██╗ ██████╗ █████╗ ████████╗██╗
## ██╔══██╗██║   ██║██╔══██╗██║     ██║██╔════╝██╔══██╗╚══██╔══╝██║
## ██║  ██║██║   ██║██████╔╝██║     ██║██║     ███████║   ██║   ██║
## ██║  ██║██║   ██║██╔═══╝ ██║     ██║██║     ██╔══██║   ██║   ██║
## ██████╔╝╚██████╔╝██║     ███████╗██║╚██████╗██║  ██║   ██║   ██║
## ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝╚═╝ ╚═════╝╚═╝  ╚═╝   ╚═╝   ╚═╝

ferramenta_duplicati() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_duplicati

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/2\e[0m"
    echo -en "\e[33mDigite o Dominio para o Duplicati (ex: duplicati.oriondesign.art.br): \e[0m" && read -r url_duplicati
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/2\e[0m"
    echo -en "\e[33mDigite a Senha para acessar o Duplicati (ex: @Senha123_): \e[0m" && read -r pass_duplicati
    echo ""

    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_duplicati
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ## Informação sobre URL
    echo -e "\e[33mDominio do Duplicati:\e[97m $url_duplicati\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do Duplicati:\e[97m $pass_duplicati\e[0m"
    echo ""

    
    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_duplicati

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO DUPLICATI \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Duplicati iniciado

echo -e "\e[97m• INSTALANDO DUPLICATI \e[33m[2/3]\e[0m"
echo ""
sleep 1

encryptionkey_duplicati=$(openssl rand -hex 16)

## Criando a stack duplicati.yaml
cat > duplicati${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  duplicati${1:+_$1}:
    image: duplicati/duplicati:latest

    volumes:
      - duplicati${1:+_$1}_data:/data
      - duplicati${1:+_$1}_backups:/backups
      - /var/lib/docker/volumes:/docker/volumes:rw ## Permite acessar os volumes do Docker
      - /root:/root:rw ## Permite acessar o /root
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## ⚙️ Configuração básica do webservice
      - DUPLICATI__WEBSERVICE_PORT=8200
      - DUPLICATI__WEBSERVICE_INTERFACE=any
      - XDG_CONFIG_HOME=/data
      
    ## 🔐 Segurança e Autenticação
      - DUPLICATI__WEBSERVICE_ALLOWED_HOSTNAMES=$url_duplicati
      - DUPLICATI__WEBSERVICE_PASSWORD=$pass_duplicati
      
    ## 🔐 Criptografia do Banco de Dados
      - DUPLICATI__DISABLE_DB_ENCRYPTION=false   
      - DUPLICATI__REQUIRE_DB_ENCRYPTION_KEY=true
      - SETTINGS_ENCRYPTION_KEY=$encryptionkey_duplicati

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager      
      labels:
        - traefik.enable=true
        - traefik.http.routers.duplicati${1:+_$1}.rule=Host(\`$url_duplicati\`)
        - traefik.http.routers.duplicati${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.duplicati${1:+_$1}.priority=1
        - traefik.http.routers.duplicati${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.duplicati${1:+_$1}.service=duplicati${1:+_$1}
        - traefik.http.services.duplicati${1:+_$1}.loadBalancer.server.port=8200
        - traefik.http.services.duplicati${1:+_$1}.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  duplicati${1:+_$1}_data:
    external: true
    name: duplicati${1:+_$1}_data
  duplicati${1:+_$1}_backups:
    external: true
    name: duplicati${1:+_$1}_backups

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do duplicati"
fi

STACK_NAME="duplicati${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c duplicati.yaml duplicati > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do duplicati"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull duplicati/duplicati:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack duplicati${1:+_$1}_duplicati${1:+_$1}

telemetria Duplicati finalizado

cd dados_vps

cat > dados_duplicati${1:+_$1} <<EOL
[ DUPLICATI ]

Dominio do Duplicati: https://$url_duplicati

Senha do Duplicati: $pass_duplicati
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ DUPLICATI ]\e[0m"
echo ""

echo -e "\e[33mDominio do Duplicati:\e[97m https://$url_duplicati\e[0m"
echo ""

echo -e "\e[33mSenha do Duplicati:\e[97m $pass_duplicati\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  ██████╗ ██████╗  █████╗  ██████╗██╗  ██╗██╗    ██╗███████╗██████╗ 
## ██╔══██╗██╔════╝ ██╔══██╗██╔══██╗██╔════╝██║ ██╔╝██║    ██║██╔════╝██╔══██╗
## ██████╔╝██║  ███╗██████╔╝███████║██║     █████╔╝ ██║ █╗ ██║█████╗  ██████╔╝
## ██╔═══╝ ██║   ██║██╔══██╗██╔══██║██║     ██╔═██╗ ██║███╗██║██╔══╝  ██╔══██╗
## ██║     ╚██████╔╝██████╔╝██║  ██║╚██████╗██║  ██╗╚███╔███╔╝███████╗██████╔╝
## ╚═╝      ╚═════╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝ ╚══╝╚══╝ ╚══════╝╚═════╝ 

ferramenta_pgbackweb() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_pgbackweb

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o PgBackWeb (ex: pgbackweb.oriondesign.art.br): \e[0m" && read -r url_pgbackweb
    echo ""

    ## Limpa o terminal
    clear

    ## Mostra o nome da aplicação
    nome_pgbackweb

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do PgBackWeb:\e[97m $url_pgbackweb\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_pgbackweb

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PGBACKWEB \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria PgBackWeb iniciado

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO/INSTALANDO POSTGRES \e[33m[2/4]\e[0m"
echo ""
sleep 1

## Aqui vamos fazer uma verificação se já existe Postgres Instalado
## Se tiver ele vai criar um banco de dados no postgres ou perguntar se deseja apagar o que já existe e criar outro

## Verifica container postgres e cria banco no postgres

verificar_container_postgres
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Postgres já instalado"
    pegar_senha_postgres > /dev/null 2>&1
    echo "2/3 - [ OK ] - Copiando senha do Postgres"
    criar_banco_postgres_da_stack "pgbackweb${1:+_$1}"
    echo "3/3 - [ OK ] - Criando banco de dados"
    echo ""
else
    ferramenta_postgres
    pegar_senha_postgres > /dev/null 2>&1
    criar_banco_postgres_da_stack "pgbackweb${1:+_$1}"
fi

pegar_senha_postgres > /dev/null 2>&1

echo -e "\e[97m• INSTALANDO PGBACKWEB \e[33m[3/4]\e[0m"
echo ""
sleep 1

encryptionkey_pgbackweb=$(openssl rand -hex 16)

## Criando a stack pgbackweb.yaml
cat > pgbackweb${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  pgbackweb${1:+_$1}:
    image: eduardolat/pgbackweb:latest

    volumes:
      - pgbackweb${1:+_$1}_backups:/backups #Pasta backups locais caso nao utilize Minio S3

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🔐 Criptografia e Segurança
      - PBW_ENCRYPTION_KEY=$encryptionkey_pgbackweb #Chave criptografia
    
    ## 🗄️ Configuração do PostgreSQL
      - PBW_POSTGRES_CONN_STRING=postgresql://postgres:$senha_postgres@postgres:5432/pgbackweb${1:+_$1}?sslmode=disable
    
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo #Fuso horario

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.pgbackweb${1:+_$1}.rule=Host(\`$url_pgbackweb\`) ## Url da aplicação
        - traefik.http.services.pgbackweb${1:+_$1}.loadbalancer.server.port=8085
        - traefik.http.routers.pgbackweb${1:+_$1}.service=pgbackweb${1:+_$1}
        - traefik.http.routers.pgbackweb${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.pgbackweb${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.pgbackweb${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  pgbackweb${1:+_$1}_backups:
    external: true
    name: pgbackweb${1:+_$1}_backups

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do pgbackweb"
fi

STACK_NAME="pgbackweb${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c pgbackweb.yaml pgbackweb > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do pgbackweb"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull eduardolat/pgbackweb:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack pgbackweb${1:+_$1}_pgbackweb${1:+_$1}

telemetria PgBackWeb finalizado

cd dados_vps

cat > dados_pgbackweb${1:+_$1} <<EOL
[ PGBACKWEB ]

Dominio do PgBackWeb: https://$url_pgbackweb
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PGBACKWEB ]\e[0m"
echo ""

echo -e "\e[33mDominio do pgbackweb:\e[97m https://$url_pgbackweb\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar no PgBackWeb\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar no PgBackWeb\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##      ██╗██╗████████╗███████╗██╗
##      ██║██║╚══██╔══╝██╔════╝██║
##      ██║██║   ██║   ███████╗██║
## ██   ██║██║   ██║   ╚════██║██║
## ╚█████╔╝██║   ██║   ███████║██║
##  ╚════╝ ╚═╝   ╚═╝   ╚══════╝╚═╝

ferramenta_jitsi() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_jitsi

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/4\e[0m"
    echo -en "\e[33mDigite o Dominio para o Jitsi (ex: jitsi.oriondesign.art.br): \e[0m" && read -r url_jitsi
    echo ""

    read -r ip _ <<<$(hostname -I | tr ' ' '\n' | grep -v '^127\.0\.0\.1' | grep -v '^10\.0\.0\.' | tr '\n' ' ')

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/4\e[0m"
    echo -en "\e[33mDigite o IP Publico da VPS (ex: $ip): \e[0m" && read -r ip_jitsi
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/4\e[0m"
    echo -en "\e[33mDigite o Usuario para o Jitsi (ex: admin): \e[0m" && read -r user_jitsi
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 4/4\e[0m"
    echo -en "\e[33mDigite a Senha para o Jitsi (ex: @Senha123_): \e[0m" && read -r pass_jitsi
    echo ""

    ## Limpa o terminal
    clear

    ## Mostra o nome da aplicação
    nome_jitsi

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do Jitsi:\e[97m $url_jitsi\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mIP da VPS:\e[97m $ip_jitsi\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mUsuario do Jitsi:\e[97m $user_jitsi\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha do Jitsi:\e[97m $pass_jitsi\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_jitsi

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO JITSI \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria Jitsi iniciado

echo -e "\e[97m• INSTALANDO JITSI \e[33m[2/4]\e[0m"
echo ""
sleep 1

jicofo_secret_jitsi=$(openssl rand -hex 16)
jicofo_component_jitsi=$(openssl rand -hex 16)
jvb_auth_jitsi=$(openssl rand -hex 16)

## Criando a stack jitsi.yaml
cat > jitsi${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  jitsi${1:+_$1}_web:
    image: jitsi/web:stable

    networks:
      - $nome_rede_interna ## Nome da rede interna

    volumes:
      - jitsi${1:+_$1}_web_config:/config:Z
      - jitsi${1:+_$1}_web_crontabs:/var/spool/cron/crontabs:Z
      - jitsi${1:+_$1}_transcripts:/usr/share/jitsi-meet/transcripts:Z

    environment:
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    ## 🔐 Autenticação e Acesso
      - ENABLE_AUTH=1 ## Ativa autenticação (secure-domain)
      - AUTH_TYPE=internal ## Backend de auth do Prosody (interno)
      - ENABLE_GUESTS=1 ## Convidados entram após a sala existir
      - ENABLE_LOBBY=1 ## Lobby disponível
      - PUBLIC_URL=https://$url_jitsi ## URL pública de acesso

    ## 📄 Páginas e Fluxo de Entrada/Saída
      - ENABLE_PREJOIN_PAGE=1 ## Tela de pré-entrada (checar áudio/vídeo, nome)
      - ENABLE_WELCOME_PAGE=1 ## Sem página inicial; "/" cria sala automaticamente
      - ENABLE_CLOSE_PAGE=1 ## Mostra página “reunião encerrada”

    ## 📞 Recursos de Sala e Moderação
      - ENABLE_BREAKOUT_ROOMS=1 ## Salas paralelas
      - ENABLE_AV_MODERATION=1 ## Moderação de áudio/vídeo
      - ENABLE_END_CONFERENCE=1 ## Moderador pode encerrar reunião
      - ENABLE_REQUIRE_DISPLAY_NAME=1 ## Obriga digitar nome

    ## 📹 Recursos de Gravação e Transcrição
      - ENABLE_RECORDING=0 ## Gravação via Jibri (infra extra) – deixe 0 se não tiver
      - ENABLE_FILE_RECORDING_SHARING=0 ## Compartilhar arquivo de gravação (se usar Jibri)
      - ENABLE_TRANSCRIPTIONS=0 ## Transcrições via Jigasi/STT (infra extra) – deixe 0

    ## 💬 Interatividade e Engajamento
      - ENABLE_POLLS=1 ## Enquetes
      - ENABLE_REACTIONS=1 ## Reações
      - ENABLE_RAISE_HAND=1 ## Levantar mão

    ## 🎧 Conexão e Qualidade de Áudio/Vídeo
      - ENABLE_P2P=1 ## P2P quando só 2 participantes
      - ENABLE_NOISE_SUPPRESSION=1 ## Supressão de ruído (client-side)
      - ENABLE_STEREO=0 ## Áudio estéreo (consome mais banda)
      - ENABLE_TALK_WHILE_MUTED=1 ## Aviso ao falar no mudo
      - ENABLE_NO_AUDIO_DETECTION=1      ## Aviso quando não há áudio

    ## 📄 Configuração do XMPP/Prosody
      - XMPP_SERVER=jitsi${1:+_$1}_prosody
      - XMPP_DOMAIN=meet.jitsi
      - XMPP_AUTH_DOMAIN=auth.meet.jitsi
      - XMPP_GUEST_DOMAIN=guest.meet.jitsi
      - XMPP_MUC_DOMAIN=muc.meet.jitsi
      - XMPP_BOSH_URL_BASE=http://jitsi${1:+_$1}_prosody:5280
      - ENABLE_XMPP_WEBSOCKET=1

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.jitsi${1:+_$1}_web.rule=Host(\`$url_jitsi\`)
        - traefik.http.services.jitsi${1:+_$1}_web.loadbalancer.server.port=80
        - traefik.http.routers.jitsi${1:+_$1}_web.service=jitsi${1:+_$1}_web
        - traefik.http.routers.jitsi${1:+_$1}_web.tls.certresolver=letsencryptresolver
        - traefik.http.routers.jitsi${1:+_$1}_web.entrypoints=websecure
        - traefik.http.routers.jitsi${1:+_$1}_web.tls=true

## --------------------------- ORION --------------------------- ##

  jitsi${1:+_$1}_prosody:
    image: jitsi/prosody:stable

    volumes:
      - jitsi${1:+_$1}_prosody_config:/config:Z
      - jitsi${1:+_$1}_prosody_plugins:/prosody-plugins-custom:Z

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    ## 🔐 Autenticação e Acesso
      - ENABLE_AUTH=1
      - AUTH_TYPE=internal
      - ENABLE_GUESTS=1

    ## 🔐 Credenciais do Jicofo e JVB
      - JICOFO_AUTH_USER=focus
      - JICOFO_AUTH_PASSWORD=$jicofo_secret_jitsi
      - JICOFO_COMPONENT_SECRET=$jicofo_component_jitsi
      - JVB_AUTH_USER=jvb
      - JVB_AUTH_PASSWORD=$jvb_auth_jitsi

    ## 📄 Configuração do XMPP/Prosody
      - XMPP_DOMAIN=meet.jitsi
      - XMPP_AUTH_DOMAIN=auth.meet.jitsi
      - XMPP_GUEST_DOMAIN=guest.meet.jitsi
      - XMPP_MUC_DOMAIN=muc.meet.jitsi
      - XMPP_INTERNAL_MUC_DOMAIN=internal-muc.meet.jitsi
      - ENABLE_XMPP_WEBSOCKET=1

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  jitsi${1:+_$1}_jicofo:
    image: jitsi/jicofo:stable

    volumes:
      - jitsi${1:+_$1}_jicofo_config:/config:Z

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    ## 🔐 Autenticação e Acesso
      - ENABLE_AUTH=1
      - AUTH_TYPE=internal

    ## 🔐 Credenciais do Jicofo
      - JICOFO_COMPONENT_SECRET=$jicofo_component_jitsi
      - JICOFO_AUTH_USER=focus
      - JICOFO_AUTH_PASSWORD=$jicofo_secret_jitsi

    ## 📄 Configuração do XMPP/Prosody
      - XMPP_DOMAIN=meet.jitsi
      - XMPP_SERVER=jitsi${1:+_$1}_prosody
      - XMPP_AUTH_DOMAIN=auth.meet.jitsi

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

## --------------------------- ORION --------------------------- ##

  jitsi${1:+_$1}_jvb:
    image: jitsi/jvb:stable

    volumes:
      - jitsi${1:+_$1}_jvb_config:/config:Z

    networks:
      - $nome_rede_interna ## Nome da rede interna
    ports:
      - target: 10000
        published: 10000
        protocol: udp
        mode: host
      - target: 4443
        published: 4443
        protocol: tcp
        mode: host

    environment:
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    ## 🔐 Credenciais do JVB
      - JVB_AUTH_USER=jvb
      - JVB_AUTH_PASSWORD=$jvb_auth_jitsi
      - JVB_BREWERY_MUC=jvbbrewery

    ## 📡 Portas de mídia
      - JVB_PORT=10000
      - JVB_TCP_PORT=4443
      - JVB_TCP_HARVESTER_DISABLED=false

    ## 🌐 Endereço público (para ICE / NAT)
      - DOCKER_HOST_ADDRESS=$ip_jitsi
      - JVB_ADVERTISE_IPS=$ip_jitsi

    ## 📡 Servidor STUN para candidatos reflexivos (ajuda NAT)
      - JVB_STUN_SERVERS=stun.l.google.com:19302

    ## 📄 Configuração do XMPP/Prosody
      - XMPP_SERVER=jitsi${1:+_$1}_prosody
      - XMPP_DOMAIN=meet.jitsi
      - XMPP_AUTH_DOMAIN=auth.meet.jitsi
      - XMPP_INTERNAL_MUC_DOMAIN=internal-muc.meet.jitsi

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 2048M

## --------------------------- ORION --------------------------- ##

volumes:
  jitsi${1:+_$1}_web_config:
    external: true
    name: jitsi${1:+_$1}_web_config
  jitsi${1:+_$1}_web_crontabs:
    external: true
    name: jitsi${1:+_$1}_web_crontabs
  jitsi${1:+_$1}_transcripts:
    external: true
    name: jitsi${1:+_$1}_transcripts
  jitsi${1:+_$1}_prosody_config:
    external: true
    name: jitsi${1:+_$1}_prosody_config
  jitsi${1:+_$1}_prosody_plugins:
    external: true
    name: jitsi${1:+_$1}_prosody_plugins
  jitsi${1:+_$1}_jicofo_config:
    external: true
    name: jitsi${1:+_$1}_jicofo_config
  jitsi${1:+_$1}_jvb_config:
    external: true
    name: jitsi${1:+_$1}_jvb_config

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna

EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do jitsi"
fi

STACK_NAME="jitsi${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c jitsi.yaml jitsi > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do jitsi"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull jitsi/web:stable jitsi/prosody:stable jitsi/jicofo:stable jitsi/jvb:stable

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack jitsi${1:+_$1}_jitsi${1:+_$1}_web jitsi${1:+_$1}_jitsi${1:+_$1}_prosody jitsi${1:+_$1}_jitsi${1:+_$1}_jicofo jitsi${1:+_$1}_jitsi${1:+_$1}_jvb


## Mensagem de Passo
echo -e "\e[97m• CRIANDO USUARIO \e[33m[4/4]\e[0m"
echo ""
sleep 1

docker exec -t "$(docker ps --filter "name=jitsi${1:+_$1}_prosody" -q)" bash -c "prosodyctl --config /config/prosody.cfg.lua register $user_jitsi meet.jitsi $pass_jitsi"

telemetria Jitsi finalizado

cd dados_vps

cat > dados_jitsi${1:+_$1} <<EOL
[ JITSI ]

Dominio do jitsi: https://$url_jitsi

Usuario: $user_jitsi

Senha: $pass_jitsi
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ JITSI ]\e[0m"
echo ""

echo -e "\e[33mDominio do jitsi:\e[97m https://$url_jitsi\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $user_jitsi\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $pass_jitsi\e[0m"
echo ""

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗ ██████╗ ███████╗    ███████╗███████╗██████╗ ██╗   ██╗███████╗██████╗ 
## ██╔════╝██╔═══██╗██╔══██╗██╔════╝    ██╔════╝██╔════╝██╔══██╗██║   ██║██╔════╝██╔══██╗
## ██║     ██║   ██║██║  ██║█████╗      ███████╗█████╗  ██████╔╝██║   ██║█████╗  ██████╔╝
## ██║     ██║   ██║██║  ██║██╔══╝      ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██╔══╝  ██╔══██╗
## ╚██████╗╚██████╔╝██████╔╝███████╗    ███████║███████╗██║  ██║ ╚████╔╝ ███████╗██║  ██║
##  ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝    ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝

ferramenta_code_server() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_code_server

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite o Dominio para o CodeServer (ex: code-server.oriondesign.art.br): \e[0m" && read -r url_code_server
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -en "\e[33mDigite a senha Admin do CodeServer (ex: @Senha123_): \e[0m" && read -r pass_admin_code_server
    echo ""

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -en "\e[33mDigite a senha SuperAdmin do CodeServer (ex: @SuperSenha123_): \e[0m" && read -r pass_super_admin_code_server
    echo ""

    ## Limpa o terminal
    clear

    ## Mostra o nome da aplicação
    nome_code_server

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do CodeServer:\e[97m $url_code_server\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha Admin do CodeServer:\e[97m $pass_admin_code_server\e[0m"
    echo ""

    ## Informação sobre URL
    echo -e "\e[33mSenha SuperAdmin do CodeServer:\e[97m $pass_super_admin_code_server\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_code_server

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO CODE SERVER \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria CodeServer iniciado

echo -e "\e[97m• INSTALANDO CODE SERVER \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack code_server.yaml
cat > code_server${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  code_server${1:+_$1}:
    image: lscr.io/linuxserver/code-server:latest

    volumes:
      - code_server${1:+_$1}_config:/config

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 👤 Permissões e Identidade do Usuário
      - PUID=1000
      - PGID=1000
    
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo
    
    ## 🔐 Credenciais e Acesso
      - PASSWORD=$pass_admin_code_server
      - SUDO_PASSWORD=$pass_super_admin_code_server
    
    ## 🌐 Configurações de Rede e Proxy
      - PROXY_DOMAIN=$url_code_server
    
    ## 📁 Configurações de Workspace
      - DEFAULT_WORKSPACE=/config/workspace
    
    ## 🧩 Configurações da Aplicação
      - PWA_APPNAME=code-server
    
    ## 🧱 Extensões e Mods do Container
      - DOCKER_MODS=linuxserver/mods:code-server-nodejs|linuxserver/mods:code-server-npmglobal ## Outros Mods: https://mods.linuxserver.io/?mod=code-server
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.code_server${1:+_$1}.rule=Host(\`$url_code_server\`)
        - traefik.http.services.code_server${1:+_$1}.loadbalancer.server.port=8443
        - traefik.http.routers.code_server${1:+_$1}.service=code_server${1:+_$1}
        - traefik.http.routers.code_server${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.code_server${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.code_server${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  code_server${1:+_$1}_config:
    external: true
    name: code_server${1:+_$1}_config

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do code_server"
fi

STACK_NAME="code_server${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c code_server.yaml code_server > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do code_server"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull lscr.io/linuxserver/code-server:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack code_server${1:+_$1}_code_server${1:+_$1}

telemetria code_server finalizado

cd dados_vps

cat > dados_code_server${1:+_$1} <<EOL
[ CODE SERVER ]

Dominio do Code Server: https://$url_code_server

Senha Admin: $pass_admin_code_server

Senha SuperAdmin: $pass_super_admin_code_server
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ CODE SERVER ]\e[0m"
echo ""

echo -e "\e[33mDominio do code_server:\e[97m https://$url_code_server\e[0m"
echo ""

echo -e "\e[33mSenha admin:\e[97m $pass_admin_code_server\e[0m"
echo ""

echo -e "\e[33mSenha SuperAdmin:\e[97m $pass_super_admin_code_server\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ██████╗  █████╗ ██████╗ ██████╗  █████╗ 
## ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗
## ██████╔╝███████║██████╔╝██████╔╝███████║
## ██╔═══╝ ██╔══██║██╔═══╝ ██╔══██╗██╔══██║
## ██║     ██║  ██║██║     ██║  ██║██║  ██║
## ╚═╝     ╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝

ferramenta_papra() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_papra

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o Papra (ex: papra.oriondesign.art.br): \e[0m" && read -r url_papra
    echo ""

    ## Limpa o terminal
    clear

    ## Mostra o nome da aplicação
    nome_papra

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do Papra:\e[97m $url_papra\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_papra

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Criando key Aleatória
auth_secret_papra=$(openssl rand -hex 48)

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO PAPRA \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria Papra iniciado

echo -e "\e[97m• INSTALANDO PAPRA \e[33m[2/3]\e[0m"
echo ""
sleep 1

## Criando a stack papra.yaml
cat > papra${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  papra${1:+_$1}:
    image: ghcr.io/papra-hq/papra:latest

    volumes:
      - papra${1:+_$1}_db:/app/app-data/db
      - papra${1:+_$1}_documents:/app/app-data/documents
    
    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
    ## 🌐 Configurações da Aplicação
      - APP_BASE_URL=https://$url_papra
      - PORT=1221
      - SERVER_HOSTNAME=0.0.0.0
      - SERVER_SERVE_PUBLIC_DIR=true
      - NODE_ENV=production
    
    ## 🗄️ Configuração do Banco de Dados
      - DATABASE_URL=file:./app-data/db/db.sqlite
    
    ## 📁 Armazenamento de Documentos
      - DOCUMENT_STORAGE_DRIVER=filesystem
      - DOCUMENT_STORAGE_FILESYSTEM_ROOT=./app-data/documents
    
    ## 🔐 Configurações de Autenticação e Segurança
      - AUTH_SECRET=$auth_secret_papra 
      - AUTH_IS_REGISTRATION_ENABLED=true
      - AUTH_IS_PASSWORD_RESET_ENABLED=true
      - AUTH_IS_EMAIL_VERIFICATION_REQUIRED=false
      - SERVER_CORS_ORIGINS=https://$url_papra
    
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.papra${1:+_$1}.rule=Host(\`$url_papra\`)
        - traefik.http.services.papra${1:+_$1}.loadbalancer.server.port=1221
        - traefik.http.routers.papra${1:+_$1}.service=papra${1:+_$1}
        - traefik.http.routers.papra${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.papra${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.papra${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  papra${1:+_$1}_db:
    external: true
    name: papra${1:+_$1}_db
  papra${1:+_$1}_documents:
    external: true
    name: papra${1:+_$1}_documents

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do papra"
fi

STACK_NAME="papra${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c papra.yaml papra > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do papra"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/papra-hq/papra:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack papra${1:+_$1}_papra${1:+_$1}

telemetria Papra finalizado

cd dados_vps

cat > dados_papra${1:+_$1} <<EOL
[ PAPRA ]

Dominio do papra: https://$url_papra

Usuario: Precisa de criar no primeiro acesso do Papra

Senha: Precisa de criar no primeiro acesso do Papra
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ PAPRA ]\e[0m"
echo ""

echo -e "\e[33mDominio do papra:\e[97m https://$url_papra\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar no primeiro acesso do Papra\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar no primeiro acesso do Papra\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███████╗███████╗██████╗  ██████╗ ██████╗ ██╗   ██╗████████╗███████╗
## ╚══███╔╝██╔════╝██╔══██╗██╔═══██╗██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔════╝
##   ███╔╝ █████╗  ██████╔╝██║   ██║██████╔╝ ╚████╔╝    ██║   █████╗  
##  ███╔╝  ██╔══╝  ██╔══██╗██║   ██║██╔══██╗  ╚██╔╝     ██║   ██╔══╝  
## ███████╗███████╗██║  ██║╚██████╔╝██████╔╝   ██║      ██║   ███████╗
## ╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝    ╚═╝      ╚═╝   ╚══════╝

ferramenta_zerobyte() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_zerobyte

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o Dominio para o ZeroByte (ex: zerobyte.oriondesign.art.br): \e[0m" && read -r url_zerobyte
    echo ""

    ## Limpa o terminal
    clear

    ## Mostra o nome da aplicação
    nome_zerobyte

    ## Mostra mensagem para verificar as informações
    conferindo_as_info

    ## Informação sobre URL
    echo -e "\e[33mDominio do ZeroByte:\e[97m $url_zerobyte\e[0m"
    echo ""

    ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_zerobyte

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO ZEROBYTE \e[33m[1/3]\e[0m"
echo ""
sleep 1

telemetria ZeroByte iniciado

echo -e "\e[97m• INSTALANDO ZEROBYTE \e[33m[2/3]\e[0m"
echo ""
sleep 1

key_zerobyte=$(openssl rand -hex 32)

## Criando a stack zerobyte.yaml
cat > zerobyte${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  zerobyte${1:+_$1}:
    image: ghcr.io/nicotsx/zerobyte:latest

    volumes:
      - zerobyte${1:+_$1}_data:/var/lib/zerobyte
      - /etc/localtime:/etc/localtime:ro
      - /var/lib/docker/volumes:/docker/volumes:rw ## Permite acessar os volumes do Docker
      - /root:/root:rw ## Permite acessar o /root
    
    ## Permissões Extras
    #cap_add:
    #  - SYS_ADMIN
    #devices:
    #  - /dev/fuse:/dev/fuse
    
    networks:
      - $nome_rede_interna ## Nome da rede interna
    
    environment:
    ## 🌐 Base URL
      - BASE_URL=https://$url_zerobyte

    ## 🔐 App Secret
      - APP_SECRET=$key_zerobyte

    ## ⚙️ Ambiente da Aplicação
      - NODE_ENV=production
    
    ## 🕒 Fuso Horário
      - TZ=America/Sao_Paulo

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.zerobyte${1:+_$1}.rule=Host(\`$url_zerobyte\`)
        - traefik.http.services.zerobyte${1:+_$1}.loadbalancer.server.port=4096
        - traefik.http.routers.zerobyte${1:+_$1}.service=zerobyte${1:+_$1}
        - traefik.http.routers.zerobyte${1:+_$1}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.zerobyte${1:+_$1}.entrypoints=websecure
        - traefik.http.routers.zerobyte${1:+_$1}.tls=true

## --------------------------- ORION --------------------------- ##

volumes:
  zerobyte${1:+_$1}_data:
    external: true
    name: zerobyte${1:+_$1}_data

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna

EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do ZeroByte"
fi

STACK_NAME="zerobyte${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c zerobyte.yaml zerobyte > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do zerobyte"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[3/3]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/nicotsx/zerobyte:latest

## Usa o serviço wait_stack para verificar se o serviço esta online
wait_stack zerobyte${1:+_$1}_zerobyte${1:+_$1}

telemetria ZeroByte finalizado

cd dados_vps

cat > dados_zerobyte${1:+_$1} <<EOL
[ ZEROBYTE ]

Dominio do ZeroByte: https://$url_zerobyte

Usuario: Precisa de criar no primeiro acesso do ZeroByte

Senha: Precisa de criar no primeiro acesso do ZeroByte
EOL
cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ ZEROBYTE ]\e[0m"
echo ""

echo -e "\e[33mDominio do ZeroByte:\e[97m https://$url_zerobyte\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar no primeiro acesso do ZeroByte\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar no primeiro acesso do ZeroByte\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## ███╗   ███╗ ██████╗██████╗     ███╗   ██╗ █████╗ ███╗   ██╗
## ████╗ ████║██╔════╝██╔══██╗    ████╗  ██║██╔══██╗████╗  ██║
## ██╔████╔██║██║     ██████╔╝    ██╔██╗ ██║╚█████╔╝██╔██╗ ██║
## ██║╚██╔╝██║██║     ██╔═══╝     ██║╚██╗██║██╔══██╗██║╚██╗██║
## ██║ ╚═╝ ██║╚██████╗██║         ██║ ╚████║╚█████╔╝██║ ╚████║
## ╚═╝     ╚═╝ ╚═════╝╚═╝         ╚═╝  ╚═══╝ ╚════╝ ╚═╝  ╚═══╝

n8n.mcp() {

## Verifica os recursos
recursos 2 2 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostrar mensagem de Instalando
instalando_msg

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO MCP DO N8N \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria MCP iniciado

## NADA

# Mensagem de Passo
echo -e "\e[97m• PEGANDO INFORMAÇÕES DA STACK DO N8N \e[33m[2/4]\e[0m"
echo ""
sleep 1

local_da_stack="/root/n8n${1:+_$1}.yaml"

if [ ! -f "$local_da_stack" ]; then
    echo -e "\e[91mArquivo $local_da_stack não encontrado!\e[0m"
    exit 1
fi

# Função para extrair valores
get_var() {
  grep "$1" "$local_da_stack" | head -n1 | awk -F '=' '{gsub(/"/, "", $2); print $2}' | xargs
}

# Variáveis extraídas
DB_PASSWORD=$(get_var "DB_POSTGRESDB_PASSWORD")
ENCRYPTION_KEY=$(get_var "N8N_ENCRYPTION_KEY")
N8N_HOST=$(get_var "N8N_HOST")
EDITOR_BASE_URL=$(get_var "N8N_EDITOR_BASE_URL")
WEBHOOK_URL=$(get_var "WEBHOOK_URL")
SMTP_SENDER=$(get_var "N8N_SMTP_SENDER")
SMTP_USER=$(get_var "N8N_SMTP_USER")
SMTP_PASS=$(get_var "N8N_SMTP_PASS")
SMTP_HOST=$(get_var "N8N_SMTP_HOST")
SMTP_PORT=$(get_var "N8N_SMTP_PORT")
SMTP_SSL=$(get_var "N8N_SMTP_SSL")
WEBHOOK_URL_FORMATADO=$(echo "$WEBHOOK_URL" | sed -E 's|https?://([^/]+)/?.*|\1|')
QUEUE_BULL_REDIS_HOST=$(get_var "QUEUE_BULL_REDIS_HOST")

# Exibir uma vez só
echo -e "• DB_PASSWORD=$DB_PASSWORD"
echo -e "• ENCRYPTION_KEY=$ENCRYPTION_KEY"
echo -e "• N8N_HOST=$N8N_HOST"
echo -e "• EDITOR_BASE_URL=$EDITOR_BASE_URL"
echo -e "• WEBHOOK_URL=$WEBHOOK_URL"
echo -e "• WEBHOOK_URL_FORMATADO=$WEBHOOK_URL_FORMATADO"
echo -e "• SMTP_SENDER=$SMTP_SENDER"
echo -e "• SMTP_USER=$SMTP_USER"
echo -e "• SMTP_PASS=$SMTP_PASS"
echo -e "• SMTP_HOST=$SMTP_HOST"
echo -e "• SMTP_PORT=$SMTP_PORT"
echo -e "• SMTP_SSL=$SMTP_SSL"
echo -e "• QUEUE_BULL_REDIS_HOST=$QUEUE_BULL_REDIS_HOST"

echo ""
## Mensagem de Passo
echo -e "\e[97m• INSTALANDO MCP DO N8N \e[33m[3/4]\e[0m"
echo ""
sleep 1

## Criando a stack n8n.yaml
cat > n8n${1:+_$1}_mcp.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  n8n${1:+_$1}_mcp:
    image: n8nio/n8n:latest ## Versão do N8N
    command: webhook

    networks:
      - $nome_rede_interna ## Nome da rede interna

    environment:
      ## 🗄️ Banco de Dados (PostgreSQL)
      - N8N_FIX_MIGRATIONS=true 
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue${1:+_$1}
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$DB_PASSWORD

      ## 🔐 Criptografia
      - N8N_ENCRYPTION_KEY=$ENCRYPTION_KEY

      ## 🌐 URLs e Configurações de Acesso
      - N8N_HOST=$N8N_HOST
      - N8N_EDITOR_BASE_URL=$EDITOR_BASE_URL
      - WEBHOOK_URL=$WEBHOOK_URL
      - N8N_PROTOCOL=https
      - N8N_PROXY_HOPS=1
      - N8N_ONBOARDING_FLOW_DISABLED=true
      - N8N_BLOCK_ENV_ACCESS_IN_NODE=false
      - N8N_SKIP_AUTH_ON_OAUTH_CALLBACK=false

      ## ⚙️ Ambiente de Execução
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_RESTRICT_FILE_ACCESS_TO="~/.n8n-files"
      - NODES_EXCLUDE="[]"

      ## 📦 Pacotes e Nós Comunitários
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true

      ## 📧 SMTP (Envio de E-mails)
      - N8N_SMTP_SENDER=$SMTP_SENDER
      - N8N_SMTP_USER=$SMTP_USER
      - N8N_SMTP_PASS=$SMTP_PASS
      - N8N_SMTP_HOST=$SMTP_HOST
      - N8N_SMTP_PORT=$SMTP_PORT
      - N8N_SMTP_SSL=$SMTP_SSL

      ## 🔁 Redis (Fila de Execução)
      - QUEUE_BULL_REDIS_HOST=$QUEUE_BULL_REDIS_HOST
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2

      ## 📊 Métricas
      - N8N_METRICS=true

      ## ⏱️ Execuções e Limpeza
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336

      ## 🧠 Recursos de IA
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=

      ## 🧰 Permissões em Funções Personalizadas
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash

      ## 🕒 Fuso Horário
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "2"
          memory: 2048M
      labels:
        - traefik.enable=true
        - traefik.http.middlewares.nogzip.headers.customResponseHeaders.Content-Encoding=
        - traefik.http.routers.n8n${1:+_$1}_mcp.rule=(Host(\`$WEBHOOK_URL_FORMATADO\`) && PathPrefix(\`/mcp\`)) ## Url do Webhook do N8N
        - traefik.http.routers.n8n${1:+_$1}_mcp.entrypoints=websecure
        - traefik.http.routers.n8n${1:+_$1}_mcp.priority=1
        - traefik.http.routers.n8n${1:+_$1}_mcp.middlewares=nogzip
        - traefik.http.routers.n8n${1:+_$1}_mcp.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n${1:+_$1}_mcp.service=n8n${1:+_$1}_mcp
        - traefik.http.services.n8n${1:+_$1}_mcp.loadbalancer.server.port=5678
        - traefik.http.services.n8n${1:+_$1}_mcp.loadbalancer.passHostHeader=1

## --------------------------- ORION --------------------------- ##

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do MCP do N8N"
fi
STACK_NAME="n8n${1:+_$1}_mcp"
stack_editavel

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[5/5]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull n8nio/n8n:latest

wait_stack n8n${1:+_$1}_mcp_n8n${1:+_$1}_mcp

telemetria MCP finalizado

fix_webhook_url_mcp="${WEBHOOK_URL%/}"

cd dados_vps

cat > dados_n8n${1:+_$1}_mpc <<EOL
[ MCP DO N8N ]

Dominio do Webhook do MCP: $fix_webhook_url_mcp/mcp
EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ MCP DO N8N ]\e[0m"
echo ""

echo -e "\e[33mDominio Webhook:\e[97m $fix_webhook_url_mcp/mcp\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

##  ██████╗ ██████╗ ███████╗███╗   ██╗    ██╗    ██╗███████╗██████╗     ██╗   ██╗██╗
## ██╔═══██╗██╔══██╗██╔════╝████╗  ██║    ██║    ██║██╔════╝██╔══██╗    ██║   ██║██║
## ██║   ██║██████╔╝█████╗  ██╔██╗ ██║    ██║ █╗ ██║█████╗  ██████╔╝    ██║   ██║██║
## ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║    ██║███╗██║██╔══╝  ██╔══██╗    ██║   ██║██║
## ╚██████╔╝██║     ███████╗██║ ╚████║    ╚███╔███╔╝███████╗██████╔╝    ╚██████╔╝██║
##  ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝     ╚══╝╚══╝ ╚══════╝╚═════╝      ╚═════╝ ╚═╝

ferramenta_openwebui() {

## Verifica os recursos
recursos 1 1 && continue || return

## Limpa o terminal
clear

## Ativa a função dados para pegar os dados da vps
dados

## Mostra o nome da aplicação
nome_openwebui

## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do

    ##Pergunta o Dominio para a ferramenta
    echo -e "\e[97mPasso$amarelo 1/1\e[0m"
    echo -en "\e[33mDigite o dominio para o OpenWebUI (ex: openwebui.oriondesign.art.br): \e[0m" && read -r url_openwebui
    echo ""
    
    ## Limpa o terminal
    clear
    
    ## Mostra o nome da aplicação
    nome_openwebui
    
    ## Mostra mensagem para verificar as informações
    conferindo_as_info
    
    ##Informação do Dominio
    echo -e "\e[33mDominio para o OpenWebUI:\e[97m $url_openwebui\e[0m"
    echo ""
    
     ## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas

        ## Limpar o terminal
        clear

        ## Mostrar mensagem de Instalando
        instalando_msg

        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        ## Mostra o nome da ferramenta
        nome_openwebui

        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

## Mensagem de Passo
echo -e "\e[97m• INICIANDO A INSTALAÇÃO DO OPENWEBUI \e[33m[1/4]\e[0m"
echo ""
sleep 1

telemetria OpenWebUI iniciado

## NADA

## Mensagem de Passo
echo -e "\e[97m• INSTALANDO OPENWEBUI \e[33m[3/4]\e[0m"
echo ""
sleep 1

WEBUI_SECRET_KEY=$(openssl rand -hex 16)

## Criando a stack openwebui.yaml
cat > openwebui${1:+_$1}.yaml <<EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  openwebui${1:+_$1}_app:
    image: ghcr.io/open-webui/open-webui:main

    volumes:
      - openwebui${1:+_$1}_data:/app/backend/data

    networks:
      - $nome_rede_interna

    #ports:
    #  - 8085:8080

    environment:
    ## 🌐 Base URL API
      #- OLLAMA_BASE_URL=https://

    ## 🔐 Secret Key
      - WEBUI_SECRET_KEY=$WEBUI_SECRET_KEY

    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.openwebui${1:+_$1}_app.rule=Host(\`$url_openwebui\`)
        - traefik.http.routers.openwebui${1:+_$1}_app.entrypoints=websecure
        - traefik.http.routers.openwebui${1:+_$1}_app.priority=1
        - traefik.http.routers.openwebui${1:+_$1}_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.openwebui${1:+_$1}_app.service=openwebui${1:+_$1}_app
        - traefik.http.services.openwebui${1:+_$1}_app.loadbalancer.server.port=8080
        - traefik.http.services.openwebui${1:+_$1}_app.loadbalancer.passHostHeader=true

## --------------------------- ORION --------------------------- ##

volumes:
  openwebui${1:+_$1}_data:
    external: true
    name: openwebui${1:+_$1}_data
  
networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
if [ $? -eq 0 ]; then
    echo "1/10 - [ OK ] - Criando Stack"
else
    echo "1/10 - [ OFF ] - Criando Stack"
    echo "Não foi possivel criar a stack do openwebui"
fi
STACK_NAME="openwebui${1:+_$1}"
stack_editavel # > /dev/null 2>&1
#docker stack deploy --prune --resolve-image always -c openwebui.yaml openwebui > /dev/null 2>&1
#if [ $? -eq 0 ]; then
#    echo "2/2 - [ OK ] - Deploy Stack"
#else
#    echo "2/2 - [ OFF ] - Deploy Stack"
#    echo "Não foi possivel Subir a stack do openwebui"
#fi

## Mensagem de Passo
echo -e "\e[97m• VERIFICANDO SERVIÇO \e[33m[4/4]\e[0m"
echo ""
sleep 1

## Baixando imagens:
pull ghcr.io/open-webui/open-webui:main

## Usa o serviço wait_nocodb para verificar se o serviço esta online
wait_stack openwebui${1:+_$1}_openwebui${1:+_$1}_app

telemetria OpenWebUI finalizado

cd dados_vps

cat > dados_openwebui${1:+_$1} <<EOL
[ OPENWEBUI ]

Dominio do Open WebUI: https://$url_openwebui

Usuario: Precisa de criar ao fazer o primeiro login

Senha: Precisa de criar ao fazer o primeiro login

EOL

cd
cd

## Espera 30 segundos
wait_30_sec

## Mensagem de finalizado
instalado_msg

## Mensagem de Guarde os Dados
guarde_os_dados_msg

## Dados da Aplicação:
echo -e "\e[32m[ OPENWEBUI ]\e[0m"
echo ""

echo -e "\e[33mOpen OpenWebUI:\e[97m https://$url_openwebui\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m Precisa de criar ao fazer o primeiro login\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m Precisa de criar ao fazer o primeiro login\e[0m"

## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

## Ignore esta parte, só para facilitar minha identificação com esta parte "XXOOXX"

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Comandos extras

portainer.restart() {

    echo ""
    echo "Aguarde enquanto reiniciamos o Portainer"
    echo ""
    docker service update --force $(docker service ls --filter name='portainer_agent' -q) > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "1/2 - [ OK ]"
    else
        echo "1/2 - [ OFF ]"
        echo "Não foi possivel reiniciar o portainer"
    fi
    docker service update --force $(docker service ls --filter name='portainer_portainer' -q) > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "2/2 - [ OK ]"
    else
        echo "2/2 - [ OFF ]"
        echo "Não foi possivel reiniciar o portainer"
    fi
    sleep 2
    clear
}

chatwoot.mail() {

    echo ""
    echo "Aguarde enquanto trocamos os emails..."
    echo ""

    #cd /var/lib/docker/volumes/chatwoot_mailer/_data/app/views/devise/mailer/
    cd /var/lib/docker/volumes/chatwoot_mailer/_data/

    # Renomeia os arquivos
    mv password_change.html.erb password_change.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "1/9 - [ OK ]"
    else
        echo "1/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    mv confirmation_instructions.html.erb confirmation_instructions.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "2/9 - [ OK ]"
    else
        echo "2/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    mv reset_password_instructions.html.erb reset_password_instructions.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "3/9 - [ OK ]"
    else
        echo "3/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    mv unlock_instructions.html.erb unlock_instructions.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "4/9 - [ OK ]"
    else
        echo "4/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    
    # Baixa os novos arquivos
    wget -O confirmation_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/confirmation_instructions.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "5/9 - [ OK ]"
    else
        echo "5/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    wget -O password_change.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/password_change.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "6/9 - [ OK ]"
    else
        echo "6/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    wget -O reset_password_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/reset_password_instructions.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "7/9 - [ OK ]"
    else
        echo "7/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    wget -O unlock_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/unlock_instructions.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "8/9 - [ OK ]"
    else
        echo "8/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    
    cd
    cd

    # Deleta os containers do Chatwoot
    docker rm -f $(docker ps -a | grep 'chatwoot' | awk '{print $1}') > /dev/null 2>&1

    if [ $? -eq 0 ]; then
        echo "9/9 - [ OK ]"
    else
        echo "9/9 - [ OFF ]"
        echo "Não foi possivel deletar containers."
    fi

    echo ""
    echo "Esperando containers subir..."
    wait_30_sec

    echo ""
    echo "Concluido!"
    sleep 2
}

chatwoot.n.mail() {

    echo ""
    echo "Aguarde enquanto trocamos os emails..."
    echo ""

    #cd /var/lib/docker/volumes/chatwoot_mailer/_data/app/views/devise/mailer/
    cd /var/lib/docker/volumes/chatwoot_nestor_mailer/_data/

    # Renomeia os arquivos
    mv password_change.html.erb password_change.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "1/9 - [ OK ]"
    else
        echo "1/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    mv confirmation_instructions.html.erb confirmation_instructions.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "2/9 - [ OK ]"
    else
        echo "2/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    mv reset_password_instructions.html.erb reset_password_instructions.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "3/9 - [ OK ]"
    else
        echo "3/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    mv unlock_instructions.html.erb unlock_instructions.html.erb.old > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "4/9 - [ OK ]"
    else
        echo "4/9 - [ OFF ]"
        echo "Não foi possivel mudar email."
    fi
    
    # Baixa os novos arquivos
    wget -O confirmation_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/confirmation_instructions.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "5/9 - [ OK ]"
    else
        echo "5/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    wget -O password_change.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/password_change.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "6/9 - [ OK ]"
    else
        echo "6/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    wget -O reset_password_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/reset_password_instructions.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "7/9 - [ OK ]"
    else
        echo "7/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    wget -O unlock_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/unlock_instructions.html.erb > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "8/9 - [ OK ]"
    else
        echo "8/9 - [ OFF ]"
        echo "Não foi possivel baixar email."
    fi
    
    cd
    cd

    # Deleta os containers do Chatwoot
    docker rm -f $(docker ps -a | grep 'chatwoot' | awk '{print $1}') > /dev/null 2>&1

    if [ $? -eq 0 ]; then
        echo "9/9 - [ OK ]"
    else
        echo "9/9 - [ OFF ]"
        echo "Não foi possivel deletar containers."
    fi

    echo ""
    echo "Esperando containers subir..."
    wait_30_sec

    echo ""
    echo "Concluido!"
    sleep 2
}

n8n.workflows(){
while true; do
    if docker ps -q --filter "name=n8n_quepasa_n8n_quepasa_editor" | grep -q .; then
        # Capturar o ID do container
        container_id=$(docker ps --filter "name=n8n_quepasa_n8n_quepasa_editor" --format "{{.ID}}")

        # Verificar se o ID do container foi capturado corretamente
        if [ -z "$container_id" ]; then
            echo "Erro: Não foi possível encontrar o ID do contêiner."
            exit 1
        fi

        # Executar o código no contêiner apenas se ele estiver em execução
        docker exec "$container_id" /bin/sh -c '
            # Criando diretório temporário
            temp_dir=$(mktemp -d)

            # Entrando no diretório temporário
            cd "$temp_dir"

            # Baixando workflows

            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/ChatwootExtra.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/ChatwootProfileUpdate.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/ChatwootToQuepasa.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/GetChatwootContacts.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/GetValidConversation.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/MsgRejectCall.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/PostToChatwoot.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/PostToWebCallBack.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaAutomatic.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaChatControl.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaContactsImport.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaInboxControl.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaInboxControl+soc.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaInboxControl+typebot.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaInboxControl+webhook.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaQrcode.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/QuepasaToChatwoot.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/ToChatwootTranscriptViaOpenAI.json"
            wget "https://raw.githubusercontent.com/DeividMs/QP_Setup_Orion/main/workflows/latest/ToTypeBot.json"

            # Subindo workflows
            n8n import:workflow --input="$temp_dir" --separate

            # Verificando se os workflows foram importados com sucesso
            if [ $? -eq 0 ]; then
                echo "Workflows importados com sucesso"
            else
                echo "Erro ao importar workflows"
                exit 1
            fi

            # Ativando os workflows
            
            n8n update:workflow --id 1008 --active=true && echo "Fluxo ChatwootToQuepasa ativado" || echo "Erro ao ativar fluxo ChatwootToQuepasa"
            n8n update:workflow --id 1009 --active=true && echo "Fluxo QuepasaToChatwoot ativado" || echo "Erro ao ativar fluxo QuepasaToChatwoot"
            n8n update:workflow --id 1011 --active=true && echo "Fluxo QuepasaAutomatic ativado" || echo "Erro ao ativar QuepasaAutomatic 1011"
            n8n update:workflow --id z7iqKYC8r5nPRRHt --active=true && echo "Fluxo QuepasaQrcode ativado" || echo "Erro ao ativar fluxo QuepasaQrcode"
            n8n update:workflow --id GIPTrjgdT9vuOSlN --active=true && echo "Fluxo MsgRejectCall ativado" || echo "Erro ao ativar fluxo MsgRejectCall"


        '
        break
    else
        clear
        erro_msg
        echo ""
        echo -e "Ops, parece que você não instalou a opção \e[32m[28] N8N + Nodes Quepasa${reset} ${branco}do nosso instalador.${reset}"
        echo "Instale antes de tentar instalar esta aplicação."
        echo ""
        echo "Pressione CTRL C para sair do instalador."
        sleep 5
        exit
    fi
done

}

portainer.reset() {
    cd
    clear
    nome_portainer.reset
    echo "Aguarde enquanto reseto a senha do portainer..."
    echo ""

    docker service scale portainer_portainer=0 > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "1/7 - [ OK ]"
    else
        echo "1/7 - [ OFF ]"
        echo "Ops, não foi possivel derrubar o serviço do portainer"
    fi

    docker pull portainer/helper-reset-password > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "2/7 - [ OK ]"
    else
        echo "2/7 - [ OFF ]"
        echo "Ops, não foi possivel super o serviço de reset password do portainer"
    fi

    script -c "docker run --rm -v /var/lib/docker/volumes/portainer_data/_data:/data portainer/helper-reset-password" output.txt > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "3/7 - [ OK ]"
    else
        echo "3/7 - [ OFF ]"
        echo "Ops, não foi possivel resetar a senha do portainer"
    fi

    cd
    #STACK_NAME="portainer"
    #stack_editavel > /dev/null 2>&1
    docker stack deploy --prune --resolve-image always -c portainer.yaml portainer > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "4/7 - [ OK ]"
    else
        echo "4/7 - [ OFF ]"
        echo "Ops, não foi possivel subir a stack do portainer"
    fi

    USER=$(grep -oP 'user: \K[^,]*' output.txt)
    if [ $? -eq 0 ]; then
        echo "5/7 - [ OK ]"
    else
        echo "5/7 - [ OFF ]"
        echo "Ops, não foi possivel pegar o usuario do portainer"
    fi

    PASSWORD=$(grep -oP 'login: \K.*' output.txt)
    if [ $? -eq 0 ]; then
        echo "6/7 - [ OK ]"
    else
        echo "6/7 - [ OFF ]"
        echo "Ops, não foi possivel pegar a senha do portainer"
    fi

    rm output.txt
    if [ $? -eq 0 ]; then
        echo "7/7 - [ OK ]"
    else
        echo "7/7 - [ OFF ]"
        echo "Ops, não foi possivel remover o arquivo output. txt ou ele não existe"
    fi

    echo ""
    sleep 3
    clear
    nome_portainer.reset
    echo -e "\e[32m[ PORTAINER ]\e[0m"
    echo ""
    
    echo -e "\e[97mUsuario:\e[33m $USER\e[0m"
    echo ""
    
    echo -e "\e[97mNova Senha:\e[33m $PASSWORD\e[0m"
    
    ## Creditos do instalador
    creditos_msg

    read -p "Deseja voltar ao menu principal? (Y/N): " choice
    if [ "$choice" = "Y" ] || [ "$choice" = "y" ]; then
        return
    else
        cd
        cd
        clear
        exit 1
    fi
}

ctop() {

    echo ""
    echo "Instalando CTOP"
    sudo wget https://github.com/bcicen/ctop/releases/download/v0.7.7/ctop-0.7.7-linux-amd64 -O /usr/local/bin/ctop
    if [ $? -eq 0 ]; then
        echo "1/2 - [ OK ] - Baixando CTOP"
    else
        echo "1/2 - [ OFF ] - Baixando CTOP"
        echo "Ops, não foi possivel baixar o CTOP"
    fi

    sudo chmod +x /usr/local/bin/ctop
    if [ $? -eq 0 ]; then
        echo "2/2 - [ OK ] - Dando permissão ao CTOP"
    else
        echo "2/2 - [ OFF ] - Dando permissão ao CTOP"
        echo "Ops, não foi possivel dar permissão ao CTOP"
    fi
    echo ""
    echo "Instalado, digite CTOP fora do nosso Setup oara executa-lo a qualquer momento."
    echo ""
    sleep 5

}

htop() {

    echo ""
    echo "Instalando HTOP"

    # Atualiza o repositório e instala o htop
    sudo apt-get update -y >/dev/null 2>&1
    sudo apt-get install -y htop >/dev/null 2>&1

    if [ $? -eq 0 ]; then
        echo "1/1 - [ OK ] - Instalando HTOP"
        echo ""
        echo "Instalado, digite HTOP fora do nosso Setup para executá-lo a qualquer momento."
    else
        echo "1/1 - [ OFF ] - Instalando HTOP"
        echo "Ops, não foi possível instalar o HTOP"
    fi

    echo ""
    sleep 5
}

portainer.update() {

    echo ""
    echo "Atualizando Portainer..."

    # Passo 1: Executa o deploy com --prune e --resolve-image always
    docker stack deploy --prune --resolve-image always -c portainer.yaml portainer
    if [ $? -eq 0 ]; then
        echo "1/2 - [ OK ] - Comando de atualização enviado"
    else
        echo "1/2 - [ OFF ] - Erro ao atualizar o Portainer"
        echo "Verifique se o arquivo 'portainer.yaml' existe e está correto."
        return 1
    fi

    # Passo 2: Espera a stack ficar online
    if wait_stack "portainer"; then
        sleep 20
        echo "2/2 - [ OK ] - Portainer está online"
    else
        echo "2/2 - [ OFF ] - Portainer não ficou online"
        echo "Verifique os logs para mais detalhes."
        return 1
    fi

    echo ""
    echo "Atualização concluída. Acesse o Portainer normalmente."
    echo ""
    sleep 3
}

traefik.update() {

echo ""
echo "Atualizando Traefik..."

## Coletando informações da atual Stack do Traefik

## Mensagem de Passo
echo -e "\e[97m• PEGANDO INFORMAÇÕES DO TRAEFIK \e[33m[1/4]\e[0m"
echo ""
sleep 1

ARQUIVO="/root/traefik.yaml"
email_ssl=$(grep -oP '(?<=--certificatesresolvers\.letsencryptresolver\.acme\.email=).*' "$ARQUIVO" | awk '{print $1}' | tr -d '"')
nome_rede_interna=$(awk '/^networks:/,/^volumes:/ {if ($1 == "name:") print $2}' "$ARQUIVO")

echo -e "\e[97mEmail SSL \e[33m$email_ssl\e[0m"
echo ""

echo -e "\e[97mRede Interna \e[33m$nome_rede_interna\e[0m"
echo ""

## Mensagem de Passo
echo -e "\e[97m• ATUALIZANDO STACK DO TRAEFIK \e[33m[2/4]\e[0m"
echo ""
sleep 1

mv /root/traefik.yaml /root/traefik.yaml.old

## Criando a stack traefik.yaml
cat > traefik.yaml << EOL
version: "3.7"
services:

## --------------------------- ORION --------------------------- ##

  traefik:
    image: traefik:v3.5.3
    command:
      - "--api.dashboard=true"
      - "--providers.swarm=true"
      - "--providers.docker.endpoint=unix:///var/run/docker.sock"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=$nome_rede_interna" ## Nome da rede interna
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.web.http.redirections.entrypoint.permanent=true"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.transport.respondingTimeouts.idleTimeout=3600"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/etc/traefik/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencryptresolver.acme.email=$email_ssl" ## Email para receber as notificações
      - "--log.level=DEBUG"
      - "--log.format=common"
      - "--log.filePath=/var/log/traefik/traefik.log"
      - "--accesslog=true"
      - "--accesslog.filepath=/var/log/traefik/access-log"

    volumes:
      - "vol_certificates:/etc/traefik/letsencrypt"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host

    deploy:
      placement:
        constraints:
          - node.role == manager
      labels:
        - "traefik.enable=true"
        - "traefik.http.middlewares.redirect-https.redirectscheme.scheme=https"
        - "traefik.http.middlewares.redirect-https.redirectscheme.permanent=true"
        - "traefik.http.routers.http-catchall.rule=Host(\`{host:.+}\`)"
        - "traefik.http.routers.http-catchall.entrypoints=web"
        - "traefik.http.routers.http-catchall.middlewares=redirect-https@docker"
        - "traefik.http.routers.http-catchall.priority=1"

## --------------------------- ORION --------------------------- ##

volumes:
  vol_shared:
    external: true
    name: volume_swarm_shared
  vol_certificates:
    external: true
    name: volume_swarm_certificates

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    attachable: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Criando Stack"
else
    echo "1/3 - [ OFF ] - Criando Stack"
    echo "Ops, não foi possivel criar a stack do Traefik"
fi

docker stack deploy --prune --resolve-image always -c traefik.yaml traefik
if [ $? -eq 0 ]; then
    echo "2/3 - [ OK ] - Subindo stack do traefik"
else
    echo "2/3 - [ OFF ] - Erro ao subir stack do traefik"
    echo "Verifique se o arquivo 'traefik.yaml' existe e está correto."
    return 1
fi

# Passo 2: Espera a stack ficar online
if wait_stack "traefik"; then
    sleep 20
    echo "3/3 - [ OK ] - Traefik está online"
    rm /root/traefik.yaml.old
else
    echo "3/3 - [ OFF ] - Traefik não ficou online"
    echo "Verifique os logs para mais detalhes."
    return 1
fi

echo ""
echo "Atualização concluída."
echo ""
sleep 3
}

traefik.dash() {
clear
nome_traefik
## Mostra mensagem para preencher informações
preencha_as_info

## Inicia um Loop até os dados estarem certos
while true; do
    ## Pergunta o link do Dashboard
    echo -e "\e[97mPasso$amarelo 1/3\e[0m"
    echo -en "\e[33mDigite um link para o Dashboard do Traefik (ex: traefik.oriondesign.art.br): \e[0m" && read -r traefik_url_dashboard
    echo ""

    ## Pergunta o usuario da ferramenta
    echo -e "\e[97mPasso$amarelo 2/3\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$ e/ou espaços"
    echo -en "\e[33mDigite um usuario (ex: OrionDesign): \e[0m" && read -r traefik_user
    echo ""

    ## Pergunta o senha da ferramenta
    echo -e "\e[97mPasso$amarelo 3/3\e[0m"
    echo -e "$amarelo--> Sem caracteres especiais: \!#$"
    echo -en "\e[33mDigite uma Senha (ex: @Senha123_): \e[0m" && read -r traefik_pass
    echo ""

## Pergunta se as respostas estão corretas
    read -p "As respostas estão corretas? (Y/N): " confirmacao
    if [ "$confirmacao" = "Y" ] || [ "$confirmacao" = "y" ]; then

        ## Digitou Y para confirmar que as informações estão corretas
        echo ""
        ## Sai do Loop
        break
    else

        ## Digitou N para dizer que as informações não estão corretas.

        ## Limpar o terminal
        clear

        nome_traefik
        ## Mostra mensagem para preencher informações
        preencha_as_info

    ## Volta para o inicio do loop com as perguntas
    fi
done

clear
instalando_msg
## Coletando informações da atual Stack do Traefik

## Mensagem de Passo
echo -e "\e[97m• PEGANDO INFORMAÇÕES DO TRAEFIK \e[33m[1/4]\e[0m"
echo ""
sleep 1

ARQUIVO="/root/traefik.yaml"
email_ssl=$(grep -oP '(?<=--certificatesresolvers\.letsencryptresolver\.acme\.email=).*' "$ARQUIVO" | awk '{print $1}' | tr -d '"')
nome_rede_interna=$(awk '/^networks:/,/^volumes:/ {if ($1 == "name:") print $2}' "$ARQUIVO")

echo -e "\e[97mEmail SSL \e[33m$email_ssl\e[0m"
echo ""

echo -e "\e[97mRede Interna \e[33m$nome_rede_interna\e[0m"
echo ""

## Mensagem de Passo
echo -e "\e[97m• ATUALIZANDO STACK DO TRAEFIK \e[33m[2/4]\e[0m"
echo ""
sleep 1

mv /root/traefik.yaml /root/traefik.yaml.old

## Gera BasicAuth
basicauth=$(htpasswd -nbB "$traefik_user" "$traefik_pass" | sed 's/\$/\$\$/g')

## Criando a stack traefik.yaml
cat > traefik.yaml << EOL
version: "3.7"
services:
  ## --------------------------- ORION --------------------------- ##

  traefik:
    image: traefik:v3.5.3
    command:
      - "--api.dashboard=true"
      - "--providers.swarm=true"
      - "--providers.docker.endpoint=unix:///var/run/docker.sock"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=$nome_rede_interna" ## Nome da rede interna
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.web.http.redirections.entrypoint.permanent=true"
      - "--entrypoints.websecure.address=:443"
      - "--api.insecure=true"
      - "--entrypoints.web.transport.respondingTimeouts.idleTimeout=3600"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/etc/traefik/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencryptresolver.acme.email=$email_ssl" ## Email para receber as notificações
      - "--log.level=DEBUG"
      - "--log.format=common"
      - "--log.filePath=/var/log/traefik/traefik.log"
      - "--accesslog=true"
      - "--accesslog.filepath=/var/log/traefik/access-log"

    volumes:
      - "vol_certificates:/etc/traefik/letsencrypt"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"

    networks:
      - $nome_rede_interna ## Nome da rede interna

    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host

    deploy:
      placement:
        constraints:
          - node.role == manager
      labels:
        - "traefik.enable=true"
        - "traefik.http.middlewares.redirect-https.redirectscheme.scheme=https"
        - "traefik.http.middlewares.redirect-https.redirectscheme.permanent=true"
        - "traefik.http.routers.http-catchall.rule=Host(\`{host:.+}\`)"
        - "traefik.http.routers.http-catchall.entrypoints=web"
        - "traefik.http.routers.http-catchall.middlewares=redirect-https@docker"
        - "traefik.http.routers.http-catchall.priority=1"

        ## Dashboard Traefik
        - "traefik.http.routers.traefik.rule=Host(\`$traefik_url_dashboard\`)" ## Dominio do traefik
        - "traefik.http.services.traefik.loadbalancer.server.port=8080"
        - "traefik.http.routers.traefik.tls.certresolver=letsencryptresolver"
        - "traefik.http.routers.traefik.service=traefik"
        - "traefik.http.routers.traefik.entrypoints=websecure"
        - "traefik.http.routers.traefik.priority=1"
        - "traefik.http.routers.traefik.middlewares=authtraefik"
        - "traefik.http.middlewares.authtraefik.basicauth.users=$basicauth"

## --------------------------- ORION --------------------------- ##

volumes:
  vol_shared:
    external: true
    name: volume_swarm_shared
  vol_certificates:
    external: true
    name: volume_swarm_certificates

networks:
  $nome_rede_interna: ## Nome da rede interna
    external: true
    attachable: true
    name: $nome_rede_interna ## Nome da rede interna
EOL
if [ $? -eq 0 ]; then
    echo "1/3 - [ OK ] - Criando Stack"
else
    echo "1/3 - [ OFF ] - Criando Stack"
    echo "Ops, não foi possivel criar a stack do Traefik"
fi

docker stack deploy --prune --resolve-image always -c traefik.yaml traefik
if [ $? -eq 0 ]; then
    echo "2/3 - [ OK ] - Subindo stack do traefik"
else
    echo "2/3 - [ OFF ] - Erro ao subir stack do traefik"
    echo "Verifique se o arquivo 'traefik.yaml' existe e está correto."
    return 1
fi

# Passo 2: Espera a stack ficar online
if wait_stack "traefik"; then
    sleep 20
    echo "3/3 - [ OK ] - Traefik está online"
    rm /root/traefik.yaml.old
else
    echo "3/3 - [ OFF ] - Traefik não ficou online"
    echo "Verifique os logs para mais detalhes."
    return 1
fi

# Resultado final
echo ""
echo -e "\e[32m[ TRAEFIK DASHBOARD ]\e[0m"
echo ""

echo -e "\e[33mUrl do Dashboard:\e[97m https://$traefik_url_dashboard\e[0m"
echo ""

echo -e "\e[33mUsuario:\e[97m $traefik_user\e[0m"
echo ""

echo -e "\e[33mSenha:\e[97m $traefik_pass\e[0m"


## Creditos do instalador
creditos_msg

## Pergunta se deseja instalar outra aplicação
requisitar_outra_instalacao
}

quepasa.setup.off(){
    echo ""
    echo "Desativando painel /setup do quepasa"
    mv /var/lib/docker/volumes/quepasa_volume/_data/views/setup.tmpl /var/lib/docker/volumes/quepasa_volume/_data/views/setup.old
    if [ $? -eq 0 ]; then
        echo "1/1 - [ OK ] - Painel /setup Desativado"
    else
        echo "1/1 - [ OFF ] - Erro ao desativar painel"
        echo "Tente novamente mais tarde ou verifique se você tem Quepasa instalado."
    fi
    echo ""
    echo "Voltando ao menu de ferramentas..."
    sleep 5
}

quepasa.setup.on(){
    echo ""
    echo "Ativando painel /setup do quepasa"
    mv /var/lib/docker/volumes/quepasa_volume/_data/views/setup.old /var/lib/docker/volumes/quepasa_volume/_data/views/setup.tmpl
    if [ $? -eq 0 ]; then
        echo "1/1 - [ OK ] - Painel /setup Ativado"
    else
        echo "1/1 - [ OFF ] - Erro ao Ativar painel"
        echo "Tente novamente mais tarde ou verifique se você tem Quepasa instalado."
    fi
    echo ""
    echo "Voltando ao menu de ferramentas..."
    sleep 5
}

# Função para calcular espaço de disco
armazenamento_livre() {
    df_output=$(df --output=used,avail,size --block-size=1G / | tail -n1)
    used=$(echo "$df_output" | awk '{print $1}')
    avail=$(echo "$df_output" | awk '{print $2}')
    total=$(echo "$df_output" | awk '{print $3}')
    percentage=$((100 * used / total))

    echo "$used $avail $total $percentage"
}

# Função principal
limpar() {
    clear
    nome_expurgando
    echo -e "\e[97m• VERIFICANDO ESPAÇO DISPONÍVEL \e[33m[1/3]\e[0m"
    echo ""
    sleep 1
    read used_before avail_before total_before percent_before <<<"$(armazenamento_livre)"
    echo -e "Espaço usado: \e[33m${used_before}Gb\e[0m (\e[33m${percent_before}%\e[0m usado)"
    echo -e "Espaço livre: \e[33m${avail_before}Gb\e[0m de \e[33m${total_before}Gb\e[0m"
    echo ""

    echo -e "\e[97m• LIMPANDO RECURSOS NÃO UTILIZADOS DO DOCKER \e[33m[2/3]\e[0m"
    echo ""
    sleep 1
    docker system prune -af > /dev/null
    truncate -s 0 /var/lib/docker/containers/*/*-json.log > /dev/null
    sleep 1

    echo -e "\e[97m• LIMPEZA CONCLUÍDA \e[33m[3/3]\e[0m"
    echo ""
    read used_after avail_after total_after percent_after <<<"$(armazenamento_livre)"
    echo -e "Espaço usado: \e[33m${used_after}Gb\e[0m (\e[33m${percent_after}%\e[0m usado)"
    echo -e "Espaço livre: \e[33m${avail_after}Gb\e[0m de \e[33m${total_after}Gb\e[0m"

    # Calcular espaço liberado
    space_freed=$((used_before - used_after))
    echo -e "Foi liberado: \e[33m${space_freed}Gb\e[0m do seu servidor"
    echo ""
    echo -e "\e[97mVoltando ao menu principal em 10 segundos...\e[0m"
    sleep 10
}

docker.fix(){

echo ""
echo "Iniciando a correção no Docker"
echo ""

sudo mkdir -p /etc/systemd/system/docker.service.d
if [ $? -eq 0 ]; then
    echo "1/6 - [ OK ] - Criando diretório de configuração do Docker"
else
    echo "1/6 - [ OFF ] - Criando diretório de configuração do Docker"
fi

sudo bash -c 'cat > /etc/systemd/system/docker.service.d/override.conf <<EOF
[Service]
Environment=DOCKER_MIN_API_VERSION=1.24
EOF'
if [ $? -eq 0 ]; then
    echo "2/6 - [ OK ] - Criando arquivo de configuração do Docker"
else
    echo "2/6 - [ OFF ] - Criando arquivo de configuração do Docker"
fi

sudo systemctl daemon-reexec > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "3/6 - [ OK ] - Aplicando override no systemd do Docker"
else
    echo "3/6 - [ OFF ] - Aplicando override no systemd do Docker"
fi
sudo systemctl daemon-reload > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "4/6 - [ OK ] - Recarregando as configurações do systemd"
else
    echo "4/6 - [ OFF ] - Recarregando as configurações do systemd"
fi
sudo systemctl restart docker > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "5/6 - [ OK ] - Reiniciando o serviço Docker"
else
    echo "5/6 - [ OFF ] - Reiniciando o serviço Docker"
fi

ENV_VALUE=$(systemctl show --property=Environment docker | grep -o "DOCKER_MIN_API_VERSION=1.24" || true)
if [ "$ENV_VALUE" == "DOCKER_MIN_API_VERSION=1.24" ]; then
    echo "6/6 - [ OK ] - Correção aplicada"
    sleep 5
else
    echo "6/6 - [ OFF ] - Correção NÃO aplicada"
    sleep 5
fi

### Detectar SO e codename
#OS_ID=$(source /etc/os-release && echo "$ID")
#OS_CODENAME=$(source /etc/os-release && echo "$VERSION_CODENAME")
#
## Instalar dependências básicas
#sudo apt update
#sudo apt install -y ca-certificates curl gnupg lsb-release
#
### Configurar repositório oficial do Docker
#sudo mkdir -p /etc/apt/keyrings
#sudo rm -f /etc/apt/keyrings/docker.gpg
#curl -fsSL https://download.docker.com/linux/$OS_ID/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
#echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$OS_ID $OS_CODENAME stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
#
#sudo apt update
#
### Versão problemática que queremos evitar
#BAD_VERSION="5:28.5.2"
#
### Buscar versão mais próxima (menor ou igual à BAD_VERSION)
#DOCKER_VERSION=$(apt-cache madison docker-ce \
#    | awk '{print $3}' \
#    | grep -E '^5:28\.5\.[0-1]-' \
#    | sort -Vr \
#    | head -n1)
#
#if [ -z "$DOCKER_VERSION" ]; then
#    echo "Não foi possível encontrar uma versão estável próxima. Instalando a última disponível..."
#    sudo apt install -y docker-ce docker-ce-cli containerd.io
#else
#    echo "Instalando Docker versão estável próxima: $DOCKER_VERSION"
#    sudo apt install --allow-downgrades -y \
#        docker-ce=$DOCKER_VERSION \
#        docker-ce-cli=$DOCKER_VERSION \
#        containerd.io
#    # Travar versão
#    sudo apt-mark hold docker-ce docker-ce-cli containerd.io
#fi
#
### Verificar instalação
#docker --version
#
#echo ""
#echo "Pode ser necessario reiniciar a VPS com o comando 'reboot' para ter efeito"
#echo ""
#sleep 10
}

docker.fix2() {
## Detectar SO e codename
OS_ID=$(source /etc/os-release && echo "$ID")
OS_CODENAME=$(source /etc/os-release && echo "$VERSION_CODENAME")

# Instalar dependências básicas
sudo apt update
sudo apt install -y ca-certificates curl gnupg lsb-release

## Configurar repositório oficial do Docker
sudo mkdir -p /etc/apt/keyrings
sudo rm -f /etc/apt/keyrings/docker.gpg
curl -fsSL https://download.docker.com/linux/$OS_ID/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$OS_ID $OS_CODENAME stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

sudo apt update

## Versão problemática que queremos evitar
BAD_VERSION="5:28.5.2"

## Buscar versão mais próxima (menor ou igual à BAD_VERSION)
DOCKER_VERSION=$(apt-cache madison docker-ce \
    | awk '{print $3}' \
    | grep -E '^5:28\.5\.[0-1]-' \
    | sort -Vr \
    | head -n1)

if [ -z "$DOCKER_VERSION" ]; then
    echo "Não foi possível encontrar uma versão estável próxima. Instalando a última disponível..."
    sudo apt install -y docker-ce docker-ce-cli containerd.io
else
    echo "Instalando Docker versão estável próxima: $DOCKER_VERSION"
    sudo apt install --allow-downgrades -y \
        docker-ce=$DOCKER_VERSION \
        docker-ce-cli=$DOCKER_VERSION \
        containerd.io
    # Travar versão
    sudo apt-mark hold docker-ce docker-ce-cli containerd.io
fi

## Verificar instalação
docker --version

echo ""
echo "Pode ser necessario reiniciar a VPS com o comando 'reboot' para ter efeito"
echo ""
sleep 10
}

# Função completa com ajustes de política para o bucket
minio.bucket() {
  dados
  pegar_senha_minio
  ADMIN_USER="$user_minio"
  ADMIN_PASS="$senha_minio"
  BUCKET_NAME="$1"

  if [ -z "$BUCKET_NAME" ]; then
    echo "❌ Você precisa informar o nome do bucket. Exemplo: minio.bucket dify"
    return 1
  fi

  MINIO_CONTAINER=$(docker ps --filter "name=minio" -q | head -n1)
  if [ -z "$MINIO_CONTAINER" ]; then
    echo "❌ Container MinIO não encontrado!"
    return 1
  fi

  MC_CMD="docker exec -i $MINIO_CONTAINER mc"
  S3_ENDPOINT=""
  ENDPOINTS=("http://minio:9000" "http://localhost:9000")

  for endpoint in "${ENDPOINTS[@]}"; do
    if $MC_CMD alias set admin "$endpoint" "$ADMIN_USER" "$ADMIN_PASS" >/dev/null 2>&1; then
      S3_ENDPOINT="$endpoint"
      echo "✅ Conectado com sucesso ao MinIO via $S3_ENDPOINT"
      break
    fi
  done

  if [ -z "$S3_ENDPOINT" ]; then
    echo -e "\n❌ Falha ao conectar com os endpoints padrão (minio, localhost)."
    echo -en "\e[33m👉 Digite manualmente o endpoint (ex: http://ip:9000): \e[0m"
    read -r S3_ENDPOINT
    $MC_CMD alias set admin "$S3_ENDPOINT" "$ADMIN_USER" "$ADMIN_PASS" || {
      echo "❌ Ainda não foi possível conectar. Verifique o endpoint e tente novamente."
      return 1
    }
    echo "✅ Conectado com sucesso ao MinIO via $S3_ENDPOINT"
  fi

  if $MC_CMD mb admin/"$BUCKET_NAME"; then
    echo "✅ Bucket '$BUCKET_NAME' criado com sucesso!"
  else
    echo "⚠️  Não foi possível criar o bucket '$BUCKET_NAME'. Ele já pode existir."
  fi

  if $MC_CMD anonymous set public admin/"$BUCKET_NAME"; then
    echo "✅ Política 'public' aplicada ao bucket '$BUCKET_NAME'"
  else
    echo "⚠️  Falha ao aplicar política pública ao bucket '$BUCKET_NAME'"
  fi

  S3_ACCESS_KEY=$(head /dev/urandom | tr -dc A-Z0-9 | head -c 20)
  S3_SECRET_KEY=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 40)

  if $MC_CMD admin user add admin "$S3_ACCESS_KEY" "$S3_SECRET_KEY"; then
    echo "✅ Usuário criado com sucesso:"
    echo "Access Key: $S3_ACCESS_KEY"
    echo "Secret Key: $S3_SECRET_KEY"
  else
    echo "❌ Falha ao criar usuário no MinIO"
    return 1
  fi

  if $MC_CMD admin policy attach admin readwrite --user "$S3_ACCESS_KEY"; then
    echo "✅ Política 'readwrite' anexada ao usuário $S3_ACCESS_KEY"
  else
    echo "⚠️  Falha ao anexar política ao usuário $S3_ACCESS_KEY"
  fi


  $MC_CMD ls admin || echo "⚠️  Falha ao listar buckets no MinIO"

  export S3_ENDPOINT
  export S3_ACCESS_KEY
  export S3_SECRET_KEY
}

minio.bucket.setup() {
  dados
  pegar_senha_minio

  ADMIN_USER="$user_minio"
  ADMIN_PASS="$senha_minio"

  MINIO_CONTAINER=$(docker ps --filter "name=minio" -q | head -n1)
  if [ -z "$MINIO_CONTAINER" ]; then
    echo "❌ Container MinIO não encontrado!"
    exit 1
  fi

  MC_CMD="docker exec -i $MINIO_CONTAINER mc"
  S3_ENDPOINT=""
  ENDPOINTS=("http://minio:9000" "http://localhost:9000")

  for endpoint in "${ENDPOINTS[@]}"; do
    if $MC_CMD alias set admin "$endpoint" "$ADMIN_USER" "$ADMIN_PASS" >/dev/null 2>&1; then
      S3_ENDPOINT="$endpoint"
      echo "✅ Conectado com sucesso ao MinIO via $S3_ENDPOINT"
      break
    fi
  done

  if [ -z "$S3_ENDPOINT" ]; then
    echo -e "\n❌ Falha ao conectar com os endpoints padrão (minio, localhost)."
    echo -en "\e[33m👉 Digite manualmente o endpoint (ex: http://ip:9000): \e[0m"
    read -r S3_ENDPOINT

    $MC_CMD alias set admin "$S3_ENDPOINT" "$ADMIN_USER" "$ADMIN_PASS" || {
      echo "❌ Ainda não foi possível conectar. Verifique o endpoint e tente novamente."
      exit 1
    }
    echo "✅ Conectado com sucesso ao MinIO via $S3_ENDPOINT"
  fi

  echo -e "\n\e[97mPasso$amarelo 1/1\e[0m"
  echo -en "\e[33mDigite o nome do Bucket (ex: arquivos): \e[0m"
  read -r BUCKET
  echo ""


  if $MC_CMD ls admin/"$BUCKET" >/dev/null 2>&1; then
    echo "⚠️ Bucket '$BUCKET' já existe, continuando..."
  else
    if $MC_CMD mb admin/"$BUCKET"; then
      echo "✅ Bucket '$BUCKET' criado com sucesso!"
    else
      echo "⚠️ Falha ao criar bucket '$BUCKET', mas continuando..."
    fi
  fi


  if $MC_CMD anonymous set public admin/"$BUCKET"; then
    echo "✅ Política 'public' aplicada ao bucket '$BUCKET'"
  else
    echo "⚠️ Falha ao aplicar política pública ao bucket '$BUCKET'"
  fi


  S3_ACCESS_KEY=$(head /dev/urandom | tr -dc A-Z0-9 | head -c 20)
  S3_SECRET_KEY=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 40)

  if $MC_CMD admin user add admin "$S3_ACCESS_KEY" "$S3_SECRET_KEY"; then
    echo "✅ Usuário criado com sucesso!"
  else
    echo "❌ Erro ao criar usuário"
    exit 1
  fi

  if $MC_CMD admin policy attach admin readwrite --user "$S3_ACCESS_KEY"; then
    echo "✅ Política 'readwrite' anexada ao usuário $S3_ACCESS_KEY"
  else
    echo "⚠️ Falha ao anexar política ao usuário"
  fi

  $MC_CMD alias set myminio "$S3_ENDPOINT" "$S3_ACCESS_KEY" "$S3_SECRET_KEY"
  $MC_CMD ls myminio/"$BUCKET" || echo "⚠️ Falha ao listar bucket"

   echo ""
   echo -e "\e[32m[ BUCKET $BUCKET ]\e[0m"
   echo ""
   echo -e "\e[33mS3 Endpoint:\e[97m $S3_ENDPOINT\e[0m"
   echo ""
   echo -e "\e[33mNome da Bucket:\e[97m $BUCKET\e[0m"
   echo ""
   echo -e "\e[33mAccess Key:\e[97m $S3_ACCESS_KEY\e[0m"
   echo ""
   echo -e "\e[33mSecret Key:\e[97m $S3_SECRET_KEY\e[0m"
 
   creditos_msg
   requisitar_outra_instalacao
}


minio.bucket.delete() {
  echo -en "\e[33m👉 Digite o nome da Bucket que deseja remover (ex: arquivos): \e[0m"
  read -r BUCKET

  POLICY_NAME="publicread-$BUCKET"

  # Descobre o container do MinIO
  MINIO_CONTAINER=$(docker ps --filter "name=minio" -q | head -n1)
  if [ -z "$MINIO_CONTAINER" ]; then
    echo "❌ Container MinIO não encontrado!"
    exit 1
  fi

  MC_CMD="docker exec -i $MINIO_CONTAINER mc"

  echo -e "\n🔍 Buscando usuário vinculado à política $POLICY_NAME..."
  USER_ACCESS_KEY=$($MC_CMD admin policy entities admin "$POLICY_NAME" 2>/dev/null | grep -oP '(?<=user\s)[^\s]+')

  if [ -z "$USER_ACCESS_KEY" ]; then
    echo "❌ Não foi possível encontrar o usuário com a política '$POLICY_NAME'."
    exit 1
  fi

  echo "🔸 Usuário identificado: $USER_ACCESS_KEY"

  echo -e "\n🧹 Limpando bucket, política e usuário..."

  # Remove acesso anônimo
  $MC_CMD anonymous set download admin/"$BUCKET" >/dev/null 2>&1 || echo "⚠️ Falha ao remover acesso anônimo"

  # Remove o usuário
  $MC_CMD admin user remove admin "$USER_ACCESS_KEY" >/dev/null 2>&1 || echo "⚠️ Falha ao remover usuário"

  # Remove a política
  $MC_CMD admin policy remove admin "$POLICY_NAME" >/dev/null 2>&1 || echo "⚠️ Falha ao remover política"

  # Remove a bucket com todos os objetos
  $MC_CMD rb --force admin/"$BUCKET" >/dev/null 2>&1 || {
    echo "❌ Falha ao remover a bucket. Verifique se ela existe e está vazia."
    exit 1
  }

  echo -e "\n✅ \e[32mBucket '$BUCKET' e recursos associados removidos com sucesso!\e[0m"
}


## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

## Iniciando instalador

## Mostrar nome do instalador
nome_instalador

## Mostrar direitos do instalador
direitos_instalador

##Após apetar Y e confirmar continua..

## Menu de opções (backend)
while true; do

    nome_menu
    menu_instalador

    read -p "Digite o NÚMERO da opção desejada ou COMANDO oculto: " opcao

    set -- $opcao
    opcao1=$1
    opcao2=$2

    case $opcao1 in

        0|00|teste_smtp|TESTE_SMTP)
            ferramenta_testeemail
            ;;

        1|01|portainer|traefik|PORTAINER|TRAEFIK)
            verificar_stack "traefik" && continue || echo ""
            verificar_stack "portainer" && continue || echo ""

            ferramenta_traefik_e_portainer
            ;;

        2|02|chatwoot|CHATWOOT)

            verificar_stack "chatwoot${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="chatwoot${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_chatwoot "$opcao2"
                else
                    APP_ORION="ferramenta_chatwoot"
                    verificar_arquivo
                fi
                ## FIM TOKEN 
            fi
            ;;

        3|03|evolution|evo|EVO)

            verificar_stack "evolution${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="evolution${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_evolution "$opcao2"
                else
                    APP_ORION="ferramenta_evolution"
                    verificar_arquivo
                fi
                ## FIM TOKEN 
            fi
            ;;
        4|04|minio|MINIO)

            verificar_stack "minio${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="minio${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_minio "$opcao2"
                else
                    APP_ORION="ferramenta_minio"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        5|05|typebot|TYPEBOT)

            verificar_stack "typebot${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_minio; then
                ## INICIO TOKEN
                STACK_NAME="typebot${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_typebot "$opcao2"
                else
                    APP_ORION="ferramenta_typebot"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        6|06|n8n|N8N)

            verificar_stack "n8n${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="n8n${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_n8n "$opcao2"
                else
                    APP_ORION="ferramenta_n8n"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        7|07|flowise|FLOWISE)

            verificar_stack "flowise${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="flowise${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_flowise "$opcao2"
                else
                    APP_ORION="ferramenta_flowise"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        8|08|pgadmin|PGADMIN)

            verificar_stack "pgadmin${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="pgadmin${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_pgAdmin_4 "$opcao2"
                else
                    APP_ORION="ferramenta_pgAdmin_4"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        9|09|nocobase|NOCOBASE)

            verificar_stack "nocobase${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="nocobase${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_nocobase "$opcao2"
                else
                    APP_ORION="ferramenta_nocobase"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        10|botpress|BOTPRESS)

            verificar_stack "botpress${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="botpress${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_botpress "$opcao2"
                else
                    APP_ORION="ferramenta_botpress"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        11|wordpress|WORDPRESS)
            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_wordpress
                else
                    APP_ORION="ferramenta_wordpress"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        12|baserow|BASEROW)

            verificar_stack "baserow${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="baserow${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_baserow "$opcao2"
                else
                    APP_ORION="ferramenta_baserow" 
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        13|mongodb|MONGODB)

            verificar_stack "mongodb${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="mongodb${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_mongodb "$opcao2"
                else
                    APP_ORION="ferramenta_mongodb"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        14|rabbitmq|RABBITMQ)

            verificar_stack "rabbitmq${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="rabbitmq${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_rabbitmq "$opcao2"
                else
                    APP_ORION="ferramenta_rabbitmq"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        15|uptimekuma|UPTIMEKUMA)

            verificar_stack "uptimekuma${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="uptimekuma${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_uptimekuma "$opcao2"
                else
                    APP_ORION="ferramenta_uptimekuma"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        16|calcom|CALCOM)

            verificar_stack "calcom${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="calcom${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_calcom "$opcao2"
                else
                    APP_ORION="ferramenta_calcom"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        17|mautic|MAUTIC)

            verificar_stack "mautic${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="mautic${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_mautic "$opcao2"
                else
                    APP_ORION="ferramenta_mautic"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        18|appsmith|APPSMITH)

            verificar_stack "appsmith${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="appsmith${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_appsmith "$opcao2"
                else
                    APP_ORION="ferramenta_appsmith"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        19|qdrant|QDRANT)

            verificar_stack "qdrant${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="qdrant${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_qdrant "$opcao2"
                else
                    APP_ORION="ferramenta_qdrant"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        20|woofedcrm|WOOFEDCRM)

            verificar_stack "woofedcrm${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="woofedcrm${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_woofed "$opcao2"
                else
                    APP_ORION="ferramenta_woofed"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        21|formbricks|FORMBRICKS)

            verificar_stack "formbricks${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_minio; then
                ## INICIO TOKEN
                STACK_NAME="formbricks${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_formbricks "$opcao2"
                else
                    APP_ORION="ferramenta_formbricks"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        22|nocodb|NOCODB)

            verificar_stack "nocodb${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="nocodb${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_nocodb "$opcao2"
                else
                    APP_ORION="ferramenta_nocodb"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        23|langfuse|LANGFUSE)

            verificar_stack "langfuse${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_minio && verificar_antes_se_tem_clickhouse; then
                ## INICIO TOKEN
                STACK_NAME="langfuse${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_langfuse "$opcao2"
                else
                    APP_ORION="ferramenta_langfuse"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        24|metabase|METABASE)

            verificar_stack "metabase${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="metabase${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_metabase "$opcao2"
                else
                    APP_ORION="ferramenta_metabase"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        25|odoo|ODOO)

            verificar_stack "odoo${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="odoo${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_odoo "$opcao2"
                else
                    APP_ORION="ferramenta_odoo"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;

        26|unoapi|UNOAPI)

            verificar_stack "unoapi${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_rabbitmq; then
                ## INICIO TOKEN
                STACK_NAME="unoapi${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_unoapi "$opcao2"
                else
                    APP_ORION="ferramenta_unoapi"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;

        27|quepasa|QUEPASA)

            verificar_stack "quepasa${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="quepasa${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_quepasa "$opcao2"
                else
                    APP_ORION="ferramenta_quepasa"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        28|docuseal|DOCUSEAL)

            verificar_stack "docuseal${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="docuseal${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_docuseal "$opcao2"
                else
                    APP_ORION="ferramenta_docuseal"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        29|monitor|grafana|MONITOR|GRAFANA)

            verificar_stack "monitor${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="monitor${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_monitor "$opcao2"
                else
                    APP_ORION="ferramenta_monitor"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        30|dify|DIFY)

            verificar_stack "dify${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_minio; then
                ## INICIO TOKEN
                STACK_NAME="dify${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_dify "$opcao2"
                else
                    APP_ORION="ferramenta_dify"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        31|ollama|OLLAMA)

            verificar_stack "ollama${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="ollama${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_ollama "$opcao2"
                else
                    APP_ORION="ferramenta_ollama"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        32|affine|AFFINE)

            verificar_stack "affine${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="affine${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_affine "$opcao2"
                else
                    APP_ORION="ferramenta_affine"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        33|directus|DIRECTUS)

            verificar_stack "directus${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_minio; then
                ## INICIO TOKEN
                STACK_NAME="directus${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_directus "$opcao2"
                else
                    APP_ORION="ferramenta_directus"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        34|vaultwarden|VAULTWARDEN)

            verificar_stack "vaultwarden${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="vaultwarden${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_vaultwarden "$opcao2"
                else
                    APP_ORION="ferramenta_vaultwarden"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        35|nextcloud|NEXTCLOUD)

            verificar_stack "nextcloud${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="nextcloud${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_nextcloud "$opcao2"
                else
                    APP_ORION="ferramenta_nextcloud"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        36|strapi|STRAPI)

            verificar_stack "strapi${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="strapi${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_strapi "$opcao2"
                else
                    APP_ORION="ferramenta_strapi"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        37|phpmyadmin|pma|PHPMYADMIN|PMA)

            verificar_stack "phpmyadmin${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="phpmyadmin${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_phpmyadmin "$opcao2"
                else
                    APP_ORION="ferramenta_phpmyadmin"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        38|supabase|supa|SUPABASE|SUPA)

            verificar_stack "supabase${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="supabase${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_supabase "$opcao2"
                else
                    APP_ORION="ferramenta_supabase"
                    verificar_arquivo
                fi
                ## FIM TOKEN            
            fi
            ;;
        39|ntfy|NTFY)

            verificar_stack "ntfy${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="ntfy${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_ntfy "$opcao2"
                else
                    APP_ORION="ferramenta_ntfy"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi   
            ;;
        40|lowcoder|LOWCODER)

            verificar_stack "lowcoder${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_mongo; then
                ## INICIO TOKEN
                STACK_NAME="lowcoder${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_lowcoder "$opcao2"
                else
                    APP_ORION="ferramenta_lowcoder"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi   
            ;;
        41|langflow|LANGFLOW)

            verificar_stack "langflow${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="langflow${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_langflow "$opcao2"
                else
                    APP_ORION="ferramenta_langflow"
                    ferramenta_langflow
                fi
                ## FIM TOKEN
            fi   
            ;;
        42|openproject|OPENPROJECT)

            verificar_stack "openproject${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="openproject${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_openproject "$opcao2"
                else
                    APP_ORION="ferramenta_openproject"
                    ferramenta_openproject
                fi
                ## FIM TOKEN
            fi   
            ;;
        43|zep|ZEP)

            verificar_stack "zep${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="zep${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_zep "$opcao2"
                else
                    APP_ORION="ferramenta_zep"
                    ferramenta_zep
                fi
                ## FIM TOKEN
            fi   
            ;;
        44|humhub|HUMHUB)

            verificar_stack "humhub${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="humhub${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_humhub "$opcao2"
                else
                    APP_ORION="ferramenta_humhub"
                    ferramenta_humhub
                fi
                ## FIM TOKEN
            fi   
            ;;
        45|yourls|YOURLS)

            verificar_stack "yourls${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="yourls${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_yourls "$opcao2"
                else
                    APP_ORION="ferramenta_yourls"
                    ferramenta_yourls
                fi
                ## FIM TOKEN
            fi   
            ;;

        46|twentycrm|TWENTYCRM)

            verificar_stack "twentycrm${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="twentycrm${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_twentycrm "$opcao2"
                else
                    APP_ORION="ferramenta_twentycrm"
                    ferramenta_twentycrm
                fi
                ## FIM TOKEN
            fi   
            ;;

        47|mattermost|MATTERMOST) 

            verificar_stack "mattermost${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="mattermost${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_mattermost "$opcao2"
                else
                    APP_ORION="ferramenta_mattermost"
                    ferramenta_mattermost
                fi
                ## FIM TOKEN
            fi   
            ;;

        48|outline|OUTLINE)

            verificar_stack "outline${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="outline${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_outline "$opcao2"
                else
                    APP_ORION="ferramenta_outline"
                    ferramenta_outline
                fi
                ## FIM TOKEN
            fi   
            ;;

        49|focalboard|FOCALBOARD) 

            verificar_stack "focalboard${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="focalboard${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_focalboard "$opcao2"
                else
                    APP_ORION="ferramenta_focalboard"
                    ferramenta_focalboard
                fi
                ## FIM TOKEN
            fi   
            ;;

        50|glpi|GLPI) 

            verificar_stack "glpi${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="glpi${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_glpi "$opcao2"
                else
                    APP_ORION="ferramenta_glpi"
                    ferramenta_glpi
                fi
                ## FIM TOKEN
            fi   
            ;;

        51|anythingllm|anything|AnythingLLM|Anything) 

            verificar_stack "anythingllm${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="anythingllm${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_anythingllm "$opcao2"
                else
                    APP_ORION="ferramenta_anythingllm"
                    ferramenta_anythingllm
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        52|excalidraw|Excalidraw) 

            verificar_stack "excalidraw${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="excalidraw${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_excalidraw "$opcao2"
                else
                    APP_ORION="ferramenta_excalidraw"
                    ferramenta_excalidraw
                fi
                ## FIM TOKEN
            fi   
            ;;

        53|easyappointments|EasyAppointments|Easy!Appointments|easy!appointments) 

            verificar_stack "easyappointments${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="easyappointments${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_easyappointments "$opcao2"
                else
                    APP_ORION="ferramenta_easyappointments"
                    ferramenta_easyappointments
                fi
                ## FIM TOKEN
            fi   
            ;;

        54|documenso|Documenso) 

            verificar_stack "documenso${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_minio; then
                ## INICIO TOKEN
                STACK_NAME="documenso${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_documenso "$opcao2"
                else
                    APP_ORION="ferramenta_documenso"
                    ferramenta_documenso
                fi
                ## FIM TOKEN
            fi   
            ;;

        #55|moodle|MOODLE) 
        #
        #    verificar_stack "moodle${opcao2:+_$opcao2}" && continue || echo ""
        #
        #    if verificar_docker_e_portainer_traefik; then
        #        ## INICIO TOKEN
        #        STACK_NAME="moodle${opcao2:+_$opcao2}"
        #        if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
        #            ferramenta_moodle "$opcao2"
        #        else
        #            APP_ORION="ferramenta_moodle"
        #            ferramenta_moodle
        #        fi
        #        ## FIM TOKEN
        #    fi   
        #    ;;

        55|tooljet|TOOLJET)

            verificar_stack "tooljet${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="tooljet${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_tooljet "$opcao2"
                else
                    APP_ORION="ferramenta_tooljet"
                    ferramenta_tooljet
                fi
                ## FIM TOKEN
            fi   
            ;;

        56|StirlingPDF|Stirling|stirling) 

            verificar_stack "stirlingpdf${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="stirlingpdf${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_stirlingpdf "$opcao2"
                else
                    APP_ORION="ferramenta_stirlingpdf"
                    ferramenta_stirlingpdf
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        57|ClickHouse|clickhouse|CLICKHOUSE)

            verificar_stack "clickhouse${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="clickhouse${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_clickhouse "$opcao2"
                else
                    APP_ORION="ferramenta_clickhouse"
                    ferramenta_clickhouse
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        58|RedisInsight|redisinsight|REDISINSIGHT) 

            verificar_stack "redisinsight${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="redisinsight${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_redisinsight "$opcao2"
                else
                    APP_ORION="ferramenta_redisinsight"
                    ferramenta_redisinsight
                fi
                ## FIM TOKEN
            fi   
            ;;

        59|Traccar|traccar|TRACCAR) 

            verificar_stack "traccar${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="traccar${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_traccar "$opcao2"
                else
                    APP_ORION="ferramenta_traccar"
                    ferramenta_traccar
                fi
                ## FIM TOKEN
            fi   
            ;;

        60|Firecrawl|firecrawl|FIRECRAWL) 

            verificar_stack "firecrawl${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="firecrawl${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_firecrawl "$opcao2"
                else
                    APP_ORION="ferramenta_firecrawl"
                    ferramenta_firecrawl
                fi
                ## FIM TOKEN
            fi   
            ;;

        61|Wuzapi|wuzapi|WUZAPI) 

            verificar_stack "wuzapi${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="wuzapi${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_wuzapi "$opcao2"
                else
                    APP_ORION="ferramenta_wuzapi"
                    ferramenta_wuzapi
                fi
                ## FIM TOKEN
            fi   
            ;;

        62|KrayinCRM|krayincrm|KRAYINCRM) 

            verificar_stack "krayincrm${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="krayincrm${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_krayincrm "$opcao2"
                else
                    APP_ORION="ferramenta_krayincrm"
                    ferramenta_krayincrm
                fi
                ## FIM TOKEN
            fi   
            ;;

        63|Planka|planka|PLANKA) 

            verificar_stack "planka${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="planka${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_planka "$opcao2"
                else
                    APP_ORION="ferramenta_planka"
                    ferramenta_planka
                fi
                ## FIM TOKEN
            fi   
            ;;

        64|WppConnect|wppconnect|WPPCONNECT) 

            verificar_stack "wppconnect${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="wppconnect${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_wppconnect "$opcao2"
                else
                    APP_ORION="ferramenta_wppconnect"
                    ferramenta_wppconnect
                fi
                ## FIM TOKEN
            fi   
            ;;

        65|Browserless|browserless|BROWSERLESS) 

            verificar_stack "browserless${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="browserless${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_browserless "$opcao2"
                else
                    APP_ORION="ferramenta_browserless"
                    ferramenta_browserless
                fi
                ## FIM TOKEN
            fi   
            ;;

        66|Frappe|frappe|FRAPPE) 

            verificar_stack "erpnext${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="erpnext${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_frappe "$opcao2"
                else
                    APP_ORION="ferramenta_frappe"
                    ferramenta_frappe
                fi
                ## FIM TOKEN
            fi   
            ;;

        67|Bolt|bolt|BOLT) 

            verificar_stack "bolt${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="bolt${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_bolt "$opcao2"
                else
                    APP_ORION="ferramenta_bolt"
                    ferramenta_bolt
                fi
                ## FIM TOKEN
            fi   
            ;;

        68|WiseMapping|wisemapping|WISEMAPPING) 

            verificar_stack "wisemapping${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="wisemapping${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_wisemapping "$opcao2"
                else
                    APP_ORION="ferramenta_wisemapping"
                    ferramenta_wisemapping
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        69|EvoAPI|evoapi|EVOAPI) 

            verificar_stack "evoai${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="evoai${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_evoai "$opcao2"
                else
                    APP_ORION="ferramenta_evoai"
                    ferramenta_evoai
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        70|Keycloak|keycloak|KEYCLOAK) 

            verificar_stack "keycloak${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="keycloak${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_keycloak "$opcao2"
                else
                    APP_ORION="ferramenta_keycloak"
                    ferramenta_keycloak
                fi
                ## FIM TOKEN
            fi   
            ;;

        71|Passbolt|passbolt|PASSBOLT) 

            verificar_stack "passbolt${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="passbolt${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_passbolt "$opcao2"
                else
                    APP_ORION="ferramenta_passbolt"
                    ferramenta_passbolt
                fi
                ## FIM TOKEN
            fi   
            ;;
          
        72|Gotenberg|gotenberg|GOTENBERG) 

            verificar_stack "gotenberg${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="gotenberg${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_gotenberg "$opcao2"
                else
                    APP_ORION="ferramenta_gotenberg"
                    ferramenta_gotenberg
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        73|Wiki|wiki|WIKI) 

            verificar_stack "wiki${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="wiki${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_wiki "$opcao2"
                else
                    APP_ORION="ferramenta_wiki"
                    ferramenta_wiki
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        74|AzuraCast|azuracast|AZURACAST) 

            verificar_stack "azuracast${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="azuracast${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_azuracast "$opcao2"
                else
                    APP_ORION="ferramenta_azuracast"
                    ferramenta_azuracast
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        75|Shlink|shlink|SHLINK) 

            verificar_stack "shlink${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="shlink${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_shlink "$opcao2"
                else
                    APP_ORION="ferramenta_shlink"
                    ferramenta_shlink
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        76|RustDesk|rustdesk|RUSTDESK) 

            verificar_stack "rustdesk${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="rustdesk${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_rustdesk "$opcao2"
                else
                    APP_ORION="ferramenta_rustdesk"
                    ferramenta_rustdesk
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        77|Hoppscotch|hoppscotch|HOPPSCOTCH) 

            verificar_stack "hoppscotch${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="hoppscotch${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_hoppscotch "$opcao2"
                else
                    APP_ORION="ferramenta_hoppscotch"
                    ferramenta_hoppscotch
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        78|transcreve|transcrevezap|TRANSCREVE|TRANSCREVEZAP) 

            verificar_stack "transcrevezap${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="transcrevezap${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_transcrevezap "$opcao2"
                else
                    APP_ORION="ferramenta_transcrevezap"
                    ferramenta_transcrevezap
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        79|omnitools|OMNITOOLS) 

            verificar_stack "omnitools${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="omnitools${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_omnitools "$opcao2"
                else
                    APP_ORION="ferramenta_omnitools"
                    ferramenta_omnitools
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        80|serpbear|SERPBEAR) 

            verificar_stack "serpbear${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="serpbear${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_serpbear "$opcao2"
                else
                    APP_ORION="ferramenta_serpbear"
                    ferramenta_serpbear
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        81|ActivePieces|activepieces|ACTIVEPIECES)

            verificar_stack "activepieces${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="activepieces${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_activepieces "$opcao2"
                else
                    APP_ORION="ferramenta_activepieces"
                    ferramenta_activepieces
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        82|authentik|AUTHENTIK)

            verificar_stack "authentik${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="authentik${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_authentik "$opcao2"
                else
                    APP_ORION="ferramenta_authentik"
                    ferramenta_authentik
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        83|checkmate|CHECKMATE)

            verificar_stack "checkmate${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_mongo; then
                ## INICIO TOKEN
                STACK_NAME="checkmate${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_checkmate "$opcao2"
                else
                    APP_ORION="ferramenta_checkmate"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        
        84|heyform|HEYFORM)

            verificar_stack "heyform${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_mongo; then
                ## INICIO TOKEN
                STACK_NAME="heyform${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_heyform "$opcao2"
                else
                    APP_ORION="ferramenta_heyform"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        
        85|wekan|WEKAN)

            verificar_stack "wekan${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_mongo; then
                ## INICIO TOKEN
                STACK_NAME="wekan${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_wekan "$opcao2"
                else
                    APP_ORION="ferramenta_wekan"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        
        86|opensign|OPENSIGN)

            verificar_stack "opensign${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik && verificar_antes_se_tem_mongo; then
                ## INICIO TOKEN
                STACK_NAME="opensign${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_opensign "$opcao2"
                else
                    APP_ORION="ferramenta_opensign"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        
        87|docmost|DOCMOST)

            verificar_stack "docmost${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="docmost${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_docmost "$opcao2"
                else
                    APP_ORION="ferramenta_docmost"
                    ferramenta_docmost
                fi
                ## FIM TOKEN
            fi   
            ;;

        88|netbox|NETBOX)

            verificar_stack "netbox${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="netbox${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_netbox "$opcao2"
                else
                    APP_ORION="ferramenta_netbox"
                    ferramenta_netbox
                fi
                ## FIM TOKEN
            fi   
            ;;

        89|kafka|KAFKA)

            verificar_stack "kafka${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="kafka${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_kafka "$opcao2"
                else
                    APP_ORION="ferramenta_kafka"
                    ferramenta_kafka
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        90|astracampaign|ASTRACAMPAIGN)

            verificar_stack "astracampaign${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="astracampaign${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_astracampaign "$opcao2"
                else
                    APP_ORION="ferramenta_astracampaign"
                    ferramenta_astracampaign
                fi
                ## FIM TOKEN
            fi   
            ;;

        91|duplicati|DUPLICATI)

            verificar_stack "duplicati${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="duplicati${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_duplicati "$opcao2"
                else
                    APP_ORION="ferramenta_duplicati"
                    ferramenta_duplicati
                fi
                ## FIM TOKEN
            fi   
            ;;

        92|pgbackweb|PGBACKWEB)

            verificar_stack "pgbackweb${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="pgbackweb${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_pgbackweb "$opcao2"
                else
                    APP_ORION="ferramenta_pgbackweb"
                    ferramenta_pgbackweb
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        93|jitsimeet|jitsi|JITSIMET|JITSI)

            verificar_stack "jitsi${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="jitsi${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_jitsi "$opcao2"
                else
                    APP_ORION="ferramenta_jitsi"
                    ferramenta_jitsi
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        94|code_server|CODE_SERVER|codeserver|CODESERVER)

            verificar_stack "code_server${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="code_server${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_code_server "$opcao2"
                else
                    APP_ORION="ferramenta_code_server"
                    ferramenta_code_server
                fi
                ## FIM TOKEN
            fi   
            ;;
        
        95|papra|PAPRA)

            verificar_stack "papra${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="papra${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_papra "$opcao2"
                else
                    APP_ORION="ferramenta_papra"
                    ferramenta_papra
                fi
                ## FIM TOKEN
            fi   
            ;;

        96|zerobyte|ZEROBYTE)

            verificar_stack "zerobyte${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="zerobyte${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_zerobyte "$opcao2"
                else
                    APP_ORION="ferramenta_zerobyte"
                    ferramenta_zerobyte
                fi
                ## FIM TOKEN
            fi   
            ;;

        ##remover.stack)
        ##    if verificar_docker_e_portainer_traefik; then
        ##
        ##        ferramenta_remover_stack
        ##
        ##    fi   
        ##    ;;

        sair|fechar|exit|close|x)
            clear
            nome_saindo
            echo ""
            break
            ;;

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

        postgres)

            verificar_stack "postgres${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="postgres${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_postgres_setup "$opcao2"
                else
                    APP_ORION="ferramenta_postgres_setup"
                    ferramenta_postgres_setup
                fi

                ## FIM TOKEN

            fi   
            ;;

        mysql)

            verificar_stack "mysql${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="mysql${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_mysql_setup "$opcao2"
                else
                    APP_ORION="ferramenta_mysql_setup"
                    ferramenta_mysql_setup
                fi

                ## FIM TOKEN

            fi   
            ;;

        redis)

            verificar_stack "redis${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="redis${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_redis_setup "$opcao2"
                else
                    APP_ORION="ferramenta_redis_setup"
                    ferramenta_redis_setup
                fi

                ## FIM TOKEN

            fi   
            ;;
        pgvector)

            verificar_stack "pgvector${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="pgvector${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_pgvector_setup "$opcao2"
                else
                    APP_ORION="ferramenta_pgvector_setup"
                    ferramenta_pgvector_setup
                fi

                ## FIM TOKEN

            fi
            ;;
            

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
        
        evolution.v1)

            verificar_stack "evolution_v1${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="evolution_v1${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_evolution_v1 "$opcao2"
                else
                    APP_ORION="ferramenta_evolution_v1"
                    ferramenta_evolution_v1
                fi

                ## FIM TOKEN

            fi   
            ;;

        evolution.v2)

            verificar_stack "evolution_v2${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="evolution_v2${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_evolution_v2 "opcao2"
                else
                    APP_ORION="ferramenta_evolution_v2${opcao2:+_$opcao2}"
                    ferramenta_evolution_v2 "$opcao2"
                fi

                ## FIM TOKEN

            fi   
            ;;

        evolution.lite)

            verificar_stack "evolution_lite${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="evolution_lite${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_evolution_lite "$opcao2"
                else
                    APP_ORION="ferramenta_evolution_lite${opcao2:+_$opcao2}"
                    ferramenta_evolution_lite "$opcao2"
                fi

                ## FIM TOKEN

            fi   
            ;;
        
        transcrevezap)

            verificar_stack "transcrevezap${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="transcrevezap${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_transcrevezap "$opcao2"
                else
                    APP_ORION="transcrevezap${opcao2:+_$opcao2}"
                    ferramenta_transcrevezap "$opcao2"
                fi

                ## FIM TOKEN

            fi   
            ;;
        n8n.mcp)

            verificar_stack "n8n${opcao2:+_$opcao2}_mcp" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="n8n${opcao2:+_$opcao2}_mcp"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    n8n.mcp "$opcao2"
                else
                    APP_ORION="n8n${opcao2:+_$opcao2}_mcp"
                    n8n.mcp "$opcao2"
                fi

                ## FIM TOKEN

            fi   
            ;;
          
          openwebui)

            verificar_stack "openwebui${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then

                ## INICIO TOKEN

                STACK_NAME="openwebui${opcao2:+_$opcao2}"

                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_openwebui "$opcao2"
                else
                    APP_ORION="openwebui${opcao2:+_$opcao2}"
                    ferramenta_openwebui "$opcao2"
                fi

                ## FIM TOKEN

            fi   
            ;;
        
        chatwoot.mega)

            verificar_stack "chatwoot_nestor${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="chatwoot_nestor${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_chatwoot_nestor "$opcao2"
                else
                    APP_ORION="ferramenta_chatwoot_nestor"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;
        
        n8n.quepasa)

            verificar_stack "n8n_quepasa${opcao2:+_$opcao2}" && continue || echo ""

            if verificar_docker_e_portainer_traefik; then
                ## INICIO TOKEN
                STACK_NAME="n8n_quepasa${opcao2:+_$opcao2}"
                if grep -q "Token: .\+" /root/dados_vps/dados_portainer; then
                    ferramenta_n8n_quepasa "$opcao2"
                else
                    APP_ORION="ferramenta_n8n_quepasa"
                    verificar_arquivo
                fi
                ## FIM TOKEN
            fi
            ;;

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##

        ## Reiniciar portainer
        portainer.restart)
            portainer.restart
            ;;

        ## Redefinir senha do portainer
        portainer.reset)
            portainer.reset
            ;;
        
        ## Atualizar portainer
        portainer.update)
            portainer.update
            ;;
        
        ## Atualizar o traefik
        traefik.update)
            traefik.update
            ;;
        
        ## Ativar o dashboard do traefik
        traefik.dash)
            traefik.dash
            ;;

        ## Traduzir emails do Chatwoot
        chatwoot.mail)
            chatwoot.mail
            ;;

        ## Traduzir emails do Chatwoot N
        chatwoot.n.mail)
            chatwoot.n.mail
            ;;

        ## Importar Workflows do Quepasa no N8N
        n8n.workflows)
            n8n.workflows
            ;;

        ## Corrigir imagem da stack do traefik para 2.11.2
        traefik.fix)
            traefik.fix    
            ;;

        ## Instalar CTOP
        ctop)
            ctop
            ;;
        
        ## Instalar HTOP
        htop)
            htop
            ;;

        minio.bucket)
            minio.bucket.setup
            ;;
          
        minio.bucket.delete)
            minio.bucket.delete
            ;;
        
        ## Corrigir credenciais do portainer (para instalações)
        credencial.reset)
            criar_arquivo
            ;;

        quepasa.setup.off)
            quepasa.setup.off
            ;;

        quepasa.setup.on)
            quepasa.setup.on
            ;;

        p1|P1)
            menu_instalador="1"
            ;;

        p2|P2)
            menu_instalador="2"
            ;;
        
        p3|P3)
            menu_instalador="3"
            ;;

        comando|COMANDO|comandos|COMANDOS) menu_instalador="4"
            ;;
        
        limpar|clean|LIMPAR|CLEAN|expurgar|EXPURGAR)
            limpar
            ;;
        
        docker.fix)
            docker.fix
            ;;

        docker.fix2)
            docker.fix2
            ;;

## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##
##                                         ORION DESIGN                                        ##
## // ## // ## // ## // ## // ## // ## // ## //## // ## // ## // ## // ## // ## // ## // ## // ##


        *)

            ;;
    esac
    echo ""
done